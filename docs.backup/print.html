<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FunLang: F#로 만드는 프로그래밍 언어</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="fslex/fsyacc를 사용한 인터프리터 구축 튜토리얼">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b2e0a5d9.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-2aa7beb1.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">FunLang: F#로 만드는 프로그래밍 언어</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/shohruh-abduakhatov-portfolio/LangTutorial" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="funlang-f로-만드는-프로그래밍-언어"><a class="header" href="#funlang-f로-만드는-프로그래밍-언어">FunLang: F#로 만드는 프로그래밍 언어</a></h1>
<p>F#과 fslex/fsyacc를 사용하여 함수형 프로그래밍 언어 인터프리터를 구축하는 튜토리얼입니다.</p>
<h2 id="목표"><a class="header" href="#목표">목표</a></h2>
<ul>
<li><strong>Lexer/Parser</strong>: fslex와 fsyacc로 토큰화 및 구문 분석</li>
<li><strong>AST</strong>: 추상 구문 트리 설계</li>
<li><strong>Interpreter</strong>: 트리-워킹 인터프리터 구현</li>
<li><strong>Type System</strong>: Hindley-Milner 타입 추론</li>
</ul>
<h2 id="funlang-특징"><a class="header" href="#funlang-특징">FunLang 특징</a></h2>
<pre><code>// 변수 바인딩
let x = 42

// 함수 정의
let add = fun x y -&gt; x + y

// 재귀 함수
let rec factorial = fun n -&gt;
  if n &lt;= 1 then 1
  else n * factorial (n - 1)

// 패턴 매칭
let rec length = fun lst -&gt;
  match lst with
  | [] -&gt; 0
  | _ :: tail -&gt; 1 + length tail

// 타입 추론
let compose = fun f g x -&gt; f (g x)
</code></pre>
<h2 id="시작하기"><a class="header" href="#시작하기">시작하기</a></h2>
<p><a href="#chapter-1-foundation--pipeline">Chapter 1: 프로젝트 기초</a>부터 시작하세요.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-1-foundation--pipeline"><a class="header" href="#chapter-1-foundation--pipeline">Chapter 1: Foundation &amp; Pipeline</a></h1>
<p>.NET 10과 FsLexYacc를 사용하여 언어 구현의 기초를 설정한다. 이 chapter에서는 아직 실행 가능한 인터프리터를 만들지 않고, Lexer → Parser → AST 파이프라인의 뼈대만 구축한다.</p>
<h2 id="개요"><a class="header" href="#개요">개요</a></h2>
<p>이 chapter에서 다루는 내용:</p>
<ul>
<li>.NET 10 F# 프로젝트 생성</li>
<li>FsLexYacc 패키지 설치</li>
<li>AST 타입 정의 (Discriminated Union)</li>
<li>fslex로 Lexer 작성</li>
<li>fsyacc로 Parser 작성</li>
<li>빌드 순서 설정 (핵심!)</li>
</ul>
<h2 id="프로젝트-생성"><a class="header" href="#프로젝트-생성">프로젝트 생성</a></h2>
<pre><code class="language-bash"># F# 콘솔 프로젝트 생성
dotnet new console -lang F# -n FunLang -f net10.0

# FsLexYacc 패키지 설치
cd FunLang
dotnet add package FsLexYacc --version 11.3.0
</code></pre>
<h2 id="ast-정의"><a class="header" href="#ast-정의">AST 정의</a></h2>
<p><code>Ast.fs</code> — 언어의 구문 트리를 F# Discriminated Union으로 정의한다.</p>
<pre><code class="language-fsharp">module Ast

/// Expression AST - minimal foundation for lexer/parser pipeline
/// Phase 1: Number only (proof of pipeline)
/// Phase 2 will add: Add, Subtract, Multiply, Divide
type Expr =
    | Number of int
</code></pre>
<p>Phase 1에서는 숫자만 지원한다. 사칙연산은 Chapter 2에서 추가한다.</p>
<h2 id="parser-작성"><a class="header" href="#parser-작성">Parser 작성</a></h2>
<p><code>Parser.fsy</code> — fsyacc 문법 명세 파일.</p>
<pre><code class="language-fsharp">%{
open Ast
%}

// Token declarations
%token &lt;int&gt; NUMBER
%token EOF

// Start symbol and its type
%start start
%type &lt;Ast.Expr&gt; start

%%

// Grammar rules
start:
  | NUMBER EOF { Number $1 }
</code></pre>
<p><strong>구성 요소:</strong></p>
<ul>
<li><code>%{ %}</code>: F# 코드 (open 문)</li>
<li><code>%token</code>: 토큰 선언 (<code>&lt;int&gt;</code>는 토큰이 가지는 값의 타입)</li>
<li><code>%start</code>, <code>%type</code>: 시작 심볼과 반환 타입</li>
<li><code>%%</code> 이후: 문법 규칙 (<code>$1</code>은 첫 번째 심볼의 값)</li>
</ul>
<h2 id="lexer-작성"><a class="header" href="#lexer-작성">Lexer 작성</a></h2>
<p><code>Lexer.fsl</code> — fslex 렉서 명세 파일.</p>
<pre><code class="language-fsharp">{
open System
open FSharp.Text.Lexing
open Parser  // Import token types from generated Parser module

// Helper to get lexeme as string
let lexeme (lexbuf: LexBuffer&lt;_&gt;) =
    LexBuffer&lt;_&gt;.LexemeString lexbuf
}

// Character class definitions
let digit = ['0'-'9']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')

// Lexer rules
rule tokenize = parse
  | whitespace+   { tokenize lexbuf }           // Skip whitespace
  | newline       { tokenize lexbuf }           // Skip newlines
  | digit+        { NUMBER (Int32.Parse(lexeme lexbuf)) }  // Integer literal
  | eof           { EOF }                       // End of input
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ul>
<li><code>open Parser</code>: Parser에서 생성된 토큰 타입(NUMBER, EOF) 사용</li>
<li><code>lexeme lexbuf</code>: 현재 매치된 문자열 추출</li>
<li><code>tokenize lexbuf</code>: 재귀 호출로 토큰 건너뛰기</li>
</ul>
<h2 id="빌드-순서-설정-핵심"><a class="header" href="#빌드-순서-설정-핵심">빌드 순서 설정 (핵심!)</a></h2>
<p><strong>런타임 순서 ≠ 빌드 순서</strong></p>
<ul>
<li>런타임: Lexer → Parser (문자열을 토큰으로, 토큰을 AST로)</li>
<li>빌드: Parser → Lexer (Lexer가 Parser의 토큰 타입을 참조하므로)</li>
</ul>
<p><code>FunLang.fsproj</code>:</p>
<pre><code class="language-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net10.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;!-- 1. AST definitions (manually written) --&gt;
    &lt;Compile Include="Ast.fs" /&gt;

    &lt;!-- 2. Parser generator - MUST come before Lexer --&gt;
    &lt;FsYacc Include="Parser.fsy"&gt;
      &lt;OtherFlags&gt;--module Parser&lt;/OtherFlags&gt;
    &lt;/FsYacc&gt;

    &lt;!-- 3. Lexer generator - depends on Parser tokens --&gt;
    &lt;FsLex Include="Lexer.fsl"&gt;
      &lt;OtherFlags&gt;--module Lexer --unicode&lt;/OtherFlags&gt;
    &lt;/FsLex&gt;

    &lt;!-- 4. Generated parser files --&gt;
    &lt;Compile Include="Parser.fsi" /&gt;
    &lt;Compile Include="Parser.fs" /&gt;

    &lt;!-- 5. Generated lexer file --&gt;
    &lt;Compile Include="Lexer.fs" /&gt;

    &lt;!-- 6. Main program --&gt;
    &lt;Compile Include="Program.fs" /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="FsLexYacc" Version="11.3.0" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p><strong>빌드 순서가 틀리면:</strong></p>
<pre><code>error FS0039: The namespace or module 'Parser' is not defined
</code></pre>
<h2 id="main-program"><a class="header" href="#main-program">Main Program</a></h2>
<p><code>Program.fs</code> — 파이프라인을 연결하고 테스트한다.</p>
<pre><code class="language-fsharp">open System
open FSharp.Text.Lexing
open Ast

/// Parse a string input and return the AST
let parse (input: string) : Expr =
    let lexbuf = LexBuffer&lt;char&gt;.FromString input
    Parser.start Lexer.tokenize lexbuf

[&lt;EntryPoint&gt;]
let main argv =
    let testInput = "42"

    printfn "FunLang Interpreter - Phase 1: Foundation"
    printfn "========================================="
    printfn ""
    printfn "Input: %s" testInput

    try
        let ast = parse testInput
        printfn "AST: %A" ast
        printfn ""
        printfn "Pipeline successful!"
        0
    with
    | ex -&gt;
        printfn "Error: %s" ex.Message
        1
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="빌드-및-실행"><a class="header" href="#빌드-및-실행">빌드 및 실행</a></h3>
<pre><code class="language-bash">$ dotnet build
Build succeeded.

$ dotnet run
FunLang Interpreter - Phase 1: Foundation
=========================================

Input: 42
AST: Number 42

Pipeline successful!
</code></pre>
<h3 id="다른-숫자-테스트"><a class="header" href="#다른-숫자-테스트">다른 숫자 테스트</a></h3>
<p><code>Program.fs</code>에서 <code>testInput</code>을 변경하여 테스트:</p>
<pre><code class="language-fsharp">let testInput = "123"
</code></pre>
<pre><code class="language-bash">$ dotnet run
Input: 123
AST: Number 123

Pipeline successful!
</code></pre>
<h3 id="빌드-오류-해결"><a class="header" href="#빌드-오류-해결">빌드 오류 해결</a></h3>
<p>빌드 순서가 잘못되면:</p>
<pre><code>error FS0039: The namespace or module 'Parser' is not defined
</code></pre>
<p><strong>해결</strong>: <code>.fsproj</code>에서 <code>&lt;FsYacc&gt;</code>가 <code>&lt;FsLex&gt;</code> 위에 있는지 확인.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>파일</th><th>역할</th></tr>
</thead>
<tbody>
<tr><td><code>Ast.fs</code></td><td>AST 타입 정의 (Discriminated Union)</td></tr>
<tr><td><code>Parser.fsy</code></td><td>fsyacc 문법 명세 → <code>Parser.fs</code>, <code>Parser.fsi</code> 생성</td></tr>
<tr><td><code>Lexer.fsl</code></td><td>fslex 렉서 명세 → <code>Lexer.fs</code> 생성</td></tr>
<tr><td><code>Program.fs</code></td><td>파이프라인 연결 및 실행</td></tr>
<tr><td><code>FunLang.fsproj</code></td><td>빌드 설정 (순서 중요!)</td></tr>
</tbody>
</table>
</div>
<h2 id="다음-chapter"><a class="header" href="#다음-chapter">다음 Chapter</a></h2>
<p>Chapter 2에서는 사칙연산(+, -, *, /)을 추가하고 Evaluator를 구현하여 실제로 계산하는 인터프리터를 만든다.</p>
<h2 id="관련-문서"><a class="header" href="#관련-문서">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/setup-fslexyacc-build-order.html">setup-fslexyacc-build-order</a> — FsLexYacc 빌드 순서 설정</li>
<li><a href="../docs/howto/write-fslex-lexer.html">write-fslex-lexer</a> — fslex 렉서 작성법</li>
<li><a href="../docs/howto/write-fsyacc-parser.html">write-fsyacc-parser</a> — fsyacc 파서 작성법</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-2-arithmetic-expressions"><a class="header" href="#chapter-2-arithmetic-expressions">Chapter 2: Arithmetic Expressions</a></h1>
<p>Chapter 1에서 구축한 파이프라인에 사칙연산을 추가하여 실제로 계산하는 인터프리터를 만든다.</p>
<h2 id="개요-1"><a class="header" href="#개요-1">개요</a></h2>
<p>이 chapter에서 추가하는 기능:</p>
<ul>
<li>사칙연산 (+, -, *, /)</li>
<li>연산자 우선순위 (*, /가 +, -보다 먼저)</li>
<li>괄호로 우선순위 변경</li>
<li>단항 마이너스 (-5, –5, -(1+2))</li>
<li>Evaluator 컴포넌트</li>
</ul>
<h2 id="ast-확장"><a class="header" href="#ast-확장">AST 확장</a></h2>
<p><code>Ast.fs</code>에 산술 연산 노드를 추가한다.</p>
<pre><code class="language-fsharp">module Ast

/// Expression AST for arithmetic operations
/// Phase 2: Arithmetic expressions with precedence
type Expr =
    | Number of int
    | Add of Expr * Expr
    | Subtract of Expr * Expr
    | Multiply of Expr * Expr
    | Divide of Expr * Expr
    | Negate of Expr  // Unary minus
</code></pre>
<p><strong>설계 포인트:</strong></p>
<ul>
<li>각 연산자마다 별도 케이스 (타입 안전성)</li>
<li><code>Negate</code>는 단항 연산자 (표현식 하나만 받음)</li>
<li>재귀 구조 (<code>Expr * Expr</code>)로 중첩 표현식 지원</li>
</ul>
<h2 id="parser-exprtermfactor-패턴"><a class="header" href="#parser-exprtermfactor-패턴">Parser: Expr/Term/Factor 패턴</a></h2>
<p>연산자 우선순위를 처리하는 핵심 패턴이다.</p>
<pre><code class="language-fsharp">// Parser.fsy

%{
open Ast
%}

%token &lt;int&gt; NUMBER
%token PLUS MINUS STAR SLASH
%token LPAREN RPAREN
%token EOF

%start start
%type &lt;Ast.Expr&gt; start

%%

// Expr/Term/Factor 패턴으로 우선순위 인코딩
// 낮은 우선순위 = 높은 문법 레벨

start:
    | Expr EOF           { $1 }

Expr:                              // + - (낮은 우선순위)
    | Expr PLUS Term     { Add($1, $3) }
    | Expr MINUS Term    { Subtract($1, $3) }
    | Term               { $1 }

Term:                              // * / (높은 우선순위)
    | Term STAR Factor   { Multiply($1, $3) }
    | Term SLASH Factor  { Divide($1, $3) }
    | Factor             { $1 }

Factor:                            // 숫자, 괄호, 단항 (가장 높은 우선순위)
    | NUMBER             { Number($1) }
    | LPAREN Expr RPAREN { $2 }
    | MINUS Factor       { Negate($2) }
</code></pre>
<p><strong>왜 이 패턴을 사용하나?</strong></p>
<p>FsYacc의 <code>%left</code>/<code>%right</code> 선언에는 알려진 버그가 있다. Expr/Term/Factor 패턴은 문법 구조 자체로 우선순위를 표현하므로 버그 영향이 없다.</p>
<p><strong>파싱 예시:</strong></p>
<p><code>2 + 3 * 4</code>:</p>
<pre><code>Expr
├── Expr → Term → Factor → 2
├── PLUS
└── Term
    ├── Term → Factor → 3
    ├── STAR
    └── Factor → 4

결과: Add(Number 2, Multiply(Number 3, Number 4))
</code></pre>
<h2 id="lexer-확장"><a class="header" href="#lexer-확장">Lexer 확장</a></h2>
<p><code>Lexer.fsl</code>에 연산자 토큰을 추가한다.</p>
<pre><code class="language-fsharp">{
open System
open FSharp.Text.Lexing
open Parser

let lexeme (lexbuf: LexBuffer&lt;_&gt;) =
    LexBuffer&lt;_&gt;.LexemeString lexbuf
}

let digit = ['0'-'9']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')

rule tokenize = parse
    | whitespace+   { tokenize lexbuf }
    | newline       { tokenize lexbuf }
    | digit+        { NUMBER (Int32.Parse(lexeme lexbuf)) }
    | '+'           { PLUS }
    | '-'           { MINUS }
    | '*'           { STAR }
    | '/'           { SLASH }
    | '('           { LPAREN }
    | ')'           { RPAREN }
    | eof           { EOF }
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ul>
<li><code>MINUS</code>는 단일 토큰 (단항/이항 구분은 파서가 함)</li>
<li>괄호 <code>(</code>, <code>)</code>도 토큰으로 정의</li>
</ul>
<h2 id="evaluator"><a class="header" href="#evaluator">Evaluator</a></h2>
<p>새로운 파일 <code>Eval.fs</code>를 추가한다. 패턴 매칭으로 AST를 평가한다.</p>
<pre><code class="language-fsharp">module Eval

open Ast

/// Evaluate an expression to an integer result
let rec eval (expr: Expr) : int =
    match expr with
    | Number n -&gt; n
    | Add (left, right) -&gt; eval left + eval right
    | Subtract (left, right) -&gt; eval left - eval right
    | Multiply (left, right) -&gt; eval left * eval right
    | Divide (left, right) -&gt; eval left / eval right
    | Negate e -&gt; -(eval e)
</code></pre>
<p><strong>빌드 순서 업데이트</strong> (<code>FunLang.fsproj</code>):</p>
<pre><code class="language-xml">&lt;Compile Include="Ast.fs" /&gt;
&lt;!-- Parser, Lexer 생성 --&gt;
&lt;Compile Include="Parser.fsi" /&gt;
&lt;Compile Include="Parser.fs" /&gt;
&lt;Compile Include="Lexer.fs" /&gt;
&lt;Compile Include="Eval.fs" /&gt;      &lt;!-- NEW --&gt;
&lt;Compile Include="Program.fs" /&gt;
</code></pre>
<h2 id="programfs"><a class="header" href="#programfs">Program.fs</a></h2>
<p>CLI 인터페이스를 추가한다.</p>
<pre><code class="language-fsharp">open System
open FSharp.Text.Lexing
open Ast
open Eval

let parse (input: string) : Expr =
    let lexbuf = LexBuffer&lt;char&gt;.FromString input
    Parser.start Lexer.tokenize lexbuf

[&lt;EntryPoint&gt;]
let main argv =
    match argv with
    | [| "--expr"; expr |] -&gt;
        try
            let result = expr |&gt; parse |&gt; eval
            printfn "%d" result
            0
        with ex -&gt;
            eprintfn "Error: %s" ex.Message
            1
    | _ -&gt;
        eprintfn "Usage: funlang --expr &lt;expression&gt;"
        1
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="기본-연산"><a class="header" href="#기본-연산">기본 연산</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "2 + 3"
5

$ dotnet run --project FunLang -- --expr "10 - 4"
6

$ dotnet run --project FunLang -- --expr "3 * 4"
12

$ dotnet run --project FunLang -- --expr "20 / 4"
5
</code></pre>
<h3 id="연산자-우선순위"><a class="header" href="#연산자-우선순위">연산자 우선순위</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "2 + 3 * 4"
14

$ dotnet run --project FunLang -- --expr "10 - 6 / 2"
7
</code></pre>
<h3 id="괄호"><a class="header" href="#괄호">괄호</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "(2 + 3) * 4"
20

$ dotnet run --project FunLang -- --expr "((2 + 3) * (4 - 1))"
15
</code></pre>
<h3 id="단항-마이너스"><a class="header" href="#단항-마이너스">단항 마이너스</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "-5"
-5

$ dotnet run --project FunLang -- --expr "-5 + 3"
-2

$ dotnet run --project FunLang -- --expr "--5"
5

$ dotnet run --project FunLang -- --expr "-(2 + 3)"
-5
</code></pre>
<h3 id="좌결합성"><a class="header" href="#좌결합성">좌결합성</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "2 - 3 - 4"
-5

$ dotnet run --project FunLang -- --expr "24 / 4 / 2"
3
</code></pre>
<h2 id="테스트"><a class="header" href="#테스트">테스트</a></h2>
<p>별도의 테스트 프로젝트 <code>FunLang.Tests</code>에서 Expecto로 테스트한다.</p>
<pre><code class="language-bash">$ dotnet run --project FunLang.Tests
[13:25:00 INF] EXPECTO? Running tests...
[13:25:01 INF] EXPECTO! 19 tests run – 19 passed, 0 failed. Success!
</code></pre>
<h2 id="요약-1"><a class="header" href="#요약-1">요약</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>파일</th><th>변경 사항</th></tr>
</thead>
<tbody>
<tr><td><code>Ast.fs</code></td><td>Add, Subtract, Multiply, Divide, Negate 추가</td></tr>
<tr><td><code>Parser.fsy</code></td><td>Expr/Term/Factor 문법 패턴</td></tr>
<tr><td><code>Lexer.fsl</code></td><td>+, -, *, /, (, ) 토큰</td></tr>
<tr><td><code>Eval.fs</code></td><td><strong>NEW</strong> - 재귀 평가 함수</td></tr>
<tr><td><code>Program.fs</code></td><td>–expr CLI 인터페이스</td></tr>
<tr><td><code>FunLang.fsproj</code></td><td>Eval.fs 빌드 순서 추가</td></tr>
</tbody>
</table>
</div>
<h2 id="다음-chapter-1"><a class="header" href="#다음-chapter-1">다음 Chapter</a></h2>
<p>Chapter 3에서는 변수 바인딩 (<code>let x = 5</code>)과 스코프 (<code>let x = 1 in x + 1</code>)를 추가한다.</p>
<h2 id="관련-문서-1"><a class="header" href="#관련-문서-1">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/fsyacc-precedence-without-declarations.html">fsyacc-precedence-without-declarations</a> — Expr/Term/Factor 패턴 상세</li>
<li><a href="../docs/howto/fsyacc-operator-precedence-methods.html">fsyacc-operator-precedence-methods</a> — 우선순위 처리 방법 비교</li>
<li><a href="../docs/howto/implement-unary-minus.html">implement-unary-minus</a> — 단항 마이너스 구현</li>
<li><a href="../docs/howto/write-fsyacc-parser.html">write-fsyacc-parser</a> — fsyacc 파서 작성</li>
<li><a href="../docs/howto/setup-expecto-test-project.html">setup-expecto-test-project</a> — Expecto 테스트 설정</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-3-variables-and-binding"><a class="header" href="#chapter-3-variables-and-binding">Chapter 3: Variables and Binding</a></h1>
<p>Chapter 2의 계산기에 변수 바인딩을 추가하여 표현식 내에서 값을 재사용할 수 있게 한다.</p>
<h2 id="개요-2"><a class="header" href="#개요-2">개요</a></h2>
<p>이 chapter에서 추가하는 기능:</p>
<ul>
<li>변수 참조 (<code>x</code>, <code>foo</code>, <code>_bar</code>)</li>
<li>Let 바인딩 (<code>let x = 5 in x + 1</code>)</li>
<li>중첩 스코프 (<code>let x = 1 in let y = 2 in x + y</code>)</li>
<li>섀도잉 (<code>let x = 1 in let x = 2 in x</code>)</li>
<li>환경 기반 평가 (Environment-passing evaluation)</li>
</ul>
<h2 id="ast-확장-1"><a class="header" href="#ast-확장-1">AST 확장</a></h2>
<p><code>Ast.fs</code>에 변수 관련 노드를 추가한다.</p>
<pre><code class="language-fsharp">module Ast

type Expr =
    | Number of int
    | Add of Expr * Expr
    | Subtract of Expr * Expr
    | Multiply of Expr * Expr
    | Divide of Expr * Expr
    | Negate of Expr
    // Phase 3: Variables
    | Var of string           // 변수 참조
    | Let of string * Expr * Expr  // let name = expr1 in expr2
</code></pre>
<p><strong>설계 포인트:</strong></p>
<ul>
<li><code>Var</code>: 변수 이름만 저장 (값은 평가 시 환경에서 조회)</li>
<li><code>Let</code>: 이름, 바인딩 표현식, 본문 표현식 세 부분</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code>let x = 5 in x + 1

Let("x", Number 5, Add(Var "x", Number 1))
</code></pre>
<h2 id="lexer-확장-1"><a class="header" href="#lexer-확장-1">Lexer 확장</a></h2>
<p><code>Lexer.fsl</code>에 키워드와 식별자 규칙을 추가한다.</p>
<pre><code class="language-fsharp">{
open System
open FSharp.Text.Lexing
open Parser

let lexeme (lexbuf: LexBuffer&lt;_&gt;) =
    LexBuffer&lt;_&gt;.LexemeString lexbuf
}

let digit = ['0'-'9']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')
let letter = ['a'-'z' 'A'-'Z']
let ident_start = letter | '_'
let ident_char = letter | digit | '_'

rule tokenize = parse
    | whitespace+   { tokenize lexbuf }
    | newline       { tokenize lexbuf }
    | digit+        { NUMBER (Int32.Parse(lexeme lexbuf)) }
    // 키워드는 반드시 식별자보다 먼저!
    | "let"         { LET }
    | "in"          { IN }
    // 식별자: 문자 또는 _로 시작
    | ident_start ident_char* { IDENT (lexeme lexbuf) }
    | '+'           { PLUS }
    | '-'           { MINUS }
    | '*'           { STAR }
    | '/'           { SLASH }
    | '('           { LPAREN }
    | ')'           { RPAREN }
    | '='           { EQUALS }
    | eof           { EOF }
</code></pre>
<p><strong>핵심 포인트: 키워드 우선순위</strong></p>
<pre><code class="language-fsharp">// 올바른 순서
| "let"         { LET }
| "in"          { IN }
| ident_start ident_char* { IDENT (lexeme lexbuf) }

// 잘못된 순서 (let이 IDENT로 인식됨)
| ident_start ident_char* { IDENT (lexeme lexbuf) }
| "let"         { LET }  // 절대 매칭되지 않음!
</code></pre>
<p>fslex는 규칙 순서대로 매칭을 시도한다. <code>"let"</code>과 <code>ident_start ident_char*</code> 둘 다 “let” 문자열에 매칭되므로, 키워드 규칙이 먼저 와야 한다.</p>
<h2 id="parser-확장"><a class="header" href="#parser-확장">Parser 확장</a></h2>
<p><code>Parser.fsy</code>에 새 토큰과 문법 규칙을 추가한다.</p>
<pre><code class="language-fsharp">%{
open Ast
%}

%token &lt;int&gt; NUMBER
%token &lt;string&gt; IDENT
%token PLUS MINUS STAR SLASH
%token LPAREN RPAREN
%token LET IN EQUALS
%token EOF

%start start
%type &lt;Ast.Expr&gt; start

%%

start:
    | Expr EOF           { $1 }

Expr:
    // Let 표현식 - 가장 낮은 우선순위
    | LET IDENT EQUALS Expr IN Expr  { Let($2, $4, $6) }
    | Expr PLUS Term     { Add($1, $3) }
    | Expr MINUS Term    { Subtract($1, $3) }
    | Term               { $1 }

Term:
    | Term STAR Factor   { Multiply($1, $3) }
    | Term SLASH Factor  { Divide($1, $3) }
    | Factor             { $1 }

Factor:
    | NUMBER             { Number($1) }
    | IDENT              { Var($1) }
    | LPAREN Expr RPAREN { $2 }
    | MINUS Factor       { Negate($2) }
</code></pre>
<p><strong>Let의 우선순위:</strong></p>
<p>Let이 <code>Expr</code> 레벨에 있으므로 가장 낮은 우선순위를 갖는다:</p>
<pre><code>let x = 2 + 3 in x * 4
→ Let("x", Add(2, 3), Multiply(Var "x", 4))
</code></pre>
<p><strong>IDENT의 위치:</strong></p>
<p><code>Factor</code>에서 <code>IDENT</code>를 처리하므로 변수는 괄호 없이 직접 사용 가능:</p>
<pre><code>x + 1      → Add(Var "x", Number 1)
x * y      → Multiply(Var "x", Var "y")
</code></pre>
<h2 id="evaluator-환경-기반-평가"><a class="header" href="#evaluator-환경-기반-평가">Evaluator: 환경 기반 평가</a></h2>
<p>변수를 지원하려면 “환경(Environment)“이 필요하다. 환경은 변수 이름에서 값으로의 매핑이다.</p>
<p><code>Eval.fs</code>를 수정한다.</p>
<pre><code class="language-fsharp">module Eval

open Ast

/// 환경: 변수 이름 → 값 매핑
type Env = Map&lt;string, int&gt;

/// 빈 환경 (최상위 평가용)
let emptyEnv : Env = Map.empty

/// 환경 내에서 표현식 평가
/// 정의되지 않은 변수는 예외 발생
let rec eval (env: Env) (expr: Expr) : int =
    match expr with
    | Number n -&gt; n

    | Var name -&gt;
        match Map.tryFind name env with
        | Some value -&gt; value
        | None -&gt; failwithf "Undefined variable: %s" name

    | Let (name, binding, body) -&gt;
        // 1. 현재 환경에서 바인딩 평가
        let value = eval env binding
        // 2. 환경 확장 (새 바인딩 추가)
        let extendedEnv = Map.add name value env
        // 3. 확장된 환경에서 본문 평가
        eval extendedEnv body

    | Add (left, right) -&gt;
        eval env left + eval env right

    | Subtract (left, right) -&gt;
        eval env left - eval env right

    | Multiply (left, right) -&gt;
        eval env left * eval env right

    | Divide (left, right) -&gt;
        eval env left / eval env right

    | Negate e -&gt;
        -(eval env e)

/// 편의 함수: 빈 환경에서 평가
let evalExpr (expr: Expr) : int =
    eval emptyEnv expr
</code></pre>
<p><strong>핵심 개념:</strong></p>
<ol>
<li><strong>환경 전파</strong>: 모든 재귀 호출에 <code>env</code>를 전달</li>
<li><strong>환경 확장</strong>: <code>Map.add</code>로 새 바인딩 추가 (불변 맵이므로 원본 유지)</li>
<li><strong>스코프</strong>: Let 본문에서만 확장된 환경 사용</li>
</ol>
<p><strong>Let 평가 흐름:</strong></p>
<pre><code>let x = 2 + 3 in x * 4
1. env = {}
2. eval {} (2 + 3) = 5
3. extendedEnv = {x: 5}
4. eval {x: 5} (x * 4)
   - eval {x: 5} x = 5
   - eval {x: 5} 4 = 4
   - 5 * 4 = 20
결과: 20
</code></pre>
<h2 id="스코프-규칙"><a class="header" href="#스코프-규칙">스코프 규칙</a></h2>
<h3 id="중첩-스코프"><a class="header" href="#중첩-스코프">중첩 스코프</a></h3>
<p>내부 Let은 외부 변수에 접근 가능:</p>
<pre><code>let x = 5 in let y = x + 1 in y
</code></pre>
<p>평가:</p>
<pre><code>1. env = {}
2. {x: 5}에서 x + 1 = 6
3. {x: 5, y: 6}에서 y = 6
결과: 6
</code></pre>
<h3 id="섀도잉-shadowing"><a class="header" href="#섀도잉-shadowing">섀도잉 (Shadowing)</a></h3>
<p>같은 이름으로 재바인딩하면 내부에서 새 값 사용:</p>
<pre><code>let x = 1 in let x = 2 in x
</code></pre>
<p>평가:</p>
<pre><code>1. env = {}
2. {x: 1}
3. {x: 2}  (Map.add로 덮어씀)
4. x = 2
결과: 2
</code></pre>
<p><strong>섀도잉 후 외부 스코프:</strong></p>
<pre><code>let x = 1 in (let x = 2 in x) + x
</code></pre>
<p>평가:</p>
<pre><code>1. env = {}
2. env1 = {x: 1}
3. (let x = 2 in x) 평가:
   - env2 = {x: 2}
   - 결과: 2
4. x (env1에서) = 1
5. 2 + 1 = 3
결과: 3
</code></pre>
<p>불변 맵 덕분에 내부 스코프가 외부에 영향을 주지 않는다.</p>
<h2 id="programfs-1"><a class="header" href="#programfs-1">Program.fs</a></h2>
<p><code>evalExpr</code>로 호출을 변경한다.</p>
<pre><code class="language-fsharp">[&lt;EntryPoint&gt;]
let main argv =
    match argv with
    | [| "--expr"; expr |] -&gt;
        try
            let result = expr |&gt; parse |&gt; evalExpr  // eval → evalExpr
            printfn "%d" result
            0
        with ex -&gt;
            eprintfn "Error: %s" ex.Message
            1
    // ... 나머지 옵션
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="기본-let-바인딩"><a class="header" href="#기본-let-바인딩">기본 Let 바인딩</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let x = 5 in x"
5

$ dotnet run --project FunLang -- --expr "let x = 2 + 3 in x"
5

$ dotnet run --project FunLang -- --expr "let x = 5 in x + 1"
6

$ dotnet run --project FunLang -- --expr "let x = 10 in x * 2 + 5"
25
</code></pre>
<h3 id="변수-참조"><a class="header" href="#변수-참조">변수 참조</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let x = 3 in x * 4"
12

$ dotnet run --project FunLang -- --expr "let x = 2 in x + x"
4

$ dotnet run --project FunLang -- --expr "let x = 5 in x * x"
25
</code></pre>
<h3 id="중첩-let"><a class="header" href="#중첩-let">중첩 Let</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let x = 1 in let y = 2 in x + y"
3

$ dotnet run --project FunLang -- --expr "let x = 5 in let y = x + 1 in y"
6

$ dotnet run --project FunLang -- --expr "let a = 1 in let b = 2 in let c = 3 in a + b + c"
6
</code></pre>
<h3 id="섀도잉"><a class="header" href="#섀도잉">섀도잉</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let x = 1 in let x = 2 in x"
2

$ dotnet run --project FunLang -- --expr "let x = 1 in (let x = 2 in x) + x"
3

$ dotnet run --project FunLang -- --expr "let x = 1 in (let y = x + 1 in y) + x"
3
</code></pre>
<h3 id="정의되지-않은-변수"><a class="header" href="#정의되지-않은-변수">정의되지 않은 변수</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "x"
Error: Undefined variable: x

$ dotnet run --project FunLang -- --expr "y + 1"
Error: Undefined variable: y
</code></pre>
<h3 id="디버깅-토큰-및-ast-출력"><a class="header" href="#디버깅-토큰-및-ast-출력">디버깅: 토큰 및 AST 출력</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-tokens --expr "let x = 5 in x"
LET
IDENT(x)
EQUALS
NUMBER(5)
IN
IDENT(x)
EOF

$ dotnet run --project FunLang -- --emit-ast --expr "let x = 5 in x"
Let(x, Number(5), Var(x))

$ dotnet run --project FunLang -- --emit-ast --expr "let x = 1 in let y = 2 in x + y"
Let(x, Number(1), Let(y, Number(2), Add(Var(x), Var(y))))
</code></pre>
<h2 id="테스트-1"><a class="header" href="#테스트-1">테스트</a></h2>
<h3 id="fslit-cli-테스트"><a class="header" href="#fslit-cli-테스트">fslit (CLI 테스트)</a></h3>
<p><code>tests/variables/</code> 디렉토리에 12개 테스트:</p>
<pre><code class="language-bash">$ make -C tests variables
...
PASS: all 12 tests passed
</code></pre>
<h3 id="expecto-단위-테스트"><a class="header" href="#expecto-단위-테스트">Expecto (단위 테스트)</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang.Tests
[13:25:00 INF] EXPECTO? Running tests...
[13:25:01 INF] EXPECTO! 58 tests run – 58 passed, 0 failed. Success!
</code></pre>
<h2 id="요약-2"><a class="header" href="#요약-2">요약</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>파일</th><th>변경 사항</th></tr>
</thead>
<tbody>
<tr><td><code>Ast.fs</code></td><td><code>Var</code>, <code>Let</code> 노드 추가</td></tr>
<tr><td><code>Lexer.fsl</code></td><td><code>LET</code>, <code>IN</code>, <code>EQUALS</code>, <code>IDENT</code> 토큰, 키워드 우선 규칙</td></tr>
<tr><td><code>Parser.fsy</code></td><td>Let 문법, IDENT → Var 변환</td></tr>
<tr><td><code>Eval.fs</code></td><td><code>Env</code> 타입, 환경 기반 <code>eval</code>, <code>evalExpr</code> 래퍼</td></tr>
<tr><td><code>Program.fs</code></td><td><code>evalExpr</code> 사용</td></tr>
</tbody>
</table>
</div>
<h2 id="핵심-개념"><a class="header" href="#핵심-개념">핵심 개념</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>개념</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>Environment</td><td>변수 이름 → 값 매핑 (<code>Map&lt;string, int&gt;</code>)</td></tr>
<tr><td>Lexical Scope</td><td>코드 구조가 변수 가시성 결정</td></tr>
<tr><td>Shadowing</td><td>같은 이름 재바인딩 시 내부 값 우선</td></tr>
<tr><td>Immutable Map</td><td>스코프 간 격리 보장</td></tr>
</tbody>
</table>
</div>
<h2 id="다음-chapter-2"><a class="header" href="#다음-chapter-2">다음 Chapter</a></h2>
<p>Chapter 4에서는 조건문 (<code>if-then-else</code>)과 Boolean 타입을 추가한다.</p>
<h2 id="관련-문서-2"><a class="header" href="#관련-문서-2">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/write-fslex-lexer.html">write-fslex-lexer</a> — fslex 렉서 작성, 키워드 우선 규칙</li>
<li><a href="../docs/howto/write-fsyacc-parser.html">write-fsyacc-parser</a> — fsyacc 파서 작성</li>
<li><a href="../docs/howto/write-fscheck-property-tests.html">write-fscheck-property-tests</a> — FsCheck로 변수 속성 검증</li>
<li><a href="../docs/howto/testing-strategies.html">testing-strategies</a> — 테스트 전략 가이드</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-4-conditionals-and-boolean"><a class="header" href="#chapter-4-conditionals-and-boolean">Chapter 4: Conditionals and Boolean</a></h1>
<p>Chapter 3의 변수 바인딩에 조건문과 Boolean 타입을 추가한다. 이제 FunLang은 여러 타입을 다루는 언어가 된다.</p>
<h2 id="개요-3"><a class="header" href="#개요-3">개요</a></h2>
<p>이 chapter에서 추가하는 기능:</p>
<ul>
<li>Boolean 리터럴 (<code>true</code>, <code>false</code>)</li>
<li>If-then-else 표현식 (<code>if condition then expr1 else expr2</code>)</li>
<li>비교 연산자 (<code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>)</li>
<li>논리 연산자 (<code>&amp;&amp;</code>, <code>||</code>)</li>
<li>타입 검사 (런타임)</li>
<li>단락 평가 (Short-circuit evaluation)</li>
</ul>
<h2 id="value-타입-도입"><a class="header" href="#value-타입-도입">Value 타입 도입</a></h2>
<p>이전까지 <code>evalExpr</code>는 <code>int</code>를 반환했다. Boolean을 추가하면 결과가 정수일 수도, 불린일 수도 있다. 이를 위해 Discriminated Union을 사용한다.</p>
<p><code>Ast.fs</code>에 <code>Value</code> 타입을 추가한다.</p>
<pre><code class="language-fsharp">module Ast

/// 평가 결과 타입
/// Phase 4: 이종 타입 (int와 bool)
type Value =
    | IntValue of int
    | BoolValue of bool
</code></pre>
<p><strong>왜 Discriminated Union인가?</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>방식</th><th>문제점</th></tr>
</thead>
<tbody>
<tr><td><code>obj</code></td><td>타입 안정성 없음, 캐스팅 필요</td></tr>
<tr><td>제네릭</td><td>표현식마다 타입이 다름</td></tr>
<tr><td>DU</td><td>가능한 타입을 명시적으로 열거, 패턴 매칭으로 안전하게 처리</td></tr>
</tbody>
</table>
</div>
<h2 id="ast-확장-2"><a class="header" href="#ast-확장-2">AST 확장</a></h2>
<p><code>Ast.fs</code>에 제어 흐름 노드를 추가한다.</p>
<pre><code class="language-fsharp">type Expr =
    | Number of int
    | Add of Expr * Expr
    | Subtract of Expr * Expr
    | Multiply of Expr * Expr
    | Divide of Expr * Expr
    | Negate of Expr
    // Phase 3: Variables
    | Var of string
    | Let of string * Expr * Expr
    // Phase 4: Control flow
    | Bool of bool            // Boolean 리터럴
    | If of Expr * Expr * Expr  // if condition then expr1 else expr2
    // Phase 4: 비교 연산자 (BoolValue 반환)
    | Equal of Expr * Expr       // =
    | NotEqual of Expr * Expr    // &lt;&gt;
    | LessThan of Expr * Expr    // &lt;
    | GreaterThan of Expr * Expr // &gt;
    | LessEqual of Expr * Expr   // &lt;=
    | GreaterEqual of Expr * Expr // &gt;=
    // Phase 4: 논리 연산자 (단락 평가)
    | And of Expr * Expr  // &amp;&amp;
    | Or of Expr * Expr   // ||
</code></pre>
<p><strong>AST 예시:</strong></p>
<pre><code>if 5 &gt; 3 then 1 else 2

If(GreaterThan(Number 5, Number 3), Number 1, Number 2)
</code></pre>
<h2 id="lexer-확장-2"><a class="header" href="#lexer-확장-2">Lexer 확장</a></h2>
<p><code>Lexer.fsl</code>에 새 키워드와 연산자를 추가한다.</p>
<pre><code class="language-fsharp">{
open System
open FSharp.Text.Lexing
open Parser

let lexeme (lexbuf: LexBuffer&lt;_&gt;) =
    LexBuffer&lt;_&gt;.LexemeString lexbuf
}

let digit = ['0'-'9']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')
let letter = ['a'-'z' 'A'-'Z']
let ident_start = letter | '_'
let ident_char = letter | digit | '_'

rule tokenize = parse
    | whitespace+   { tokenize lexbuf }
    | newline       { tokenize lexbuf }
    | digit+        { NUMBER (Int32.Parse(lexeme lexbuf)) }
    // 키워드는 반드시 식별자보다 먼저!
    | "true"        { TRUE }
    | "false"       { FALSE }
    | "if"          { IF }
    | "then"        { THEN }
    | "else"        { ELSE }
    | "let"         { LET }
    | "in"          { IN }
    // 식별자
    | ident_start ident_char* { IDENT (lexeme lexbuf) }
    // 다중 문자 연산자는 단일 문자보다 먼저!
    | "&lt;="          { LE }
    | "&gt;="          { GE }
    | "&lt;&gt;"          { NE }
    | "&amp;&amp;"          { AND }
    | "||"          { OR }
    // 단일 문자 연산자
    | '+'           { PLUS }
    | '-'           { MINUS }
    | '*'           { STAR }
    | '/'           { SLASH }
    | '&lt;'           { LT }
    | '&gt;'           { GT }
    | '('           { LPAREN }
    | ')'           { RPAREN }
    | '='           { EQUALS }
    | eof           { EOF }
</code></pre>
<p><strong>핵심 포인트: 연산자 매칭 순서</strong></p>
<pre><code class="language-fsharp">// 올바른 순서
| "&lt;="          { LE }
| "&lt;"           { LT }

// 잘못된 순서
| "&lt;"           { LT }   // "&lt;=" 입력 시 "&lt;"만 매칭됨
| "&lt;="          { LE }   // 도달 불가
</code></pre>
<p>fslex는 가장 긴 매칭(longest match)을 선호하지만, 같은 길이면 먼저 나온 규칙이 우선이다. 안전을 위해 다중 문자 연산자를 먼저 배치한다.</p>
<h2 id="parser-확장-1"><a class="header" href="#parser-확장-1">Parser 확장</a></h2>
<p><code>Parser.fsy</code>에 새 토큰과 문법을 추가한다.</p>
<pre><code class="language-fsharp">%{
open Ast
%}

%token &lt;int&gt; NUMBER
%token &lt;string&gt; IDENT
%token PLUS MINUS STAR SLASH
%token LPAREN RPAREN
%token LET IN EQUALS
%token TRUE FALSE IF THEN ELSE
%token LT GT LE GE NE
%token AND OR
%token EOF

// 우선순위 선언 (낮은 것부터 높은 것 순)
%left OR
%left AND
%nonassoc EQUALS LT GT LE GE NE

%start start
%type &lt;Ast.Expr&gt; start

%%

start:
    | Expr EOF           { $1 }

Expr:
    // Let - 가장 낮은 우선순위
    | LET IDENT EQUALS Expr IN Expr  { Let($2, $4, $6) }
    // If-then-else - 낮은 우선순위
    | IF Expr THEN Expr ELSE Expr    { If($2, $4, $6) }
    // 논리 연산자 (%left 선언으로 우선순위 적용)
    | Expr OR Expr                   { Or($1, $3) }
    | Expr AND Expr                  { And($1, $3) }
    // 비교 연산자 (%nonassoc로 비연관성)
    | Expr EQUALS Expr               { Equal($1, $3) }
    | Expr LT Expr                   { LessThan($1, $3) }
    | Expr GT Expr                   { GreaterThan($1, $3) }
    | Expr LE Expr                   { LessEqual($1, $3) }
    | Expr GE Expr                   { GreaterEqual($1, $3) }
    | Expr NE Expr                   { NotEqual($1, $3) }
    // 산술 연산 (Term/Factor 패턴 유지)
    | Expr PLUS Term                 { Add($1, $3) }
    | Expr MINUS Term                { Subtract($1, $3) }
    | Term                           { $1 }

Term:
    | Term STAR Factor   { Multiply($1, $3) }
    | Term SLASH Factor  { Divide($1, $3) }
    | Factor             { $1 }

Factor:
    | NUMBER             { Number($1) }
    | IDENT              { Var($1) }
    | TRUE               { Bool(true) }
    | FALSE              { Bool(false) }
    | LPAREN Expr RPAREN { $2 }
    | MINUS Factor       { Negate($2) }
</code></pre>
<p><strong>연산자 우선순위:</strong></p>
<pre><code>낮음 → 높음:
  OR &lt; AND &lt; 비교 &lt; +,- &lt; *,/ &lt; 단항- &lt; 괄호/리터럴

예: a || b &amp;&amp; c &lt; 5 + 1
→  a || (b &amp;&amp; ((c &lt; 5) + 1))  -- 잘못!
→  a || (b &amp;&amp; (c &lt; (5 + 1)))  -- 올바름
</code></pre>
<p><strong><code>%nonassoc</code> 비교 연산자:</strong></p>
<p><code>1 &lt; 2 &lt; 3</code> 같은 표현을 파싱 에러로 만든다. 왜?</p>
<ul>
<li>수학적으로 <code>1 &lt; 2 &lt; 3</code>은 “1 &lt; 2이고 2 &lt; 3“을 의미</li>
<li>그러나 대부분 언어에서 <code>(1 &lt; 2) &lt; 3</code>으로 파싱됨 → <code>true &lt; 3</code> → 타입 에러</li>
<li>혼란 방지를 위해 비연관성으로 선언</li>
</ul>
<h2 id="evaluator-타입-검사"><a class="header" href="#evaluator-타입-검사">Evaluator: 타입 검사</a></h2>
<p><code>Eval.fs</code>를 <code>Value</code> 반환으로 수정한다.</p>
<pre><code class="language-fsharp">module Eval

open Ast

/// 환경: 변수 이름 → Value 매핑
type Env = Map&lt;string, Value&gt;

let emptyEnv : Env = Map.empty

/// 출력용 포맷팅
let formatValue (v: Value) : string =
    match v with
    | IntValue n -&gt; string n
    | BoolValue b -&gt; if b then "true" else "false"

/// 환경 내에서 표현식 평가
/// 타입 에러 시 예외 발생
let rec eval (env: Env) (expr: Expr) : Value =
    match expr with
    | Number n -&gt; IntValue n
    | Bool b -&gt; BoolValue b

    | Var name -&gt;
        match Map.tryFind name env with
        | Some value -&gt; value
        | None -&gt; failwithf "Undefined variable: %s" name

    | Let (name, binding, body) -&gt;
        let value = eval env binding
        let extendedEnv = Map.add name value env
        eval extendedEnv body

    // 산술 연산 - 정수 타입 검사
    | Add (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; IntValue (l + r)
        | _ -&gt; failwith "Type error: + requires integer operands"

    | Subtract (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; IntValue (l - r)
        | _ -&gt; failwith "Type error: - requires integer operands"

    | Multiply (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; IntValue (l * r)
        | _ -&gt; failwith "Type error: * requires integer operands"

    | Divide (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; IntValue (l / r)
        | _ -&gt; failwith "Type error: / requires integer operands"

    | Negate e -&gt;
        match eval env e with
        | IntValue n -&gt; IntValue (-n)
        | _ -&gt; failwith "Type error: unary - requires integer operand"

    // 비교 연산 - 정수 입력, 불린 출력
    | LessThan (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; BoolValue (l &lt; r)
        | _ -&gt; failwith "Type error: &lt; requires integer operands"

    | GreaterThan (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; BoolValue (l &gt; r)
        | _ -&gt; failwith "Type error: &gt; requires integer operands"

    | LessEqual (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; BoolValue (l &lt;= r)
        | _ -&gt; failwith "Type error: &lt;= requires integer operands"

    | GreaterEqual (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; BoolValue (l &gt;= r)
        | _ -&gt; failwith "Type error: &gt;= requires integer operands"

    // 동등 비교 - 같은 타입 요구
    | Equal (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; BoolValue (l = r)
        | BoolValue l, BoolValue r -&gt; BoolValue (l = r)
        | _ -&gt; failwith "Type error: = requires operands of same type"

    | NotEqual (left, right) -&gt;
        match eval env left, eval env right with
        | IntValue l, IntValue r -&gt; BoolValue (l &lt;&gt; r)
        | BoolValue l, BoolValue r -&gt; BoolValue (l &lt;&gt; r)
        | _ -&gt; failwith "Type error: &lt;&gt; requires operands of same type"

    // 논리 연산 - 단락 평가
    | And (left, right) -&gt;
        match eval env left with
        | BoolValue false -&gt; BoolValue false  // 단락: 오른쪽 평가 안 함
        | BoolValue true -&gt;
            match eval env right with
            | BoolValue b -&gt; BoolValue b
            | _ -&gt; failwith "Type error: &amp;&amp; requires boolean operands"
        | _ -&gt; failwith "Type error: &amp;&amp; requires boolean operands"

    | Or (left, right) -&gt;
        match eval env left with
        | BoolValue true -&gt; BoolValue true  // 단락: 오른쪽 평가 안 함
        | BoolValue false -&gt;
            match eval env right with
            | BoolValue b -&gt; BoolValue b
            | _ -&gt; failwith "Type error: || requires boolean operands"
        | _ -&gt; failwith "Type error: || requires boolean operands"

    // If-then-else
    | If (condition, thenBranch, elseBranch) -&gt;
        match eval env condition with
        | BoolValue true -&gt; eval env thenBranch
        | BoolValue false -&gt; eval env elseBranch
        | _ -&gt; failwith "Type error: if condition must be boolean"

let evalExpr (expr: Expr) : Value =
    eval emptyEnv expr
</code></pre>
<p><strong>단락 평가 (Short-circuit Evaluation):</strong></p>
<pre><code>false &amp;&amp; (실행 안 됨)  → false
true || (실행 안 됨)   → true
</code></pre>
<p>단락 평가는 부작용(side effect)이 있을 때 중요하다. 예: <code>x &lt;&gt; 0 &amp;&amp; 10 / x &gt; 1</code></p>
<p><strong>타입 검사:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>연산자</th><th>입력 타입</th><th>출력 타입</th></tr>
</thead>
<tbody>
<tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></td><td>int, int</td><td>int</td></tr>
<tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>int, int</td><td>bool</td></tr>
<tr><td><code>=</code>, <code>&lt;&gt;</code></td><td>같은 타입</td><td>bool</td></tr>
<tr><td><code>&amp;&amp;</code>, <code>||</code></td><td>bool, bool</td><td>bool</td></tr>
<tr><td><code>if</code></td><td>bool, any, any</td><td>any</td></tr>
</tbody>
</table>
</div>
<h2 id="programfs-수정"><a class="header" href="#programfs-수정">Program.fs 수정</a></h2>
<p><code>Value</code>를 문자열로 출력하도록 변경한다.</p>
<pre><code class="language-fsharp">[&lt;EntryPoint&gt;]
let main argv =
    match argv with
    | [| "--expr"; expr |] -&gt;
        try
            let result = expr |&gt; parse |&gt; evalExpr
            printfn "%s" (formatValue result)  // int → Value 포맷팅
            0
        with ex -&gt;
            eprintfn "Error: %s" ex.Message
            1
    // ... 나머지 옵션
</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="boolean-리터럴"><a class="header" href="#boolean-리터럴">Boolean 리터럴</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "true"
true

$ dotnet run --project FunLang -- --expr "false"
false

$ dotnet run --project FunLang -- --expr "let b = true in b"
true
</code></pre>
<h3 id="if-then-else"><a class="header" href="#if-then-else">If-Then-Else</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "if true then 1 else 2"
1

$ dotnet run --project FunLang -- --expr "if false then 1 else 2"
2

$ dotnet run --project FunLang -- --expr "if 5 &gt; 3 then 10 else 20"
10

$ dotnet run --project FunLang -- --expr "if 2 + 3 &gt; 4 then 10 else 20"
10
</code></pre>
<h3 id="중첩-if"><a class="header" href="#중첩-if">중첩 If</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "if 5 &gt; 3 then if 2 &lt; 4 then 100 else 50 else 0"
100
</code></pre>
<h3 id="비교-연산자"><a class="header" href="#비교-연산자">비교 연산자</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "if 3 &lt; 5 then 1 else 0"
1

$ dotnet run --project FunLang -- --expr "if 5 &gt; 3 then 1 else 0"
1

$ dotnet run --project FunLang -- --expr "if 3 &lt;= 3 then 1 else 0"
1

$ dotnet run --project FunLang -- --expr "if 5 &gt;= 5 then 1 else 0"
1

$ dotnet run --project FunLang -- --expr "if 5 = 5 then 1 else 0"
1

$ dotnet run --project FunLang -- --expr "if 5 &lt;&gt; 3 then 1 else 0"
1
</code></pre>
<h3 id="논리-연산자"><a class="header" href="#논리-연산자">논리 연산자</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "if true &amp;&amp; true then 1 else 0"
1

$ dotnet run --project FunLang -- --expr "if true &amp;&amp; false then 1 else 0"
0

$ dotnet run --project FunLang -- --expr "if false || true then 1 else 0"
1

$ dotnet run --project FunLang -- --expr "if false || false then 1 else 0"
0
</code></pre>
<h3 id="let과-조합"><a class="header" href="#let과-조합">Let과 조합</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let x = 10 in if x &gt; 5 then x else 0"
10

$ dotnet run --project FunLang -- --expr "let x = 10 in let y = 20 in if x = 10 &amp;&amp; y = 20 then 1 else 0"
1
</code></pre>
<h3 id="타입-에러"><a class="header" href="#타입-에러">타입 에러</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "if 1 then 2 else 3"
Error: Type error: if condition must be boolean

$ dotnet run --project FunLang -- --expr "true + 1"
Error: Type error: + requires integer operands

$ dotnet run --project FunLang -- --expr "1 &amp;&amp; 2"
Error: Type error: &amp;&amp; requires boolean operands

$ dotnet run --project FunLang -- --expr "true &lt; false"
Error: Type error: &lt; requires integer operands
</code></pre>
<h3 id="디버깅-토큰-및-ast"><a class="header" href="#디버깅-토큰-및-ast">디버깅: 토큰 및 AST</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-tokens --expr "if true then 1 else 2"
IF TRUE THEN NUMBER(1) ELSE NUMBER(2) EOF

$ dotnet run --project FunLang -- --emit-ast --expr "if true then 1 else 2"
If (Bool true, Number 1, Number 2)

$ dotnet run --project FunLang -- --emit-tokens --expr "5 &gt; 3 &amp;&amp; 2 &lt; 4"
NUMBER(5) GT NUMBER(3) AND NUMBER(2) LT NUMBER(4) EOF
</code></pre>
<h2 id="테스트-2"><a class="header" href="#테스트-2">테스트</a></h2>
<h3 id="fslit-cli-테스트-1"><a class="header" href="#fslit-cli-테스트-1">fslit (CLI 테스트)</a></h3>
<p><code>tests/control/</code> 디렉토리에 20개 테스트:</p>
<pre><code class="language-bash">$ make -C tests control
...
PASS: all 20 tests passed
</code></pre>
<h3 id="expecto-단위-테스트-1"><a class="header" href="#expecto-단위-테스트-1">Expecto (단위 테스트)</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang.Tests
[16:21:05 INF] EXPECTO? Running tests...
[16:21:05 INF] EXPECTO! 93 tests run – 93 passed, 0 failed. Success!
</code></pre>
<h2 id="요약-3"><a class="header" href="#요약-3">요약</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>파일</th><th>변경 사항</th></tr>
</thead>
<tbody>
<tr><td><code>Ast.fs</code></td><td><code>Value</code> 타입, <code>Bool</code>, <code>If</code>, 비교/논리 연산자 노드</td></tr>
<tr><td><code>Lexer.fsl</code></td><td><code>TRUE</code>, <code>FALSE</code>, <code>IF</code>, <code>THEN</code>, <code>ELSE</code>, 비교/논리 토큰</td></tr>
<tr><td><code>Parser.fsy</code></td><td>우선순위 선언, if-then-else 문법, 비교/논리 규칙</td></tr>
<tr><td><code>Eval.fs</code></td><td><code>Value</code> 반환, 타입 검사, 단락 평가</td></tr>
<tr><td><code>Program.fs</code></td><td><code>formatValue</code>로 출력</td></tr>
</tbody>
</table>
</div>
<h2 id="핵심-개념-1"><a class="header" href="#핵심-개념-1">핵심 개념</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>개념</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>Value Type</td><td>평가 결과를 표현하는 discriminated union</td></tr>
<tr><td>Type Check</td><td>런타임에 피연산자 타입 검증</td></tr>
<tr><td>Short-circuit</td><td><code>&amp;&amp;</code>, <code>||</code>에서 첫 피연산자로 결과 결정 시 두 번째 평가 생략</td></tr>
<tr><td>Precedence</td><td>연산자 우선순위로 파싱 모호성 해결</td></tr>
</tbody>
</table>
</div>
<h2 id="다음-chapter-3"><a class="header" href="#다음-chapter-3">다음 Chapter</a></h2>
<p>Chapter 5에서는 함수 정의와 호출을 추가한다.</p>
<h2 id="관련-문서-3"><a class="header" href="#관련-문서-3">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/adapt-tests-for-value-type-evolution.html">adapt-tests-for-value-type-evolution</a> — evalExpr가 int→Value로 변경될 때 테스트 호환성 유지</li>
<li><a href="../docs/howto/write-fsyacc-parser.html">write-fsyacc-parser</a> — fsyacc 우선순위 선언</li>
<li><a href="../docs/howto/fsyacc-operator-precedence-methods.html">fsyacc-operator-precedence-methods</a> — 연산자 우선순위 처리 방법</li>
<li><a href="../docs/howto/testing-strategies.html">testing-strategies</a> — 테스트 전략 가이드</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-5-functions--abstraction"><a class="header" href="#chapter-5-functions--abstraction">Chapter 5: Functions &amp; Abstraction</a></h1>
<p>이 장에서는 FunLang에 함수를 추가한다. 람다 표현식, 함수 호출, 재귀 함수, 클로저를 구현하여 언어를 Turing-complete하게 만든다.</p>
<h2 id="개요-4"><a class="header" href="#개요-4">개요</a></h2>
<p>함수형 프로그래밍의 핵심인 일급 함수(first-class functions)를 구현한다:</p>
<ul>
<li><strong>람다 표현식</strong>: <code>fun x -&gt; x + 1</code></li>
<li><strong>함수 호출</strong>: <code>f 5</code></li>
<li><strong>재귀 함수</strong>: <code>let rec fact n = ...</code></li>
<li><strong>클로저</strong>: 함수가 정의 시점의 환경을 캡처</li>
</ul>
<h2 id="ast-확장-3"><a class="header" href="#ast-확장-3">AST 확장</a></h2>
<h3 id="value-타입에-functionvalue-추가"><a class="header" href="#value-타입에-functionvalue-추가">Value 타입에 FunctionValue 추가</a></h3>
<p>함수도 값이다. 함수 값은 매개변수, 본문, 그리고 <strong>클로저</strong>(정의 시점의 환경)를 포함한다.</p>
<pre><code class="language-fsharp">// FunLang/Ast.fs

/// Value type for evaluation results
and Value =
    | IntValue of int
    | BoolValue of bool
    | FunctionValue of param: string * body: Expr * closure: Env

/// Environment mapping variable names to values
and Env = Map&lt;string, Value&gt;
</code></pre>
<p><code>Value</code>와 <code>Env</code>는 상호 참조하므로 <code>and</code> 키워드로 상호 재귀 타입을 정의한다.</p>
<h3 id="expr-타입에-함수-표현식-추가"><a class="header" href="#expr-타입에-함수-표현식-추가">Expr 타입에 함수 표현식 추가</a></h3>
<pre><code class="language-fsharp">type Expr =
    // ... 기존 케이스들 ...

    // Phase 5: Functions
    | Lambda of param: string * body: Expr
    | App of func: Expr * arg: Expr
    | LetRec of name: string * param: string * body: Expr * inExpr: Expr
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>케이스</th><th>구문</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td><code>Lambda</code></td><td><code>fun x -&gt; body</code></td><td>익명 함수 생성</td></tr>
<tr><td><code>App</code></td><td><code>f arg</code></td><td>함수 호출</td></tr>
<tr><td><code>LetRec</code></td><td><code>let rec f x = body in expr</code></td><td>재귀 함수 정의</td></tr>
</tbody>
</table>
</div>
<h2 id="lexer-확장-3"><a class="header" href="#lexer-확장-3">Lexer 확장</a></h2>
<p>새로운 키워드와 연산자를 추가한다.</p>
<pre><code class="language-fsharp">// FunLang/Lexer.fsl

// Phase 5: Function keywords
| "fun"         { FUN }
| "rec"         { REC }

// Phase 5: Arrow for lambda expressions (multi-char, before single-char operators)
| "-&gt;"          { ARROW }
</code></pre>
<p><strong>중요</strong>: <code>-&gt;</code> 규칙은 <code>-</code> 규칙보다 먼저 와야 한다. 그렇지 않으면 <code>-&gt;</code> 가 <code>MINUS</code> <code>GT</code>로 잘못 토큰화된다.</p>
<h2 id="parser-확장-2"><a class="header" href="#parser-확장-2">Parser 확장</a></h2>
<h3 id="토큰-선언"><a class="header" href="#토큰-선언">토큰 선언</a></h3>
<pre><code class="language-fsharp">// FunLang/Parser.fsy

%token FUN REC ARROW
</code></pre>
<h3 id="문법-규칙"><a class="header" href="#문법-규칙">문법 규칙</a></h3>
<pre><code class="language-fsharp">Expr:
    // ... 기존 규칙들 ...

    // Phase 5: Function definitions
    | LET REC IDENT IDENT EQUALS Expr IN Expr  { LetRec($3, $4, $6, $8) }
    | FUN IDENT ARROW Expr                     { Lambda($2, $4) }
</code></pre>
<h3 id="함수-호출과-연산자-우선순위"><a class="header" href="#함수-호출과-연산자-우선순위">함수 호출과 연산자 우선순위</a></h3>
<p>함수 호출은 juxtaposition(나란히 쓰기)으로 표현된다: <code>f 5</code>. 이는 가장 높은 우선순위를 가진다.</p>
<p><strong>문제</strong>: <code>f - 1</code>은 어떻게 해석해야 하는가?</p>
<ul>
<li>뺄셈: <code>f</code>에서 <code>1</code>을 뺀다</li>
<li>함수 호출: <code>f</code>에 <code>-1</code>을 전달한다</li>
</ul>
<p><strong>해결책</strong>: <code>Atom</code> 비단말을 도입하여 함수 인자에서 단항 마이너스를 제외한다.</p>
<pre><code class="language-fsharp">// Factor: 단항 마이너스 포함
Factor:
    | MINUS Factor       { Negate($2) }
    | AppExpr            { $1 }

// AppExpr: 함수 호출 (left-associative)
// Atom만 인자로 받음 - 단항 마이너스 제외
AppExpr:
    | AppExpr Atom       { App($1, $2) }
    | Atom               { $1 }

// Atom: 가장 기본적인 표현식 (연산자 없음)
Atom:
    | NUMBER             { Number($1) }
    | IDENT              { Var($1) }
    | TRUE               { Bool(true) }
    | FALSE              { Bool(false) }
    | LPAREN Expr RPAREN { $2 }
</code></pre>
<p>이 구조로:</p>
<ul>
<li><code>f - 1</code> → 뺄셈 (<code>Subtract(Var "f", Number 1)</code>)</li>
<li><code>f (-1)</code> → 함수 호출 (<code>App(Var "f", Negate(Number 1))</code>)</li>
<li><code>f 1 2</code> → 커링 (<code>App(App(Var "f", Number 1), Number 2)</code>)</li>
</ul>
<h2 id="evaluator-구현"><a class="header" href="#evaluator-구현">Evaluator 구현</a></h2>
<h3 id="lambda-클로저-생성"><a class="header" href="#lambda-클로저-생성">Lambda: 클로저 생성</a></h3>
<p>람다 표현식을 평가하면 현재 환경을 캡처한 클로저를 생성한다.</p>
<pre><code class="language-fsharp">// FunLang/Eval.fs

| Lambda (param, body) -&gt;
    FunctionValue (param, body, env)
</code></pre>
<p><strong>핵심</strong>: 함수 값은 정의 시점의 환경(<code>env</code>)을 캡처한다. 이것이 클로저의 본질이다.</p>
<h3 id="app-함수-호출"><a class="header" href="#app-함수-호출">App: 함수 호출</a></h3>
<p>함수를 호출할 때는 <strong>클로저의 환경</strong>을 확장한다 (호출 시점의 환경이 아님).</p>
<pre><code class="language-fsharp">| App (funcExpr, argExpr) -&gt;
    let funcVal = eval env funcExpr
    match funcVal with
    | FunctionValue (param, body, closureEnv) -&gt;
        let argValue = eval env argExpr
        // 재귀 함수: 자기 자신을 클로저에 추가
        let augmentedClosureEnv =
            match funcExpr with
            | Var name -&gt; Map.add name funcVal closureEnv
            | _ -&gt; closureEnv
        let callEnv = Map.add param argValue augmentedClosureEnv
        eval callEnv body
    | _ -&gt; failwith "Type error: attempted to call non-function"
</code></pre>
<p><strong>중요 포인트</strong>:</p>
<ol>
<li>인자는 <strong>호출 시점</strong>의 환경에서 평가</li>
<li>본문은 <strong>클로저의 환경</strong>을 확장하여 평가</li>
<li>재귀 함수는 자신을 클로저에 추가하여 자기 참조 가능</li>
</ol>
<h3 id="letrec-재귀-함수-정의"><a class="header" href="#letrec-재귀-함수-정의">LetRec: 재귀 함수 정의</a></h3>
<pre><code class="language-fsharp">| LetRec (name, param, funcBody, inExpr) -&gt;
    let funcVal = FunctionValue (param, funcBody, env)
    let recEnv = Map.add name funcVal env
    eval recEnv inExpr
</code></pre>
<p>재귀가 작동하는 이유:</p>
<ol>
<li><code>LetRec</code>은 함수를 환경에 바인딩</li>
<li><code>App</code>에서 변수로 함수를 호출할 때 자기 자신을 클로저에 추가</li>
<li>함수 본문에서 자신의 이름으로 재귀 호출 가능</li>
</ol>
<h3 id="formatvalue-함수-출력"><a class="header" href="#formatvalue-함수-출력">formatValue: 함수 출력</a></h3>
<pre><code class="language-fsharp">let formatValue (v: Value) : string =
    match v with
    | IntValue n -&gt; string n
    | BoolValue b -&gt; if b then "true" else "false"
    | FunctionValue _ -&gt; "&lt;function&gt;"
</code></pre>
<p>함수는 <code>&lt;function&gt;</code>으로 표시한다.</p>
<h2 id="클로저의-이해"><a class="header" href="#클로저의-이해">클로저의 이해</a></h2>
<p>클로저는 함수가 <strong>정의 시점의 환경</strong>을 기억하는 것이다.</p>
<pre><code>let x = 10 in
let f = fun y -&gt; x + y in
let x = 100 in
f 5
</code></pre>
<p>결과는 <code>15</code>이다 (<code>115</code>가 아님). <code>f</code>가 정의될 때 <code>x = 10</code>이었고, 나중에 <code>x = 100</code>으로 섀도잉되어도 <code>f</code>의 클로저에는 여전히 <code>x = 10</code>이 저장되어 있다.</p>
<h3 id="클로저-vs-동적-스코프"><a class="header" href="#클로저-vs-동적-스코프">클로저 vs 동적 스코프</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>스코핑</th><th>설명</th><th>위 예제 결과</th></tr>
</thead>
<tbody>
<tr><td>렉시컬 스코프 (클로저)</td><td>정의 시점 환경 사용</td><td>15</td></tr>
<tr><td>동적 스코프</td><td>호출 시점 환경 사용</td><td>115</td></tr>
</tbody>
</table>
</div>
<p>FunLang은 렉시컬 스코프를 사용한다 (대부분의 현대 언어와 동일).</p>
<h2 id="커링-currying"><a class="header" href="#커링-currying">커링 (Currying)</a></h2>
<p>다중 매개변수 함수는 커링으로 구현한다:</p>
<pre><code>let add = fun x -&gt; fun y -&gt; x + y in
add 3 4
</code></pre>
<p>이것은 다음과 같이 동작한다:</p>
<ol>
<li><code>add 3</code> → <code>fun y -&gt; 3 + y</code> (클로저에 <code>x = 3</code> 저장)</li>
<li><code>(add 3) 4</code> → <code>3 + 4</code> → <code>7</code></li>
</ol>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="기본-람다"><a class="header" href="#기본-람다">기본 람다</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "fun x -&gt; x"
&lt;function&gt;

$ dotnet run --project FunLang -- --expr "fun x -&gt; x + 1"
&lt;function&gt;
</code></pre>
<h3 id="함수-바인딩과-호출"><a class="header" href="#함수-바인딩과-호출">함수 바인딩과 호출</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let f = fun x -&gt; x + 1 in f 5"
6

$ dotnet run --project FunLang -- --expr "let double = fun x -&gt; x * 2 in double 7"
14
</code></pre>
<h3 id="커링과-부분-적용"><a class="header" href="#커링과-부분-적용">커링과 부분 적용</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let add = fun x -&gt; fun y -&gt; x + y in add 3 4"
7

$ dotnet run --project FunLang -- --expr "let add = fun x -&gt; fun y -&gt; x + y in let add5 = add 5 in add5 10"
15
</code></pre>
<h3 id="중첩-함수-호출"><a class="header" href="#중첩-함수-호출">중첩 함수 호출</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let f = fun x -&gt; x + 1 in f (f (f 0))"
3
</code></pre>
<h3 id="재귀-함수-factorial"><a class="header" href="#재귀-함수-factorial">재귀 함수: Factorial</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let rec fact n = if n &lt;= 1 then 1 else n * fact (n - 1) in fact 5"
120
</code></pre>
<h3 id="재귀-함수-fibonacci"><a class="header" href="#재귀-함수-fibonacci">재귀 함수: Fibonacci</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let rec fib n = if n &lt;= 1 then n else fib (n - 1) + fib (n - 2) in fib 6"
8

$ dotnet run --project FunLang -- --expr "let rec fib n = if n &lt;= 1 then n else fib (n - 1) + fib (n - 2) in fib 10"
55
</code></pre>
<h3 id="클로저-기본"><a class="header" href="#클로저-기본">클로저: 기본</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let x = 10 in let f = fun y -&gt; x + y in f 5"
15
</code></pre>
<h3 id="클로저-중첩-바인딩"><a class="header" href="#클로저-중첩-바인딩">클로저: 중첩 바인딩</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let a = 1 in let b = 2 in let f = fun x -&gt; a + b + x in f 3"
6
</code></pre>
<h3 id="클로저-makeadder-패턴"><a class="header" href="#클로저-makeadder-패턴">클로저: makeAdder 패턴</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let makeAdder = fun x -&gt; fun y -&gt; x + y in let add5 = makeAdder 5 in add5 3"
8
</code></pre>
<h3 id="클로저-값-캡처-섀도잉-불변"><a class="header" href="#클로저-값-캡처-섀도잉-불변">클로저: 값 캡처 (섀도잉 불변)</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let x = 1 in let f = fun y -&gt; x + y in let x = 100 in f 5"
6
</code></pre>
<p><code>f</code>는 정의 시점의 <code>x = 1</code>을 캡처했으므로 나중에 <code>x = 100</code>으로 섀도잉되어도 영향받지 않는다.</p>
<h3 id="함수-호출-vs-뺄셈"><a class="header" href="#함수-호출-vs-뺄셈">함수 호출 vs 뺄셈</a></h3>
<pre><code class="language-bash"># 뺄셈: f - 1
$ dotnet run --project FunLang -- --expr "let f = 10 in f - 1"
9

# 함수 호출: f (-1)
$ dotnet run --project FunLang -- --expr "let f = fun x -&gt; x * 2 in f (-1)"
-2
</code></pre>
<h3 id="ast-확인"><a class="header" href="#ast-확인">AST 확인</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-ast --expr "fun x -&gt; x + 1"
Lambda ("x", Add (Var "x", Number 1))

$ dotnet run --project FunLang -- --emit-ast --expr "f 5"
App (Var "f", Number 5)

$ dotnet run --project FunLang -- --emit-ast --expr "let rec f x = x in f 1"
LetRec ("f", "x", Var "x", App (Var "f", Number 1))
</code></pre>
<h3 id="토큰-확인"><a class="header" href="#토큰-확인">토큰 확인</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-tokens --expr "fun x -&gt; x + 1"
FUN IDENT(x) ARROW IDENT(x) PLUS NUMBER(1) EOF
</code></pre>
<h2 id="타입-에러-1"><a class="header" href="#타입-에러-1">타입 에러</a></h2>
<pre><code class="language-bash"># 함수가 아닌 값을 호출
$ dotnet run --project FunLang -- --expr "5 3"
Type error: attempted to call non-function

$ dotnet run --project FunLang -- --expr "true 1"
Type error: attempted to call non-function
</code></pre>
<h2 id="정리"><a class="header" href="#정리">정리</a></h2>
<p>이 장에서 구현한 내용:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>구문</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td>람다 표현식</td><td><code>fun param -&gt; body</code></td><td><code>fun x -&gt; x + 1</code></td></tr>
<tr><td>함수 호출</td><td><code>func arg</code></td><td><code>f 5</code></td></tr>
<tr><td>재귀 함수</td><td><code>let rec name param = body in expr</code></td><td><code>let rec fact n = ... in fact 5</code></td></tr>
<tr><td>클로저</td><td>자동 (정의 시점 환경 캡처)</td><td><code>let x = 10 in fun y -&gt; x + y</code></td></tr>
<tr><td>커링</td><td>중첩 람다</td><td><code>fun x -&gt; fun y -&gt; x + y</code></td></tr>
</tbody>
</table>
</div>
<p><strong>FunLang은 이제 Turing-complete 언어이다.</strong> 재귀 함수를 통해 모든 계산 가능한 함수를 표현할 수 있다.</p>
<h2 id="테스트-3"><a class="header" href="#테스트-3">테스트</a></h2>
<pre><code class="language-bash"># fslit 테스트 (13개 함수 테스트 포함)
make -C tests

# Expecto 단위 테스트
dotnet run --project FunLang.Tests
</code></pre>
<p>전체 소스 코드는 <code>FunLang/</code> 디렉토리를 참조한다.</p>
<h2 id="관련-문서-4"><a class="header" href="#관련-문서-4">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/resolve-function-application-vs-subtraction.html">resolve-function-application-vs-subtraction</a> - 함수 호출과 뺄셈 문법 충돌 해결</li>
<li><a href="../docs/howto/implement-unary-minus.html">implement-unary-minus</a> - 단항 마이너스 구현</li>
<li><a href="../docs/howto/adapt-tests-for-value-type-evolution.html">adapt-tests-for-value-type-evolution</a> - Value 타입 변경 시 테스트 적응</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-6-tuples--pattern-matching"><a class="header" href="#chapter-6-tuples--pattern-matching">Chapter 6: Tuples &amp; Pattern Matching</a></h1>
<p>이 장에서는 FunLang에 튜플(Tuple)과 패턴 매칭(Pattern Matching)을 추가한다. 튜플은 고정 크기의 이종 컬렉션으로, 함수에서 여러 값을 반환하거나 관련 데이터를 묶을 때 유용하다.</p>
<h2 id="개요-5"><a class="header" href="#개요-5">개요</a></h2>
<p>튜플은 여러 타입의 값을 하나의 복합 값으로 묶는 자료구조다:</p>
<ul>
<li><strong>튜플 생성</strong>: <code>(1, 2)</code>, <code>(1, true, "hello")</code></li>
<li><strong>패턴 디스트럭처링</strong>: <code>let (x, y) = (1, 2) in x + y</code></li>
<li><strong>중첩 튜플</strong>: <code>((1, 2), 3)</code></li>
<li><strong>와일드카드 패턴</strong>: <code>let (_, y) = (1, 2) in y</code></li>
<li><strong>구조적 동등성</strong>: <code>(1, 2) = (1, 2)</code></li>
</ul>
<h2 id="ast-확장-4"><a class="header" href="#ast-확장-4">AST 확장</a></h2>
<h3 id="expr-타입에-튜플-표현식-추가"><a class="header" href="#expr-타입에-튜플-표현식-추가">Expr 타입에 튜플 표현식 추가</a></h3>
<pre><code class="language-fsharp">// FunLang/Ast.fs

type Expr =
    // ... 기존 케이스들 ...

    // Phase 1 (v3.0): Tuples
    | Tuple of Expr list               // 튜플 표현식: (e1, e2, ...)
    | LetPat of Pattern * Expr * Expr  // 패턴 바인딩: let pat = expr in body
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>케이스</th><th>구문</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td><code>Tuple</code></td><td><code>(e1, e2, ...)</code></td><td>튜플 표현식 생성</td></tr>
<tr><td><code>LetPat</code></td><td><code>let pat = expr in body</code></td><td>패턴 바인딩 let 표현식</td></tr>
</tbody>
</table>
</div>
<h3 id="pattern-타입-추가"><a class="header" href="#pattern-타입-추가">Pattern 타입 추가</a></h3>
<p>패턴은 값을 분해하여 변수에 바인딩하는 데 사용된다.</p>
<pre><code class="language-fsharp">/// Pattern for destructuring bindings
and Pattern =
    | VarPat of string           // 변수 패턴: x
    | TuplePat of Pattern list   // 튜플 패턴: (p1, p2, ...)
    | WildcardPat                // 와일드카드 패턴: _
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>패턴</th><th>구문</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td><code>VarPat</code></td><td><code>x</code></td><td>값을 변수에 바인딩</td></tr>
<tr><td><code>TuplePat</code></td><td><code>(p1, p2)</code></td><td>튜플 구조 분해</td></tr>
<tr><td><code>WildcardPat</code></td><td><code>_</code></td><td>값을 무시 (바인딩 없음)</td></tr>
</tbody>
</table>
</div>
<h3 id="value-타입에-tuplevalue-추가"><a class="header" href="#value-타입에-tuplevalue-추가">Value 타입에 TupleValue 추가</a></h3>
<pre><code class="language-fsharp">and Value =
    | IntValue of int
    | BoolValue of bool
    | FunctionValue of param: string * body: Expr * closure: Env
    | StringValue of string
    | TupleValue of Value list  // 튜플 값
</code></pre>
<p><code>TupleValue</code>는 여러 <code>Value</code>를 담는 리스트로 표현된다.</p>
<h2 id="lexer-확장-4"><a class="header" href="#lexer-확장-4">Lexer 확장</a></h2>
<p>새로운 토큰을 추가한다.</p>
<pre><code class="language-fsharp">// FunLang/Lexer.fsl

// Wildcard pattern (반드시 identifier 패턴 전에 와야 함)
| '_'           { UNDERSCORE }

// Comma for tuples
| ','           { COMMA }
</code></pre>
<p><strong>중요</strong>: <code>_</code> 규칙은 identifier 패턴(<code>ident_start ident_char*</code>)보다 먼저 와야 한다. 그렇지 않으면 <code>_</code>가 identifier로 잘못 인식된다.</p>
<h3 id="토큰-정의"><a class="header" href="#토큰-정의">토큰 정의</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>토큰</th><th>문자</th><th>용도</th></tr>
</thead>
<tbody>
<tr><td><code>COMMA</code></td><td><code>,</code></td><td>튜플 요소 구분자</td></tr>
<tr><td><code>UNDERSCORE</code></td><td><code>_</code></td><td>와일드카드 패턴</td></tr>
</tbody>
</table>
</div>
<h2 id="parser-확장-3"><a class="header" href="#parser-확장-3">Parser 확장</a></h2>
<h3 id="토큰-선언-1"><a class="header" href="#토큰-선언-1">토큰 선언</a></h3>
<pre><code class="language-fsharp">// FunLang/Parser.fsy

%token COMMA
%token UNDERSCORE
</code></pre>
<h3 id="문법-규칙-1"><a class="header" href="#문법-규칙-1">문법 규칙</a></h3>
<pre><code class="language-fsharp">Expr:
    // ... 기존 규칙들 ...

    // 패턴 바인딩 let
    | LET TuplePattern EQUALS Expr IN Expr  { LetPat($2, $4, $6) }

Atom:
    // ... 기존 규칙들 ...

    // 튜플 표현식: (e1, e2, ...)
    | LPAREN Expr COMMA ExprList RPAREN  { Tuple($2 :: $4) }

// 쉼표로 구분된 표현식 리스트
ExprList:
    | Expr                        { [$1] }
    | Expr COMMA ExprList         { $1 :: $3 }

// 튜플 패턴
TuplePattern:
    | LPAREN PatternList RPAREN   { TuplePat($2) }

PatternList:
    | Pattern COMMA Pattern       { [$1; $3] }
    | Pattern COMMA PatternList   { $1 :: $3 }

Pattern:
    | LPAREN PatternList RPAREN   { TuplePat($2) }
    | IDENT                       { VarPat($1) }
    | UNDERSCORE                  { WildcardPat }
</code></pre>
<h3 id="문법-구조-설명"><a class="header" href="#문법-구조-설명">문법 구조 설명</a></h3>
<p><strong>튜플 표현식</strong>은 <code>Atom</code> 레벨에서 파싱된다:</p>
<ul>
<li><code>(expr)</code>: 괄호로 묶인 표현식 (기존)</li>
<li><code>(e1, e2, ...)</code>: 쉼표가 있으면 튜플</li>
</ul>
<p><strong>패턴 매칭 let</strong>은 <code>Expr</code> 레벨에서:</p>
<ul>
<li><code>let x = ...</code>: 단순 변수 바인딩 (기존)</li>
<li><code>let (p1, p2) = ...</code>: 튜플 패턴 바인딩</li>
</ul>
<p><strong>PatternList</strong>는 최소 2개 패턴이 필요하다 (단일 요소 튜플은 지원하지 않음).</p>
<h2 id="evaluator-구현-1"><a class="header" href="#evaluator-구현-1">Evaluator 구현</a></h2>
<h3 id="tuple-튜플-평가"><a class="header" href="#tuple-튜플-평가">Tuple: 튜플 평가</a></h3>
<pre><code class="language-fsharp">// FunLang/Eval.fs

| Tuple exprs -&gt;
    let values = List.map (eval env) exprs
    TupleValue values
</code></pre>
<p>튜플의 각 요소를 순서대로 평가하여 <code>TupleValue</code>로 묶는다.</p>
<h3 id="matchpattern-패턴-매칭"><a class="header" href="#matchpattern-패턴-매칭">matchPattern: 패턴 매칭</a></h3>
<p>패턴과 값을 매칭하여 바인딩 리스트를 반환한다.</p>
<pre><code class="language-fsharp">/// Match a pattern against a value, returning bindings if successful
let rec matchPattern (pat: Pattern) (value: Value) : (string * Value) list option =
    match pat, value with
    | VarPat name, v -&gt; Some [(name, v)]
    | WildcardPat, _ -&gt; Some []
    | TuplePat pats, TupleValue vals -&gt;
        if List.length pats &lt;&gt; List.length vals then
            None  // Arity mismatch
        else
            let bindings = List.map2 matchPattern pats vals
            if List.forall Option.isSome bindings then
                Some (List.collect Option.get bindings)
            else
                None
    | _ -&gt; None  // Type mismatch
</code></pre>
<p><strong>핵심 포인트</strong>:</p>
<ul>
<li><code>VarPat</code>: 값을 변수에 바인딩</li>
<li><code>WildcardPat</code>: 빈 바인딩 반환 (값 무시)</li>
<li><code>TuplePat</code>: 요소 개수가 일치해야 하며, 모든 하위 패턴이 매칭되어야 함</li>
<li>매칭 실패 시 <code>None</code> 반환</li>
</ul>
<h3 id="letpat-패턴-바인딩-평가"><a class="header" href="#letpat-패턴-바인딩-평가">LetPat: 패턴 바인딩 평가</a></h3>
<pre><code class="language-fsharp">| LetPat (pat, bindingExpr, bodyExpr) -&gt;
    let value = eval env bindingExpr
    match matchPattern pat value with
    | Some bindings -&gt;
        let extendedEnv = List.fold (fun e (n, v) -&gt; Map.add n v e) env bindings
        eval extendedEnv bodyExpr
    | None -&gt;
        match pat, value with
        | TuplePat pats, TupleValue vals -&gt;
            failwithf "Pattern match failed: tuple pattern expects %d elements but value has %d"
                      (List.length pats) (List.length vals)
        | TuplePat _, _ -&gt;
            failwith "Pattern match failed: expected tuple value"
        | _ -&gt;
            failwith "Pattern match failed"
</code></pre>
<ol>
<li>바인딩 표현식을 평가</li>
<li>패턴 매칭 시도</li>
<li>성공 시 환경 확장 후 본문 평가</li>
<li>실패 시 상세한 에러 메시지 출력</li>
</ol>
<h3 id="구조적-동등성"><a class="header" href="#구조적-동등성">구조적 동등성</a></h3>
<p>튜플은 구조적 동등성(structural equality)을 지원한다.</p>
<pre><code class="language-fsharp">| Equal (left, right) -&gt;
    match eval env left, eval env right with
    | IntValue l, IntValue r -&gt; BoolValue (l = r)
    | BoolValue l, BoolValue r -&gt; BoolValue (l = r)
    | TupleValue l, TupleValue r -&gt; BoolValue (l = r)  // 구조적 비교
    | _ -&gt; failwith "Type error: = requires operands of same type"
</code></pre>
<p>F#의 <code>=</code> 연산자는 <code>Value list</code>에 대해 자동으로 구조적 비교를 수행한다.</p>
<h3 id="formatvalue-튜플-출력"><a class="header" href="#formatvalue-튜플-출력">formatValue: 튜플 출력</a></h3>
<pre><code class="language-fsharp">let rec formatValue (v: Value) : string =
    match v with
    | IntValue n -&gt; string n
    | BoolValue b -&gt; if b then "true" else "false"
    | FunctionValue _ -&gt; "&lt;function&gt;"
    | TupleValue values -&gt;
        let formattedElements = List.map formatValue values
        sprintf "(%s)" (String.concat ", " formattedElements)
</code></pre>
<p>튜플은 <code>(v1, v2, ...)</code> 형식으로 출력된다.</p>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="기본-튜플-생성"><a class="header" href="#기본-튜플-생성">기본 튜플 생성</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "(1, 2)"
(1, 2)

$ dotnet run --project FunLang -- --expr "(1, true, \"hello\")"
(1, true, "hello")

$ dotnet run --project FunLang -- --expr "(1 + 2, 3 * 4)"
(3, 12)
</code></pre>
<h3 id="튜플-패턴-디스트럭처링"><a class="header" href="#튜플-패턴-디스트럭처링">튜플 패턴 디스트럭처링</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let (x, y) = (1, 2) in x + y"
3

$ dotnet run --project FunLang -- --expr "let (a, b, c) = (1, 2, 3) in a + b + c"
6

$ dotnet run --project FunLang -- --expr "let (x, y) = (10, 20) in x * y"
200
</code></pre>
<h3 id="중첩-튜플"><a class="header" href="#중첩-튜플">중첩 튜플</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "((1, 2), 3)"
((1, 2), 3)

$ dotnet run --project FunLang -- --expr "let ((a, b), c) = ((1, 2), 3) in a + b + c"
6

$ dotnet run --project FunLang -- --expr "(1, (2, 3))"
(1, (2, 3))
</code></pre>
<h3 id="와일드카드-패턴"><a class="header" href="#와일드카드-패턴">와일드카드 패턴</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let (_, y) = (1, 2) in y"
2

$ dotnet run --project FunLang -- --expr "let (x, _) = (1, 2) in x"
1

$ dotnet run --project FunLang -- --expr "let (_, _, z) = (1, 2, 3) in z"
3

$ dotnet run --project FunLang -- --expr "let (_, (_, z)) = (1, (2, 3)) in z"
3
</code></pre>
<h3 id="튜플-동등성-비교"><a class="header" href="#튜플-동등성-비교">튜플 동등성 비교</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "(1, 2) = (1, 2)"
true

$ dotnet run --project FunLang -- --expr "(1, 2) = (1, 3)"
false

$ dotnet run --project FunLang -- --expr "(1, 2) &lt;&gt; (1, 3)"
true

$ dotnet run --project FunLang -- --expr "((1, 2), 3) = ((1, 2), 3)"
true
</code></pre>
<h3 id="함수와-튜플-조합"><a class="header" href="#함수와-튜플-조합">함수와 튜플 조합</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let swap = fun p -&gt; let (x, y) = p in (y, x) in swap (1, 2)"
(2, 1)

$ dotnet run --project FunLang -- --expr "let fst = fun p -&gt; let (x, _) = p in x in fst (10, 20)"
10

$ dotnet run --project FunLang -- --expr "let snd = fun p -&gt; let (_, y) = p in y in snd (10, 20)"
20
</code></pre>
<h3 id="repl-출력-형식"><a class="header" href="#repl-출력-형식">REPL 출력 형식</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang
FunLang REPL - Type an expression and press Enter (Ctrl+C to exit)
&gt; (1, 2, 3)
(1, 2, 3)
&gt; let (x, y) = (10, 20) in x + y
30
&gt; (true, false)
(true, false)
</code></pre>
<h3 id="ast-확인-1"><a class="header" href="#ast-확인-1">AST 확인</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-ast --expr "(1, 2)"
Tuple [Number 1; Number 2]

$ dotnet run --project FunLang -- --emit-ast --expr "(1, 2, 3)"
Tuple [Number 1; Number 2; Number 3]

$ dotnet run --project FunLang -- --emit-ast --expr "let (x, y) = (1, 2) in x"
LetPat (TuplePat [VarPat "x"; VarPat "y"], Tuple [Number 1; Number 2], Var "x")

$ dotnet run --project FunLang -- --emit-ast --expr "let (_, y) = (1, 2) in y"
LetPat (TuplePat [WildcardPat; VarPat "y"], Tuple [Number 1; Number 2], Var "y")
</code></pre>
<h3 id="토큰-확인-1"><a class="header" href="#토큰-확인-1">토큰 확인</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-tokens --expr "(1, 2)"
LPAREN NUMBER(1) COMMA NUMBER(2) RPAREN EOF

$ dotnet run --project FunLang -- --emit-tokens --expr "let (x, _) = (1, 2) in x"
LET LPAREN IDENT(x) COMMA UNDERSCORE RPAREN EQUALS LPAREN NUMBER(1) COMMA NUMBER(2) RPAREN IN IDENT(x) EOF
</code></pre>
<h2 id="타입-에러-2"><a class="header" href="#타입-에러-2">타입 에러</a></h2>
<h3 id="arity-불일치"><a class="header" href="#arity-불일치">Arity 불일치</a></h3>
<pre><code class="language-bash"># 패턴과 튜플의 요소 개수가 다름
$ dotnet run --project FunLang -- --expr "let (x, y) = (1, 2, 3) in x"
Pattern match failed: tuple pattern expects 2 elements but value has 3

$ dotnet run --project FunLang -- --expr "let (x, y, z) = (1, 2) in x"
Pattern match failed: tuple pattern expects 3 elements but value has 2
</code></pre>
<h3 id="타입-불일치"><a class="header" href="#타입-불일치">타입 불일치</a></h3>
<pre><code class="language-bash"># 튜플 패턴에 비-튜플 값
$ dotnet run --project FunLang -- --expr "let (x, y) = 5 in x"
Pattern match failed: expected tuple value

# 다른 타입 튜플 비교
$ dotnet run --project FunLang -- --expr "(1, 2) = 5"
Type error: = requires operands of same type
</code></pre>
<h2 id="정리-1"><a class="header" href="#정리-1">정리</a></h2>
<p>이 장에서 구현한 내용:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>구문</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td>튜플 생성</td><td><code>(e1, e2, ...)</code></td><td><code>(1, 2, 3)</code></td></tr>
<tr><td>변수 패턴</td><td><code>x</code></td><td><code>let x = 5 in x</code></td></tr>
<tr><td>튜플 패턴</td><td><code>(p1, p2, ...)</code></td><td><code>let (x, y) = (1, 2) in ...</code></td></tr>
<tr><td>와일드카드</td><td><code>_</code></td><td><code>let (_, y) = (1, 2) in y</code></td></tr>
<tr><td>중첩 패턴</td><td><code>((p1, p2), p3)</code></td><td><code>let ((a, b), c) = ... in ...</code></td></tr>
<tr><td>구조적 동등성</td><td><code>=</code>, <code>&lt;&gt;</code></td><td><code>(1, 2) = (1, 2)</code></td></tr>
</tbody>
</table>
</div>
<p><strong>핵심 개념</strong>:</p>
<ul>
<li>튜플은 고정 크기 이종 컬렉션이다</li>
<li>패턴 매칭으로 튜플을 분해한다</li>
<li>와일드카드(<code>_</code>)는 값을 무시한다</li>
<li>튜플은 구조적 동등성으로 비교된다</li>
</ul>
<h2 id="테스트-4"><a class="header" href="#테스트-4">테스트</a></h2>
<pre><code class="language-bash"># fslit 테스트
make -C tests

# Expecto 단위 테스트
dotnet run --project FunLang.Tests
</code></pre>
<p>전체 소스 코드는 <code>FunLang/</code> 디렉토리를 참조한다.</p>
<h2 id="관련-문서-5"><a class="header" href="#관련-문서-5">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/write-fsyacc-parser.html">write-fsyacc-parser</a> - fsyacc 파서 작성법 (튜플 문법 규칙)</li>
<li><a href="../docs/howto/adapt-tests-for-value-type-evolution.html">adapt-tests-for-value-type-evolution</a> - Value 타입 확장 시 테스트 적응</li>
<li><a href="../docs/howto/write-fslex-lexer.html">write-fslex-lexer</a> - fslex 렉서 작성법 (COMMA, UNDERSCORE 토큰)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-7-lists"><a class="header" href="#chapter-7-lists">Chapter 7: Lists</a></h1>
<p>이 장에서는 FunLang에 리스트를 추가한다. 리스트는 가변 길이의 동종(homogeneous) 컬렉션으로, 함수형 프로그래밍의 핵심 자료구조다.</p>
<h2 id="개요-6"><a class="header" href="#개요-6">개요</a></h2>
<p>리스트는 같은 타입의 값들을 순서대로 저장하는 컬렉션이다:</p>
<ul>
<li><strong>빈 리스트</strong>: <code>[]</code></li>
<li><strong>리스트 리터럴</strong>: <code>[1, 2, 3]</code></li>
<li><strong>Cons 연산자</strong>: <code>h :: t</code> (요소를 리스트 앞에 추가)</li>
</ul>
<p>리스트는 재귀적 구조를 가진다. 리스트는 빈 리스트이거나, head 요소와 tail 리스트의 조합이다.</p>
<pre><code>[1, 2, 3]  =  1 :: [2, 3]
           =  1 :: 2 :: [3]
           =  1 :: 2 :: 3 :: []
</code></pre>
<h2 id="ast-확장-5"><a class="header" href="#ast-확장-5">AST 확장</a></h2>
<h3 id="expr-타입에-리스트-표현식-추가"><a class="header" href="#expr-타입에-리스트-표현식-추가">Expr 타입에 리스트 표현식 추가</a></h3>
<pre><code class="language-fsharp">// FunLang/Ast.fs

type Expr =
    // ... 기존 케이스들 ...

    // Phase 2 (v3.0): Lists
    | EmptyList                        // 빈 리스트: []
    | List of Expr list                // 리스트 리터럴: [e1, e2, ...]
    | Cons of Expr * Expr              // Cons 연산자: h :: t
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>케이스</th><th>구문</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td><code>EmptyList</code></td><td><code>[]</code></td><td>빈 리스트</td></tr>
<tr><td><code>List</code></td><td><code>[e1, e2, ...]</code></td><td>리스트 리터럴</td></tr>
<tr><td><code>Cons</code></td><td><code>h :: t</code></td><td>head를 tail 앞에 추가</td></tr>
</tbody>
</table>
</div>
<h3 id="value-타입에-listvalue-추가"><a class="header" href="#value-타입에-listvalue-추가">Value 타입에 ListValue 추가</a></h3>
<pre><code class="language-fsharp">/// Value type for evaluation results
and Value =
    | IntValue of int
    | BoolValue of bool
    | FunctionValue of param: string * body: Expr * closure: Env
    | StringValue of string
    | TupleValue of Value list
    | ListValue of Value list  // 리스트 값
</code></pre>
<p><code>ListValue</code>는 <code>Value list</code>를 감싸는 래퍼다. F#의 네이티브 리스트를 사용하여 구현한다.</p>
<h2 id="lexer-확장-5"><a class="header" href="#lexer-확장-5">Lexer 확장</a></h2>
<p><code>Lexer.fsl</code>에 새 토큰을 추가한다.</p>
<pre><code class="language-fsharp">// FunLang/Lexer.fsl

rule tokenize = parse
    // ... 기존 규칙들 ...

    // Phase 2 (v3.0): Cons 연산자 (다중 문자, 단일 문자보다 먼저)
    | "::"          { CONS }

    // Phase 2 (v3.0): 리스트 괄호
    | '['           { LBRACKET }
    | ']'           { RBRACKET }
</code></pre>
<p><strong>중요</strong>: <code>::</code> 규칙은 단일 문자 <code>:</code> 규칙이 있다면 그보다 먼저 와야 한다. 현재 FunLang에는 <code>:</code> 토큰이 없으므로 순서는 중요하지 않지만, 다중 문자 연산자를 먼저 배치하는 것이 좋은 습관이다.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>토큰</th><th>패턴</th><th>용도</th></tr>
</thead>
<tbody>
<tr><td><code>LBRACKET</code></td><td><code>[</code></td><td>리스트 시작</td></tr>
<tr><td><code>RBRACKET</code></td><td><code>]</code></td><td>리스트 끝</td></tr>
<tr><td><code>CONS</code></td><td><code>::</code></td><td>Cons 연산자</td></tr>
</tbody>
</table>
</div>
<h2 id="parser-확장-4"><a class="header" href="#parser-확장-4">Parser 확장</a></h2>
<h3 id="토큰-선언-2"><a class="header" href="#토큰-선언-2">토큰 선언</a></h3>
<pre><code class="language-fsharp">// FunLang/Parser.fsy

// Phase 2 (v3.0): List tokens
%token LBRACKET RBRACKET CONS
</code></pre>
<h3 id="우선순위-선언"><a class="header" href="#우선순위-선언">우선순위 선언</a></h3>
<p>Cons 연산자는 <strong>우결합(right-associative)</strong> 이다.</p>
<pre><code class="language-fsharp">// 우선순위 선언 (낮은 것부터 높은 것 순)
%left OR
%left AND
%nonassoc EQUALS LT GT LE GE NE
%right CONS    // 우결합: 1 :: 2 :: [] = 1 :: (2 :: [])
</code></pre>
<p><strong>왜 우결합인가?</strong></p>
<p><code>1 :: 2 :: 3 :: []</code>는 다음과 같이 파싱되어야 한다:</p>
<pre><code>1 :: (2 :: (3 :: []))
</code></pre>
<p>좌결합이라면 <code>((1 :: 2) :: 3) :: []</code>가 되어 타입 에러가 발생한다 (정수에 정수를 cons할 수 없음).</p>
<p><strong>Cons의 우선순위 위치:</strong></p>
<p>Cons는 비교 연산자보다 낮고, 산술 연산자보다 높다:</p>
<pre><code>1 + 2 :: [3]  →  (1 + 2) :: [3]  →  [3, 3]
</code></pre>
<h3 id="문법-규칙-2"><a class="header" href="#문법-규칙-2">문법 규칙</a></h3>
<pre><code class="language-fsharp">Expr:
    // ... 기존 규칙들 ...

    // Phase 2 (v3.0): Cons 연산자 (비교보다 낮은 우선순위)
    | Expr CONS Expr                 { Cons($1, $3) }

Atom:
    // ... 기존 규칙들 ...

    // Phase 2 (v3.0): 리스트 리터럴
    | LBRACKET RBRACKET                      { EmptyList }
    | LBRACKET Expr RBRACKET                 { List([$2]) }
    | LBRACKET Expr COMMA ExprList RBRACKET  { List($2 :: $4) }
</code></pre>
<p>리스트 리터럴은 <code>ExprList</code> 비단말을 재사용한다 (튜플에서 이미 정의됨):</p>
<pre><code class="language-fsharp">// 콤마로 구분된 표현식 목록
ExprList:
    | Expr                        { [$1] }
    | Expr COMMA ExprList         { $1 :: $3 }
</code></pre>
<p><strong>리스트 파싱 규칙:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>입력</th><th>매칭 규칙</th><th>결과</th></tr>
</thead>
<tbody>
<tr><td><code>[]</code></td><td><code>LBRACKET RBRACKET</code></td><td><code>EmptyList</code></td></tr>
<tr><td><code>[1]</code></td><td><code>LBRACKET Expr RBRACKET</code></td><td><code>List([Number 1])</code></td></tr>
<tr><td><code>[1, 2, 3]</code></td><td><code>LBRACKET Expr COMMA ExprList RBRACKET</code></td><td><code>List([Number 1; Number 2; Number 3])</code></td></tr>
</tbody>
</table>
</div>
<h2 id="evaluator-구현-2"><a class="header" href="#evaluator-구현-2">Evaluator 구현</a></h2>
<h3 id="emptylist-빈-리스트-평가"><a class="header" href="#emptylist-빈-리스트-평가">EmptyList: 빈 리스트 평가</a></h3>
<pre><code class="language-fsharp">// FunLang/Eval.fs

| EmptyList -&gt;
    ListValue []
</code></pre>
<p>빈 리스트는 빈 <code>ListValue</code>로 평가된다.</p>
<h3 id="list-리스트-리터럴-평가"><a class="header" href="#list-리스트-리터럴-평가">List: 리스트 리터럴 평가</a></h3>
<pre><code class="language-fsharp">| List exprs -&gt;
    let values = List.map (eval env) exprs
    ListValue values
</code></pre>
<p>각 요소를 순서대로 평가하고 <code>ListValue</code>로 감싼다.</p>
<h3 id="cons-cons-연산자-평가"><a class="header" href="#cons-cons-연산자-평가">Cons: Cons 연산자 평가</a></h3>
<pre><code class="language-fsharp">| Cons (headExpr, tailExpr) -&gt;
    let headVal = eval env headExpr
    match eval env tailExpr with
    | ListValue tailVals -&gt; ListValue (headVal :: tailVals)
    | _ -&gt; failwith "Type error: cons (::) requires list as second argument"
</code></pre>
<p><strong>핵심 포인트:</strong></p>
<ol>
<li>head는 어떤 값이든 가능</li>
<li>tail은 반드시 <code>ListValue</code>여야 함</li>
<li>F#의 <code>::</code> 연산자로 실제 prepend 수행</li>
</ol>
<h3 id="구조적-동등성-structural-equality"><a class="header" href="#구조적-동등성-structural-equality">구조적 동등성 (Structural Equality)</a></h3>
<p>리스트는 구조적 동등성을 지원한다:</p>
<pre><code class="language-fsharp">| Equal (left, right) -&gt;
    match eval env left, eval env right with
    // ... 기존 케이스들 ...
    | ListValue l, ListValue r -&gt; BoolValue (l = r)
    | _ -&gt; failwith "Type error: = requires operands of same type"

| NotEqual (left, right) -&gt;
    match eval env left, eval env right with
    // ... 기존 케이스들 ...
    | ListValue l, ListValue r -&gt; BoolValue (l &lt;&gt; r)
    | _ -&gt; failwith "Type error: &lt;&gt; requires operands of same type"
</code></pre>
<p>F#의 <code>Value</code> 타입이 구조적 동등성을 자동으로 지원하므로, <code>l = r</code>로 중첩된 리스트도 올바르게 비교된다.</p>
<h3 id="formatvalue-리스트-출력"><a class="header" href="#formatvalue-리스트-출력">formatValue: 리스트 출력</a></h3>
<pre><code class="language-fsharp">let rec formatValue (v: Value) : string =
    match v with
    // ... 기존 케이스들 ...
    | ListValue values -&gt;
        let formattedElements = List.map formatValue values
        sprintf "[%s]" (String.concat ", " formattedElements)
</code></pre>
<p>출력 형식: <code>[1, 2, 3]</code></p>
<p>중첩 리스트의 경우 재귀적으로 포맷팅된다: <code>[[1, 2], [3, 4]]</code></p>
<h2 id="연산자-우선순위-정리"><a class="header" href="#연산자-우선순위-정리">연산자 우선순위 정리</a></h2>
<p>FunLang의 전체 연산자 우선순위 (낮은 것부터 높은 것 순):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>우선순위</th><th>연산자</th><th>결합성</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>1 (낮음)</td><td><code>||</code></td><td>좌결합</td><td>논리 OR</td></tr>
<tr><td>2</td><td><code>&amp;&amp;</code></td><td>좌결합</td><td>논리 AND</td></tr>
<tr><td>3</td><td><code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>비결합</td><td>비교</td></tr>
<tr><td>4</td><td><code>::</code></td><td><strong>우결합</strong></td><td>Cons</td></tr>
<tr><td>5</td><td><code>+</code>, <code>-</code></td><td>좌결합</td><td>덧셈, 뺄셈</td></tr>
<tr><td>6</td><td><code>*</code>, <code>/</code></td><td>좌결합</td><td>곱셈, 나눗셈</td></tr>
<tr><td>7</td><td>단항 <code>-</code></td><td>-</td><td>부정</td></tr>
<tr><td>8 (높음)</td><td>함수 호출</td><td>좌결합</td><td><code>f x</code></td></tr>
</tbody>
</table>
</div>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="빈-리스트"><a class="header" href="#빈-리스트">빈 리스트</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "[]"
[]
</code></pre>
<h3 id="리스트-리터럴"><a class="header" href="#리스트-리터럴">리스트 리터럴</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "[1, 2, 3]"
[1, 2, 3]

$ dotnet run --project FunLang -- --expr "[true, false]"
[true, false]
</code></pre>
<h3 id="cons-연산자"><a class="header" href="#cons-연산자">Cons 연산자</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "1 :: [2, 3]"
[1, 2, 3]

$ dotnet run --project FunLang -- --expr "1 :: 2 :: 3 :: []"
[1, 2, 3]
</code></pre>
<p>우결합이므로 <code>1 :: 2 :: 3 :: []</code>는 <code>1 :: (2 :: (3 :: []))</code>로 파싱된다.</p>
<h3 id="중첩-리스트"><a class="header" href="#중첩-리스트">중첩 리스트</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "[[1, 2], [3, 4]]"
[[1, 2], [3, 4]]
</code></pre>
<h3 id="리스트-동등성"><a class="header" href="#리스트-동등성">리스트 동등성</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "[1, 2] = [1, 2]"
true

$ dotnet run --project FunLang -- --expr "[1, 2] &lt;&gt; [1, 2, 3]"
true

$ dotnet run --project FunLang -- --expr "[1] &lt;&gt; []"
true
</code></pre>
<h3 id="튜플과-조합"><a class="header" href="#튜플과-조합">튜플과 조합</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "[(1, 2), (3, 4)]"
[(1, 2), (3, 4)]
</code></pre>
<h3 id="산술과-cons-우선순위"><a class="header" href="#산술과-cons-우선순위">산술과 Cons 우선순위</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "1 + 2 :: [3]"
[3, 3]
</code></pre>
<p><code>1 + 2</code>가 먼저 계산되어 <code>3 :: [3]</code> = <code>[3, 3]</code>이 된다.</p>
<h3 id="조건문과-조합"><a class="header" href="#조건문과-조합">조건문과 조합</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "if true then [1, 2] else []"
[1, 2]

$ dotnet run --project FunLang -- --expr "[1] = [1] &amp;&amp; true"
true
</code></pre>
<h3 id="let-바인딩과-조합"><a class="header" href="#let-바인딩과-조합">Let 바인딩과 조합</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let xs = [1, 2, 3] in xs"
[1, 2, 3]

$ dotnet run --project FunLang -- --expr "let x = 1 in x :: [2, 3]"
[1, 2, 3]
</code></pre>
<h3 id="함수와-조합"><a class="header" href="#함수와-조합">함수와 조합</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "let f = fun x -&gt; x :: [] in f 42"
[42]
</code></pre>
<h3 id="ast-확인-2"><a class="header" href="#ast-확인-2">AST 확인</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-ast --expr "[]"
EmptyList

$ dotnet run --project FunLang -- --emit-ast --expr "[1, 2, 3]"
List [Number 1; Number 2; Number 3]

$ dotnet run --project FunLang -- --emit-ast --expr "1 :: [2, 3]"
Cons (Number 1, List [Number 2; Number 3])

$ dotnet run --project FunLang -- --emit-ast --expr "1 :: 2 :: []"
Cons (Number 1, Cons (Number 2, EmptyList))
</code></pre>
<p>마지막 예시에서 우결합이 명확히 드러난다: <code>Cons (Number 1, Cons (Number 2, EmptyList))</code>.</p>
<h3 id="토큰-확인-2"><a class="header" href="#토큰-확인-2">토큰 확인</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-tokens --expr "[1, 2, 3]"
LBRACKET NUMBER(1) COMMA NUMBER(2) COMMA NUMBER(3) RBRACKET EOF

$ dotnet run --project FunLang -- --emit-tokens --expr "1 :: [2, 3]"
NUMBER(1) CONS LBRACKET NUMBER(2) COMMA NUMBER(3) RBRACKET EOF
</code></pre>
<h2 id="타입-에러-3"><a class="header" href="#타입-에러-3">타입 에러</a></h2>
<h3 id="cons의-두-번째-인자가-리스트가-아닐-때"><a class="header" href="#cons의-두-번째-인자가-리스트가-아닐-때">Cons의 두 번째 인자가 리스트가 아닐 때</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "1 :: 2"
Error: Type error: cons (::) requires list as second argument
</code></pre>
<h3 id="다른-타입의-리스트-비교"><a class="header" href="#다른-타입의-리스트-비교">다른 타입의 리스트 비교</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "[1, 2] = true"
Error: Type error: = requires operands of same type
</code></pre>
<h2 id="정리-2"><a class="header" href="#정리-2">정리</a></h2>
<p>이 장에서 구현한 내용:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>구문</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td>빈 리스트</td><td><code>[]</code></td><td><code>[]</code></td></tr>
<tr><td>리스트 리터럴</td><td><code>[e1, e2, ...]</code></td><td><code>[1, 2, 3]</code></td></tr>
<tr><td>Cons 연산자</td><td><code>h :: t</code></td><td><code>1 :: [2, 3]</code></td></tr>
<tr><td>리스트 동등성</td><td><code>=</code>, <code>&lt;&gt;</code></td><td><code>[1, 2] = [1, 2]</code></td></tr>
<tr><td>중첩 리스트</td><td>-</td><td><code>[[1], [2, 3]]</code></td></tr>
</tbody>
</table>
</div>
<p><strong>파일별 변경 사항:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>파일</th><th>변경 사항</th></tr>
</thead>
<tbody>
<tr><td><code>Ast.fs</code></td><td><code>EmptyList</code>, <code>List</code>, <code>Cons</code> 케이스, <code>ListValue</code></td></tr>
<tr><td><code>Lexer.fsl</code></td><td><code>LBRACKET</code>, <code>RBRACKET</code>, <code>CONS</code> 토큰</td></tr>
<tr><td><code>Parser.fsy</code></td><td><code>%right CONS</code> 선언, 리스트 리터럴 규칙</td></tr>
<tr><td><code>Eval.fs</code></td><td>리스트 평가, Cons 평가, 구조적 동등성, <code>formatValue</code></td></tr>
</tbody>
</table>
</div>
<h2 id="테스트-5"><a class="header" href="#테스트-5">테스트</a></h2>
<pre><code class="language-bash"># fslit 테스트
make -C tests

# Expecto 단위 테스트
dotnet run --project FunLang.Tests
</code></pre>
<h2 id="관련-문서-6"><a class="header" href="#관련-문서-6">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/fsyacc-operator-precedence-methods.html">fsyacc-operator-precedence-methods</a> - 연산자 우선순위 처리 방법 (<code>%right</code>로 우결합 선언)</li>
<li><a href="../docs/howto/fsyacc-precedence-without-declarations.html">fsyacc-precedence-without-declarations</a> - 문법 계층으로 우선순위 인코딩</li>
<li><a href="../docs/howto/write-fsyacc-parser.html">write-fsyacc-parser</a> - fsyacc 기본 문법</li>
<li><a href="../docs/howto/adapt-tests-for-value-type-evolution.html">adapt-tests-for-value-type-evolution</a> - Value 타입 확장 시 테스트 적응</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-8-pattern-matching"><a class="header" href="#chapter-8-pattern-matching">Chapter 8: Pattern Matching</a></h1>
<p>이 장에서는 FunLang에 패턴 매칭을 추가한다. <code>match</code> 표현식을 사용하여 값의 구조를 검사하고 분해할 수 있다.</p>
<h2 id="개요-7"><a class="header" href="#개요-7">개요</a></h2>
<p>패턴 매칭은 함수형 프로그래밍의 핵심 기능이다. 조건문보다 강력하며, 값을 검사하는 동시에 내부 구조를 분해하여 변수에 바인딩할 수 있다.</p>
<p>FunLang의 패턴 매칭:</p>
<ul>
<li><strong>Match 표현식</strong>: <code>match e with | p1 -&gt; e1 | p2 -&gt; e2</code></li>
<li><strong>패턴 종류</strong>: 상수, 변수, 와일드카드, cons, 빈 리스트, 튜플</li>
<li><strong>First-match 의미</strong>: 패턴을 위에서 아래로 순서대로 시도</li>
<li><strong>비소진 매칭 에러</strong>: 어떤 패턴도 매칭되지 않으면 런타임 에러</li>
</ul>
<p>패턴 매칭을 사용하면 리스트 처리와 재귀 함수를 우아하게 작성할 수 있다.</p>
<h2 id="ast-확장-6"><a class="header" href="#ast-확장-6">AST 확장</a></h2>
<h3 id="match-표현식과-패턴-타입"><a class="header" href="#match-표현식과-패턴-타입">Match 표현식과 패턴 타입</a></h3>
<pre><code class="language-fsharp">// FunLang/Ast.fs

type Expr =
    // ... 기존 케이스들 ...

    // Phase 3 (v3.0): Pattern Matching
    | Match of scrutinee: Expr * clauses: MatchClause list

/// Pattern for destructuring bindings
and Pattern =
    | VarPat of string           // 변수 패턴: x
    | TuplePat of Pattern list   // 튜플 패턴: (p1, p2, ...)
    | WildcardPat                // 와일드카드 패턴: _
    // Phase 3 (v3.0): New pattern types for match expressions
    | ConsPat of Pattern * Pattern     // Cons 패턴: h :: t
    | EmptyListPat                     // 빈 리스트 패턴: []
    | ConstPat of Constant             // 상수 패턴: 1, true, false

/// Match clause: pattern -&gt; expression
and MatchClause = Pattern * Expr

/// Constant values for patterns
and Constant =
    | IntConst of int
    | BoolConst of bool
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>타입</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td><code>Match</code></td><td>검사할 값(<code>scrutinee</code>)과 매칭 절 리스트</td></tr>
<tr><td><code>MatchClause</code></td><td>패턴과 결과 표현식의 쌍</td></tr>
<tr><td><code>Constant</code></td><td>패턴에서 사용할 상수 값 (정수, 불린)</td></tr>
</tbody>
</table>
</div>
<h3 id="패턴-종류"><a class="header" href="#패턴-종류">패턴 종류</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>패턴</th><th>구문</th><th>매칭 조건</th><th>바인딩</th></tr>
</thead>
<tbody>
<tr><td><code>VarPat</code></td><td><code>x</code></td><td>모든 값</td><td><code>x</code>에 값 바인딩</td></tr>
<tr><td><code>WildcardPat</code></td><td><code>_</code></td><td>모든 값</td><td>바인딩 없음</td></tr>
<tr><td><code>ConstPat</code></td><td><code>1</code>, <code>true</code></td><td>상수와 동일한 값</td><td>바인딩 없음</td></tr>
<tr><td><code>EmptyListPat</code></td><td><code>[]</code></td><td>빈 리스트</td><td>바인딩 없음</td></tr>
<tr><td><code>ConsPat</code></td><td><code>h :: t</code></td><td>비어있지 않은 리스트</td><td><code>h</code>에 첫 요소, <code>t</code>에 나머지</td></tr>
<tr><td><code>TuplePat</code></td><td><code>(x, y)</code></td><td>같은 길이의 튜플</td><td>각 요소를 변수에 바인딩</td></tr>
</tbody>
</table>
</div>
<h2 id="lexer-확장-6"><a class="header" href="#lexer-확장-6">Lexer 확장</a></h2>
<p><code>Lexer.fsl</code>에 패턴 매칭 토큰을 추가한다.</p>
<pre><code class="language-fsharp">// FunLang/Lexer.fsl

// Phase 3 (v3.0): Pattern matching keywords
| "match"       { MATCH }
| "with"        { WITH }

// Phase 3 (v3.0): Pipe for match clauses
| '|'           { PIPE }
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>토큰</th><th>용도</th></tr>
</thead>
<tbody>
<tr><td><code>MATCH</code></td><td>match 표현식 시작</td></tr>
<tr><td><code>WITH</code></td><td>scrutinee와 패턴 절 구분</td></tr>
<tr><td><code>PIPE</code></td><td>각 패턴 절 앞에 위치 (<code>|</code> 문자)</td></tr>
</tbody>
</table>
</div>
<h2 id="parser-확장-5"><a class="header" href="#parser-확장-5">Parser 확장</a></h2>
<h3 id="토큰-선언-3"><a class="header" href="#토큰-선언-3">토큰 선언</a></h3>
<pre><code class="language-fsharp">// FunLang/Parser.fsy

// Phase 3 (v3.0): Pattern matching tokens
%token MATCH WITH PIPE
</code></pre>
<h3 id="match-표현식-문법"><a class="header" href="#match-표현식-문법">Match 표현식 문법</a></h3>
<p>Match 표현식은 가장 낮은 우선순위를 가진다 (let, if보다도 낮음).</p>
<pre><code class="language-fsharp">Expr:
    // Phase 3 (v3.0): Match expression - lowest precedence
    | MATCH Expr WITH MatchClauses   { Match($2, $4) }
    // ... 기존 규칙들 ...
</code></pre>
<p><strong>구문 구조</strong>:</p>
<pre><code>match &lt;scrutinee&gt; with
| &lt;pattern1&gt; -&gt; &lt;expr1&gt;
| &lt;pattern2&gt; -&gt; &lt;expr2&gt;
...
</code></pre>
<h3 id="match-절-문법"><a class="header" href="#match-절-문법">Match 절 문법</a></h3>
<pre><code class="language-fsharp">// Phase 3 (v3.0): Match clauses (non-empty, requires leading PIPE)
MatchClauses:
    | PIPE Pattern ARROW Expr                { [($2, $4)] }
    | PIPE Pattern ARROW Expr MatchClauses   { ($2, $4) :: $5 }
</code></pre>
<p><strong>핵심 포인트</strong>:</p>
<ul>
<li>각 절은 반드시 <code>|</code>로 시작</li>
<li>첫 번째 절도 <code>|</code>로 시작 (일관성)</li>
<li>재귀적 정의로 여러 절 지원</li>
</ul>
<h3 id="패턴-문법"><a class="header" href="#패턴-문법">패턴 문법</a></h3>
<pre><code class="language-fsharp">Pattern:
    | LPAREN PatternList RPAREN   { TuplePat($2) }
    | IDENT                       { VarPat($1) }
    | UNDERSCORE                  { WildcardPat }
    // Phase 3 (v3.0): Extended patterns for match expressions
    | NUMBER                      { ConstPat(IntConst($1)) }
    | TRUE                        { ConstPat(BoolConst(true)) }
    | FALSE                       { ConstPat(BoolConst(false)) }
    | LBRACKET RBRACKET           { EmptyListPat }
    | Pattern CONS Pattern        { ConsPat($1, $3) }
</code></pre>
<p><strong>Cons 패턴의 우선순위</strong>:</p>
<p>Cons 패턴은 이미 선언된 <code>%right CONS</code>를 재사용한다:</p>
<pre><code class="language-fsharp">// 우선순위 선언
%right CONS    // Right-associative
</code></pre>
<p>예시:</p>
<pre><code>h :: t :: rest  →  ConsPat(h, ConsPat(t, rest))
</code></pre>
<h2 id="evaluator-구현-3"><a class="header" href="#evaluator-구현-3">Evaluator 구현</a></h2>
<h3 id="matchpattern-패턴-매칭-함수"><a class="header" href="#matchpattern-패턴-매칭-함수">matchPattern: 패턴 매칭 함수</a></h3>
<p><code>matchPattern</code>은 패턴과 값을 비교하여 바인딩을 생성한다.</p>
<pre><code class="language-fsharp">// FunLang/Eval.fs

/// Match a pattern against a value, returning bindings if successful
let rec matchPattern (pat: Pattern) (value: Value) : (string * Value) list option =
    match pat, value with
    | VarPat name, v -&gt; Some [(name, v)]
    | WildcardPat, _ -&gt; Some []
    | TuplePat pats, TupleValue vals -&gt;
        if List.length pats &lt;&gt; List.length vals then
            None  // Arity mismatch
        else
            let bindings = List.map2 matchPattern pats vals
            if List.forall Option.isSome bindings then
                Some (List.collect Option.get bindings)
            else
                None
    // Constant patterns
    | ConstPat (IntConst n), IntValue m -&gt;
        if n = m then Some [] else None
    | ConstPat (BoolConst b1), BoolValue b2 -&gt;
        if b1 = b2 then Some [] else None
    // Empty list pattern
    | EmptyListPat, ListValue [] -&gt; Some []
    // Cons pattern - matches non-empty list
    | ConsPat (headPat, tailPat), ListValue (h :: t) -&gt;
        match matchPattern headPat h with
        | Some headBindings -&gt;
            match matchPattern tailPat (ListValue t) with
            | Some tailBindings -&gt; Some (headBindings @ tailBindings)
            | None -&gt; None
        | None -&gt; None
    | _ -&gt; None  // Type mismatch
</code></pre>
<p><strong>반환 값</strong>:</p>
<ul>
<li><code>Some [바인딩 리스트]</code>: 매칭 성공</li>
<li><code>None</code>: 매칭 실패</li>
</ul>
<p><strong>매칭 규칙</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>패턴</th><th>값</th><th>결과</th><th>바인딩</th></tr>
</thead>
<tbody>
<tr><td><code>VarPat "x"</code></td><td>모든 값</td><td>성공</td><td><code>[("x", value)]</code></td></tr>
<tr><td><code>WildcardPat</code></td><td>모든 값</td><td>성공</td><td><code>[]</code></td></tr>
<tr><td><code>ConstPat (IntConst 1)</code></td><td><code>IntValue 1</code></td><td>성공</td><td><code>[]</code></td></tr>
<tr><td><code>ConstPat (IntConst 1)</code></td><td><code>IntValue 2</code></td><td>실패</td><td>-</td></tr>
<tr><td><code>EmptyListPat</code></td><td><code>ListValue []</code></td><td>성공</td><td><code>[]</code></td></tr>
<tr><td><code>ConsPat (VarPat "h", VarPat "t")</code></td><td><code>ListValue [1; 2; 3]</code></td><td>성공</td><td><code>[("h", IntValue 1); ("t", ListValue [2; 3])]</code></td></tr>
<tr><td><code>TuplePat [VarPat "x"; VarPat "y"]</code></td><td><code>TupleValue [IntValue 1; IntValue 2]</code></td><td>성공</td><td><code>[("x", IntValue 1); ("y", IntValue 2)]</code></td></tr>
</tbody>
</table>
</div>
<h3 id="evalmatchclauses-match-절-평가"><a class="header" href="#evalmatchclauses-match-절-평가">evalMatchClauses: Match 절 평가</a></h3>
<pre><code class="language-fsharp">/// Evaluate match clauses sequentially, returning first match
and evalMatchClauses (env: Env) (scrutinee: Value) (clauses: MatchClause list) : Value =
    match clauses with
    | [] -&gt; failwith "Match failure: no pattern matched"
    | (pattern, resultExpr) :: rest -&gt;
        match matchPattern pattern scrutinee with
        | Some bindings -&gt;
            let extendedEnv = List.fold (fun e (n, v) -&gt; Map.add n v e) env bindings
            eval extendedEnv resultExpr
        | None -&gt;
            evalMatchClauses env scrutinee rest
</code></pre>
<p><strong>작동 방식</strong>:</p>
<ol>
<li>절 리스트를 순서대로 순회</li>
<li>각 패턴을 <code>matchPattern</code>으로 시도</li>
<li>매칭되면:
<ul>
<li>바인딩을 환경에 추가</li>
<li>결과 표현식을 확장된 환경에서 평가</li>
</ul>
</li>
<li>매칭 실패하면 다음 절 시도</li>
<li>모든 절이 실패하면 런타임 에러</li>
</ol>
<h3 id="match-표현식-평가"><a class="header" href="#match-표현식-평가">Match 표현식 평가</a></h3>
<pre><code class="language-fsharp">// Phase 3 (v3.0): Pattern Matching
| Match (scrutinee, clauses) -&gt;
    let value = eval env scrutinee
    evalMatchClauses env value clauses
</code></pre>
<ol>
<li>scrutinee를 평가하여 값 얻기</li>
<li><code>evalMatchClauses</code>로 첫 번째 매칭되는 절 찾기</li>
<li>해당 절의 결과 반환</li>
</ol>
<h2 id="패턴-매칭-활용-예시"><a class="header" href="#패턴-매칭-활용-예시">패턴 매칭 활용 예시</a></h2>
<h3 id="상수-패턴"><a class="header" href="#상수-패턴">상수 패턴</a></h3>
<pre><code class="language-fsharp">match x with
| 0 -&gt; "zero"
| 1 -&gt; "one"
| _ -&gt; "other"
</code></pre>
<p>숫자를 문자열로 변환한다. 와일드카드 <code>_</code>는 모든 값을 매칭한다.</p>
<h3 id="리스트-패턴-재귀적-합계"><a class="header" href="#리스트-패턴-재귀적-합계">리스트 패턴: 재귀적 합계</a></h3>
<pre><code class="language-fsharp">let rec sum xs =
    match xs with
    | [] -&gt; 0
    | h :: t -&gt; h + sum t
</code></pre>
<p><strong>작동 방식</strong>:</p>
<ul>
<li><code>[]</code>: 빈 리스트면 0 반환</li>
<li><code>h :: t</code>: 비어있지 않으면 첫 요소 + 나머지 합계</li>
</ul>
<p><strong>예시 평가</strong>:</p>
<pre><code>sum [1, 2, 3]
→ match [1, 2, 3] with ...
→ 1 + sum [2, 3]
→ 1 + (2 + sum [3])
→ 1 + (2 + (3 + sum []))
→ 1 + (2 + (3 + 0))
→ 6
</code></pre>
<h3 id="튜플-패턴"><a class="header" href="#튜플-패턴">튜플 패턴</a></h3>
<pre><code class="language-fsharp">match pair with
| (x, y) -&gt; x + y
</code></pre>
<p>튜플을 분해하여 각 요소를 변수에 바인딩한다.</p>
<h3 id="중첩-패턴"><a class="header" href="#중첩-패턴">중첩 패턴</a></h3>
<pre><code class="language-fsharp">match xs with
| (h1 :: h2 :: t) -&gt; h1 + h2
| _ -&gt; 0
</code></pre>
<p>최소 두 개의 요소가 있는 리스트에서 첫 두 요소를 추출한다.</p>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<h3 id="상수-매칭"><a class="header" href="#상수-매칭">상수 매칭</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'match 1 with | 1 -&gt; "one" | _ -&gt; "other"'
"one"

$ dotnet run --project FunLang -- -e 'match 2 with | 1 -&gt; "one" | _ -&gt; "other"'
"other"

$ dotnet run --project FunLang -- -e 'match true with | true -&gt; 1 | false -&gt; 0'
1
</code></pre>
<h3 id="리스트-패턴-head와-tail"><a class="header" href="#리스트-패턴-head와-tail">리스트 패턴: Head와 Tail</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'match [1, 2, 3] with | [] -&gt; 0 | h :: t -&gt; h'
1

$ dotnet run --project FunLang -- -e 'match [] with | [] -&gt; 0 | h :: t -&gt; h'
0

$ dotnet run --project FunLang -- -e 'match [1, 2, 3] with | h :: t -&gt; t'
[2, 3]
</code></pre>
<p>첫 번째 예시는 리스트의 첫 요소(head)를 반환한다. 세 번째 예시는 나머지(tail)를 반환한다.</p>
<h3 id="튜플-패턴-1"><a class="header" href="#튜플-패턴-1">튜플 패턴</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'match (1, 2) with | (x, y) -&gt; x + y'
3

$ dotnet run --project FunLang -- -e 'match (5, 10) with | (a, b) -&gt; a * b'
50
</code></pre>
<h3 id="재귀-함수-리스트-합계"><a class="header" href="#재귀-함수-리스트-합계">재귀 함수: 리스트 합계</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'let rec sum xs = match xs with | [] -&gt; 0 | h :: t -&gt; h + sum t in sum [1, 2, 3, 4, 5]'
15
</code></pre>
<p><strong>평가 과정</strong>:</p>
<pre><code>sum [1, 2, 3, 4, 5]
→ 1 + sum [2, 3, 4, 5]
→ 1 + 2 + sum [3, 4, 5]
→ 1 + 2 + 3 + sum [4, 5]
→ 1 + 2 + 3 + 4 + sum [5]
→ 1 + 2 + 3 + 4 + 5 + sum []
→ 1 + 2 + 3 + 4 + 5 + 0
→ 15
</code></pre>
<h3 id="재귀-함수-리스트-길이"><a class="header" href="#재귀-함수-리스트-길이">재귀 함수: 리스트 길이</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'let rec length xs = match xs with | [] -&gt; 0 | h :: t -&gt; 1 + length t in length [1, 2, 3]'
3
</code></pre>
<h3 id="재귀-함수-리스트-뒤집기"><a class="header" href="#재귀-함수-리스트-뒤집기">재귀 함수: 리스트 뒤집기</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'let rec rev xs = match xs with | [] -&gt; [] | h :: t -&gt; rev t + [h] in rev [1, 2, 3]'
[3, 2, 1]
</code></pre>
<p><strong>참고</strong>: 이 구현은 <code>+</code> 연산자가 리스트 연결을 지원한다고 가정한다. 실제 FunLang에서는 문자열 연결만 지원하므로, 더 복잡한 구현이 필요할 수 있다.</p>
<h3 id="중첩-패턴-1"><a class="header" href="#중첩-패턴-1">중첩 패턴</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'match [1, 2, 3] with | h1 :: h2 :: t -&gt; h1 + h2 | _ -&gt; 0'
3

$ dotnet run --project FunLang -- -e 'match [1] with | h1 :: h2 :: t -&gt; h1 + h2 | _ -&gt; 0'
0
</code></pre>
<p>첫 번째 예시는 최소 두 요소가 있으므로 첫 두 요소를 더한다. 두 번째는 요소가 하나뿐이므로 와일드카드 패턴이 매칭된다.</p>
<h3 id="불린-패턴"><a class="header" href="#불린-패턴">불린 패턴</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'match true &amp;&amp; false with | true -&gt; "yes" | false -&gt; "no"'
"no"

$ dotnet run --project FunLang -- -e 'match 5 &gt; 3 with | true -&gt; "greater" | false -&gt; "not greater"'
"greater"
</code></pre>
<h3 id="복잡한-예시-필터링"><a class="header" href="#복잡한-예시-필터링">복잡한 예시: 필터링</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'let rec filter f xs = match xs with | [] -&gt; [] | h :: t -&gt; if f h then h :: filter f t else filter f t in let isPositive = fun x -&gt; x &gt; 0 in filter isPositive [-1, 2, -3, 4]'
[2, 4]
</code></pre>
<p><strong>참고</strong>: 이 예시는 설명을 위한 것이며, 실제 FunLang 구현에서 모든 기능이 지원되는지 확인이 필요할 수 있다.</p>
<h3 id="ast-확인-3"><a class="header" href="#ast-확인-3">AST 확인</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-ast -e 'match x with | 1 -&gt; "one" | _ -&gt; "other"'
Match (Var "x", [(ConstPat (IntConst 1), String "one"); (WildcardPat, String "other")])

$ dotnet run --project FunLang -- --emit-ast -e 'match xs with | [] -&gt; 0 | h :: t -&gt; h'
Match (Var "xs", [(EmptyListPat, Number 0); (ConsPat (VarPat "h", VarPat "t"), Var "h")])
</code></pre>
<h2 id="런타임-에러"><a class="header" href="#런타임-에러">런타임 에러</a></h2>
<h3 id="비소진-매칭-non-exhaustive-match"><a class="header" href="#비소진-매칭-non-exhaustive-match">비소진 매칭 (Non-exhaustive Match)</a></h3>
<p>모든 패턴이 실패하면 런타임 에러가 발생한다.</p>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'match 2 with | 1 -&gt; "one"'
Error: Match failure: no pattern matched
</code></pre>
<p>이 예시는 <code>2</code>를 매칭하지만, 패턴은 <code>1</code>만 처리한다.</p>
<p><strong>해결책</strong>: 와일드카드 패턴으로 모든 경우를 처리한다.</p>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'match 2 with | 1 -&gt; "one" | _ -&gt; "other"'
"other"
</code></pre>
<h3 id="타입-불일치-1"><a class="header" href="#타입-불일치-1">타입 불일치</a></h3>
<p>패턴과 값의 타입이 맞지 않으면 매칭 실패한다.</p>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'match 1 with | [] -&gt; 0'
Error: Match failure: no pattern matched
</code></pre>
<p>정수 <code>1</code>은 빈 리스트 패턴 <code>[]</code>와 매칭되지 않는다.</p>
<h2 id="패턴-매칭-vs-if-then-else"><a class="header" href="#패턴-매칭-vs-if-then-else">패턴 매칭 vs If-Then-Else</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>If-Then-Else</th><th>Pattern Matching</th></tr>
</thead>
<tbody>
<tr><td>구조 분해</td><td>불가능</td><td>가능 (<code>h :: t</code>, <code>(x, y)</code>)</td></tr>
<tr><td>여러 조건</td><td>중첩 필요</td><td>여러 절로 간결하게</td></tr>
<tr><td>가독성</td><td>복잡한 조건에서 낮음</td><td>높음</td></tr>
<tr><td>비소진 검사</td><td>없음</td><td>런타임 에러</td></tr>
</tbody>
</table>
</div>
<p><strong>If-Then-Else로 리스트 합계</strong>:</p>
<pre><code class="language-fsharp">let rec sum xs =
    if xs = [] then
        0
    else
        // head와 tail 추출이 어려움!
        ???
</code></pre>
<p>리스트를 분해하는 연산이 없으면 if-then-else로 구현하기 어렵다.</p>
<p><strong>Pattern Matching으로 리스트 합계</strong>:</p>
<pre><code class="language-fsharp">let rec sum xs =
    match xs with
    | [] -&gt; 0
    | h :: t -&gt; h + sum t
</code></pre>
<p>패턴 매칭은 구조 분해를 내장하므로 간결하다.</p>
<h2 id="정리-3"><a class="header" href="#정리-3">정리</a></h2>
<p>이 장에서 구현한 내용:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>구문</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td>Match 표현식</td><td><code>match e with | p1 -&gt; e1 | p2 -&gt; e2</code></td><td><code>match x with | 1 -&gt; "one" | _ -&gt; "other"</code></td></tr>
<tr><td>상수 패턴</td><td><code>1</code>, <code>true</code>, <code>false</code></td><td><code>| 0 -&gt; "zero"</code></td></tr>
<tr><td>변수 패턴</td><td><code>x</code></td><td><code>| n -&gt; n + 1</code></td></tr>
<tr><td>와일드카드 패턴</td><td><code>_</code></td><td><code>| _ -&gt; "default"</code></td></tr>
<tr><td>빈 리스트 패턴</td><td><code>[]</code></td><td><code>| [] -&gt; 0</code></td></tr>
<tr><td>Cons 패턴</td><td><code>h :: t</code></td><td><code>| h :: t -&gt; h + sum t</code></td></tr>
<tr><td>튜플 패턴</td><td><code>(x, y)</code></td><td><code>| (a, b) -&gt; a + b</code></td></tr>
</tbody>
</table>
</div>
<p><strong>파일별 변경 사항</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>파일</th><th>변경 사항</th></tr>
</thead>
<tbody>
<tr><td><code>Ast.fs</code></td><td><code>Match</code> 케이스, <code>Pattern</code> 타입 확장 (<code>ConsPat</code>, <code>EmptyListPat</code>, <code>ConstPat</code>), <code>MatchClause</code>, <code>Constant</code></td></tr>
<tr><td><code>Lexer.fsl</code></td><td><code>MATCH</code>, <code>WITH</code>, <code>PIPE</code> 토큰</td></tr>
<tr><td><code>Parser.fsy</code></td><td>Match 표현식 규칙, <code>MatchClauses</code> 비단말, <code>Pattern</code> 확장</td></tr>
<tr><td><code>Eval.fs</code></td><td><code>matchPattern</code> 함수 확장, <code>evalMatchClauses</code> 헬퍼 함수</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심 개념</strong>:</p>
<ul>
<li><strong>First-match 의미</strong>: 패턴은 위에서 아래로 순서대로 시도된다.</li>
<li><strong>구조 분해</strong>: 패턴은 값을 검사하면서 동시에 내부 구조를 변수에 바인딩한다.</li>
<li><strong>비소진 매칭</strong>: 모든 패턴이 실패하면 런타임 에러가 발생한다.</li>
</ul>
<p>패턴 매칭은 함수형 프로그래밍의 표현력을 크게 향상시키며, 특히 재귀적 자료구조(리스트)를 처리할 때 필수적이다.</p>
<h2 id="테스트-6"><a class="header" href="#테스트-6">테스트</a></h2>
<pre><code class="language-bash"># fslit 테스트
make -C tests

# Expecto 단위 테스트
dotnet run --project FunLang.Tests
</code></pre>
<h2 id="관련-문서-7"><a class="header" href="#관련-문서-7">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/write-fsyacc-parser.html">write-fsyacc-parser</a> - fsyacc 기본 문법</li>
<li><a href="../docs/howto/fsyacc-operator-precedence-methods.html">fsyacc-operator-precedence-methods</a> - 연산자 우선순위 처리 (<code>%right CONS</code> 재사용)</li>
</ul>
<h2 id="소스-참조"><a class="header" href="#소스-참조">소스 참조</a></h2>
<p>전체 소스 코드는 FunLang 디렉토리를 참조한다:</p>
<ul>
<li><code>FunLang/Ast.fs</code> - Match, Pattern, MatchClause, Constant 타입</li>
<li><code>FunLang/Lexer.fsl</code> - MATCH, WITH, PIPE 토큰</li>
<li><code>FunLang/Parser.fsy</code> - Match 표현식 및 패턴 문법</li>
<li><code>FunLang/Eval.fs</code> - matchPattern, evalMatchClauses 구현</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-9-prelude-standard-library"><a class="header" href="#chapter-9-prelude-standard-library">Chapter 9: Prelude (Standard Library)</a></h1>
<p>이 장에서는 FunLang의 표준 라이브러리(Prelude)를 구현한다. Prelude는 자주 사용되는 리스트 조작 함수와 유틸리티를 제공하며, <strong>FunLang 자체로 작성</strong>되어 언어의 표현력을 증명한다.</p>
<h2 id="개요-8"><a class="header" href="#개요-8">개요</a></h2>
<p>Prelude는 다음 기능을 제공한다:</p>
<ul>
<li><strong>고차 함수</strong>: <code>map</code>, <code>filter</code>, <code>fold</code> (리스트 처리의 핵심)</li>
<li><strong>리스트 유틸리티</strong>: <code>length</code>, <code>reverse</code>, <code>append</code></li>
<li><strong>리스트 접근</strong>: <code>hd</code>, <code>tl</code> (head, tail)</li>
<li><strong>Combinators</strong>: <code>id</code>, <code>const</code>, <code>compose</code> (함수 조합)</li>
</ul>
<p><strong>핵심 아이디어</strong>: Prelude는 FunLang으로 작성되고, 인터프리터 시작 시 자동으로 로드된다. 이를 <strong>self-hosted standard library</strong>라고 한다.</p>
<h2 id="구현-전략"><a class="header" href="#구현-전략">구현 전략</a></h2>
<p>Prelude 구현은 두 부분으로 나뉜다:</p>
<ol>
<li><strong>Prelude.fun</strong>: 표준 라이브러리 함수들을 FunLang으로 작성</li>
<li><strong>Prelude.fs</strong>: Prelude.fun을 파싱하고 환경에 로드하는 인프라</li>
</ol>
<h3 id="self-hosting의-장점"><a class="header" href="#self-hosting의-장점">Self-Hosting의 장점</a></h3>
<p>Prelude를 FunLang 자체로 작성하는 것은 여러 이점이 있다:</p>
<ul>
<li><strong>언어 능력 증명</strong>: FunLang이 충분히 표현력 있음을 보여줌</li>
<li><strong>일관성</strong>: 사용자 코드와 동일한 문법/의미론 사용</li>
<li><strong>유지보수성</strong>: 표준 라이브러리를 언어 자체로 확장 가능</li>
<li><strong>교육적 가치</strong>: 표준 라이브러리가 “마법“이 아니라 일반 코드임을 보여줌</li>
</ul>
<h2 id="preludefun-표준-라이브러리-소스"><a class="header" href="#preludefun-표준-라이브러리-소스">Prelude.fun: 표준 라이브러리 소스</a></h2>
<p><code>Prelude.fun</code> 파일은 FunLang으로 작성된 표준 라이브러리다. 중첩된 <code>let ... in</code> 구조로 함수들을 정의한다.</p>
<h3 id="고차-함수"><a class="header" href="#고차-함수">고차 함수</a></h3>
<h4 id="map-리스트-변환"><a class="header" href="#map-리스트-변환">map: 리스트 변환</a></h4>
<pre><code class="language-funlang">let rec map f = fun xs -&gt;
    match xs with
    | [] -&gt; []
    | h :: t -&gt; (f h) :: (map f t)
in
</code></pre>
<p><code>map</code>은 함수를 리스트의 각 요소에 적용하여 새 리스트를 생성한다.</p>
<ul>
<li>빈 리스트는 빈 리스트로 매핑</li>
<li>비어있지 않은 리스트는 head에 함수 적용 후 tail을 재귀적으로 매핑</li>
</ul>
<p><strong>타입</strong>: <code>('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</code></p>
<h4 id="filter-조건으로-필터링"><a class="header" href="#filter-조건으로-필터링">filter: 조건으로 필터링</a></h4>
<pre><code class="language-funlang">let rec filter pred = fun xs -&gt;
    match xs with
    | [] -&gt; []
    | h :: t -&gt; if pred h then h :: (filter pred t) else filter pred t
in
</code></pre>
<p><code>filter</code>는 조건을 만족하는 요소만 남긴다.</p>
<ul>
<li>빈 리스트는 빈 리스트 반환</li>
<li>head가 조건 만족 시 결과에 포함, 아니면 스킵</li>
</ul>
<p><strong>타입</strong>: <code>('a -&gt; bool) -&gt; 'a list -&gt; 'a list</code></p>
<h4 id="fold-리스트-누적"><a class="header" href="#fold-리스트-누적">fold: 리스트 누적</a></h4>
<pre><code class="language-funlang">let rec fold f = fun acc -&gt; fun xs -&gt;
    match xs with
    | [] -&gt; acc
    | h :: t -&gt; fold f (f acc h) t
in
</code></pre>
<p><code>fold</code>는 리스트를 왼쪽에서 오른쪽으로 순회하며 누적값을 계산한다 (left fold).</p>
<ul>
<li>빈 리스트는 누적값 반환</li>
<li>head와 누적값을 함수에 전달하여 새 누적값 생성</li>
</ul>
<p><strong>타입</strong>: <code>('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc -&gt; 'a list -&gt; 'acc</code></p>
<h3 id="리스트-유틸리티"><a class="header" href="#리스트-유틸리티">리스트 유틸리티</a></h3>
<h4 id="length-리스트-길이"><a class="header" href="#length-리스트-길이">length: 리스트 길이</a></h4>
<pre><code class="language-funlang">let rec length xs =
    match xs with
    | [] -&gt; 0
    | _ :: t -&gt; 1 + (length t)
in
</code></pre>
<p>재귀적으로 리스트를 순회하며 길이를 센다.</p>
<p><strong>타입</strong>: <code>'a list -&gt; int</code></p>
<h4 id="reverse-리스트-뒤집기"><a class="header" href="#reverse-리스트-뒤집기">reverse: 리스트 뒤집기</a></h4>
<pre><code class="language-funlang">let reverse = fun xs -&gt;
    let rec rev_acc acc = fun ys -&gt;
        match ys with
        | [] -&gt; acc
        | h :: t -&gt; rev_acc (h :: acc) t
    in
    rev_acc [] xs
in
</code></pre>
<p>누적 리스트를 사용하여 효율적으로 뒤집는다 (tail-recursive).</p>
<ul>
<li>내부 함수 <code>rev_acc</code>는 누적 리스트에 요소를 cons하며 순회</li>
<li><code>[1, 2, 3]</code> → <code>rev_acc [] [1,2,3]</code> → <code>rev_acc [1] [2,3]</code> → <code>rev_acc [2,1] [3]</code> → <code>[3,2,1]</code></li>
</ul>
<p><strong>타입</strong>: <code>'a list -&gt; 'a list</code></p>
<h4 id="append-리스트-연결"><a class="header" href="#append-리스트-연결">append: 리스트 연결</a></h4>
<pre><code class="language-funlang">let rec append xs = fun ys -&gt;
    match xs with
    | [] -&gt; ys
    | h :: t -&gt; h :: (append t ys)
in
</code></pre>
<p>두 리스트를 연결한다.</p>
<ul>
<li>첫 번째 리스트가 빈 리스트면 두 번째 리스트 반환</li>
<li>그렇지 않으면 첫 번째 리스트의 head를 cons하고 tail과 두 번째 리스트를 재귀적으로 연결</li>
</ul>
<p><strong>타입</strong>: <code>'a list -&gt; 'a list -&gt; 'a list</code></p>
<h3 id="리스트-접근"><a class="header" href="#리스트-접근">리스트 접근</a></h3>
<h4 id="hd-리스트의-첫-요소"><a class="header" href="#hd-리스트의-첫-요소">hd: 리스트의 첫 요소</a></h4>
<pre><code class="language-funlang">let hd = fun xs -&gt;
    match xs with
    | h :: _ -&gt; h
in
</code></pre>
<p>리스트의 head를 반환한다. 빈 리스트에 대해서는 매칭 실패 에러가 발생한다.</p>
<p><strong>타입</strong>: <code>'a list -&gt; 'a</code></p>
<h4 id="tl-리스트의-나머지"><a class="header" href="#tl-리스트의-나머지">tl: 리스트의 나머지</a></h4>
<pre><code class="language-funlang">let tl = fun xs -&gt;
    match xs with
    | _ :: t -&gt; t
in
</code></pre>
<p>리스트의 tail을 반환한다. 빈 리스트에 대해서는 매칭 실패 에러가 발생한다.</p>
<p><strong>타입</strong>: <code>'a list -&gt; 'a list</code></p>
<h3 id="combinators"><a class="header" href="#combinators">Combinators</a></h3>
<h4 id="id-항등-함수"><a class="header" href="#id-항등-함수">id: 항등 함수</a></h4>
<pre><code class="language-funlang">let id = fun x -&gt; x
in
</code></pre>
<p>입력을 그대로 반환한다.</p>
<p><strong>타입</strong>: <code>'a -&gt; 'a</code></p>
<h4 id="const-상수-함수"><a class="header" href="#const-상수-함수">const: 상수 함수</a></h4>
<pre><code class="language-funlang">let const = fun x -&gt; fun y -&gt; x
in
</code></pre>
<p>두 개의 인자를 받아 첫 번째 인자를 반환한다. 두 번째 인자는 무시된다.</p>
<p><strong>타입</strong>: <code>'a -&gt; 'b -&gt; 'a</code></p>
<h4 id="compose-함수-합성"><a class="header" href="#compose-함수-합성">compose: 함수 합성</a></h4>
<pre><code class="language-funlang">let compose = fun f -&gt; fun g -&gt; fun x -&gt; f (g x)
in
</code></pre>
<p>두 함수를 합성한다. <code>g</code>를 먼저 적용하고 그 결과에 <code>f</code>를 적용한다.</p>
<p><strong>타입</strong>: <code>('b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; ('a -&gt; 'c)</code></p>
<h3 id="구조"><a class="header" href="#구조">구조</a></h3>
<p><code>Prelude.fun</code>은 중첩된 <code>let ... in</code> 구조를 사용한다:</p>
<pre><code class="language-funlang">let map = ... in
let filter = ... in
let fold = ... in
...
let compose = ... in
0
</code></pre>
<p>마지막 표현식 <code>0</code>은 더미 값이다. Prelude 로딩 시 이 값은 버려지고 환경만 추출된다.</p>
<h2 id="preludefs-로딩-인프라"><a class="header" href="#preludefs-로딩-인프라">Prelude.fs: 로딩 인프라</a></h2>
<p><code>FunLang/Prelude.fs</code> 모듈은 <code>Prelude.fun</code>을 파싱하고 초기 환경에 로드한다.</p>
<h3 id="evaltoenv-환경-추출"><a class="header" href="#evaltoenv-환경-추출">evalToEnv: 환경 추출</a></h3>
<p><code>evalToEnv</code>는 중첩된 <code>let ... in</code> 구조를 순회하며 바인딩을 환경에 누적한다.</p>
<pre><code class="language-fsharp">let rec private evalToEnv (env: Env) (expr: Expr) : Env =
    match expr with
    | Let (name, binding, body) -&gt;
        let value = eval env binding
        let extendedEnv = Map.add name value env
        evalToEnv extendedEnv body
    | LetRec (name, param, funcBody, inExpr) -&gt;
        let funcVal = FunctionValue (param, funcBody, env)
        let extendedEnv = Map.add name funcVal env
        evalToEnv extendedEnv inExpr
    | _ -&gt;
        // Base case: return accumulated environment (final expr is discarded)
        env
</code></pre>
<p><strong>동작 방식</strong>:</p>
<ol>
<li><code>Let</code> 또는 <code>LetRec</code> 표현식을 만나면 바인딩을 평가</li>
<li>환경을 확장하고 body를 재귀적으로 처리</li>
<li>최종 표현식(예: <code>0</code>)을 만나면 누적된 환경을 반환</li>
</ol>
<p><strong>중요</strong>: 최종 표현식은 버려진다. 목표는 바인딩만 수집하는 것이다.</p>
<h3 id="loadprelude-파일-로딩"><a class="header" href="#loadprelude-파일-로딩">loadPrelude: 파일 로딩</a></h3>
<p><code>loadPrelude</code>는 <code>Prelude.fun</code>을 읽고 파싱하여 초기 환경을 생성한다.</p>
<pre><code class="language-fsharp">let loadPrelude () : Env =
    let preludePath = "Prelude.fun"
    if File.Exists preludePath then
        try
            let source = File.ReadAllText preludePath
            let ast = parse source
            evalToEnv emptyEnv ast
        with ex -&gt;
            eprintfn "Warning: Failed to load Prelude.fun: %s" ex.Message
            emptyEnv
    else
        eprintfn "Warning: Prelude.fun not found, starting with empty environment"
        emptyEnv
</code></pre>
<p><strong>Graceful Degradation</strong>: 파일이 없거나 파싱 실패 시 빈 환경을 반환한다. 인터프리터는 Prelude 없이도 동작한다.</p>
<h3 id="repl-통합"><a class="header" href="#repl-통합">REPL 통합</a></h3>
<p><code>Repl.fs</code>의 <code>startRepl</code> 함수는 Prelude를 로드하여 초기 환경으로 사용한다.</p>
<pre><code class="language-fsharp">let startRepl () : int =
    printfn "FunLang REPL"
    printfn "Type '#quit' or Ctrl+D to quit."
    printfn ""
    let initialEnv = Prelude.loadPrelude()
    replLoop initialEnv
    0
</code></pre>
<p>REPL 시작 시 Prelude의 모든 함수가 사용 가능하다.</p>
<h3 id="cli-통합"><a class="header" href="#cli-통합">CLI 통합</a></h3>
<p><code>Program.fs</code>도 <code>--expr</code>과 파일 실행 모드에서 Prelude를 로드한다.</p>
<pre><code class="language-fsharp">// Load prelude for evaluation modes
let initialEnv = Prelude.loadPrelude()

// --expr only
elif results.Contains Expr then
    let expr = results.GetResult Expr
    try
        let result = eval initialEnv (parse expr)
        printfn "%s" (formatValue result)
        0
    with ex -&gt;
        eprintfn "Error: %s" ex.Message
        1
</code></pre>
<p>CLI에서도 Prelude 함수를 바로 사용할 수 있다.</p>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<h3 id="map-리스트-변환-1"><a class="header" href="#map-리스트-변환-1">map: 리스트 변환</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'map (fun x -&gt; x * 2) [1, 2, 3]'
[2, 4, 6]

$ dotnet run --project FunLang -- -e 'let double = fun x -&gt; x * 2 in map double [1, 2, 3, 4, 5]'
[2, 4, 6, 8, 10]
</code></pre>
<p><code>map</code>은 리스트의 각 요소에 함수를 적용한다.</p>
<h3 id="filter-조건-필터링"><a class="header" href="#filter-조건-필터링">filter: 조건 필터링</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'filter (fun x -&gt; x &gt; 1) [1, 2, 3]'
[2, 3]

$ dotnet run --project FunLang -- -e 'filter (fun x -&gt; x &gt; 0) [1, -2, 3, -4, 5]'
[1, 3, 5]
</code></pre>
<p><code>filter</code>는 조건을 만족하는 요소만 남긴다.</p>
<h3 id="fold-리스트-누적-1"><a class="header" href="#fold-리스트-누적-1">fold: 리스트 누적</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'fold (fun a -&gt; fun b -&gt; a + b) 0 [1, 2, 3]'
6

$ dotnet run --project FunLang -- -e 'fold (fun a -&gt; fun b -&gt; a * b) 1 [1, 2, 3, 4]'
24
</code></pre>
<p><code>fold</code>는 리스트를 순회하며 값을 누적한다. 첫 번째 예시는 합계(sum), 두 번째는 곱(product).</p>
<h3 id="length-리스트-길이-1"><a class="header" href="#length-리스트-길이-1">length: 리스트 길이</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'length [1, 2, 3]'
3

$ dotnet run --project FunLang -- -e 'length []'
0
</code></pre>
<h3 id="reverse-리스트-뒤집기-1"><a class="header" href="#reverse-리스트-뒤집기-1">reverse: 리스트 뒤집기</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'reverse [1, 2, 3]'
[3, 2, 1]

$ dotnet run --project FunLang -- -e 'reverse [[1, 2], [3, 4]]'
[[3, 4], [1, 2]]
</code></pre>
<h3 id="append-리스트-연결-1"><a class="header" href="#append-리스트-연결-1">append: 리스트 연결</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'append [1, 2] [3, 4]'
[1, 2, 3, 4]

$ dotnet run --project FunLang -- -e 'append [] [1, 2, 3]'
[1, 2, 3]
</code></pre>
<h3 id="hd와-tl-리스트-분해"><a class="header" href="#hd와-tl-리스트-분해">hd와 tl: 리스트 분해</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'hd [1, 2, 3]'
1

$ dotnet run --project FunLang -- -e 'tl [1, 2, 3]'
[2, 3]
</code></pre>
<p>빈 리스트에 대해서는 매칭 실패 에러가 발생한다:</p>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'hd []'
Error: Match failure: no pattern matched
</code></pre>
<h3 id="combinators-1"><a class="header" href="#combinators-1">Combinators</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'id 42'
42

$ dotnet run --project FunLang -- -e 'const 1 2'
1

$ dotnet run --project FunLang -- -e 'let f = fun x -&gt; x * 2 in let g = fun x -&gt; x + 1 in (compose f g) 5'
12
</code></pre>
<p><code>compose f g</code>는 <code>f (g x)</code>를 의미한다. <code>(compose f g) 5</code> = <code>f (g 5)</code> = <code>f 6</code> = <code>12</code>.</p>
<h3 id="함수-조합"><a class="header" href="#함수-조합">함수 조합</a></h3>
<p>고차 함수를 조합하여 복잡한 연산을 표현할 수 있다:</p>
<pre><code class="language-bash">$ dotnet run --project FunLang -- -e 'map (fun x -&gt; x * 2) (filter (fun x -&gt; x &gt; 1) [1, 2, 3, 4])'
[4, 6, 8]

$ dotnet run --project FunLang -- -e 'fold (fun a -&gt; fun b -&gt; a + b) 0 (map (fun x -&gt; x * x) [1, 2, 3, 4])'
30
</code></pre>
<p>두 번째 예시는 <code>[1, 2, 3, 4]</code>를 제곱하고(<code>[1, 4, 9, 16]</code>) 합계를 계산한다(<code>1 + 4 + 9 + 16 = 30</code>).</p>
<h2 id="repl에서-사용"><a class="header" href="#repl에서-사용">REPL에서 사용</a></h2>
<p>REPL을 시작하면 Prelude가 자동으로 로드되어 모든 함수를 사용할 수 있다:</p>
<pre><code class="language-bash">$ dotnet run --project FunLang
FunLang REPL
Type '#quit' or Ctrl+D to quit.

funlang&gt; map (fun x -&gt; x * 2) [1, 2, 3]
[2, 4, 6]
funlang&gt; length [1, 2, 3, 4, 5]
5
funlang&gt; reverse [1, 2, 3]
[3, 2, 1]
</code></pre>
<h2 id="구현-세부-사항"><a class="header" href="#구현-세부-사항">구현 세부 사항</a></h2>
<h3 id="evaltoenv의-필요성"><a class="header" href="#evaltoenv의-필요성">evalToEnv의 필요성</a></h3>
<p>일반적인 <code>eval</code>은 표현식의 <strong>값</strong>을 반환한다. 그러나 Prelude는 <strong>바인딩 집합</strong>을 추출해야 한다.</p>
<p><code>evalToEnv</code>는 다음과 같이 동작한다:</p>
<pre><code>let map = ... in                 → env' = env + {map = &lt;func&gt;}
let filter = ... in              → env'' = env' + {filter = &lt;func&gt;}
...
0                                → env''를 반환 (0은 버림)
</code></pre>
<p>각 <code>let</code>을 만날 때마다 환경을 확장하고, 최종적으로 모든 바인딩을 포함한 환경을 반환한다.</p>
<h3 id="클로저와-재귀"><a class="header" href="#클로저와-재귀">클로저와 재귀</a></h3>
<p><code>let rec</code> 함수는 클로저를 생성할 때 <strong>자기 자신을 참조할 수 있어야</strong> 한다.</p>
<pre><code class="language-fsharp">| LetRec (name, param, funcBody, inExpr) -&gt;
    let funcVal = FunctionValue (param, funcBody, env)
    let extendedEnv = Map.add name funcVal env
    evalToEnv extendedEnv inExpr
</code></pre>
<p><code>FunctionValue</code>의 클로저 환경은 현재 환경(<code>env</code>)이다. 그러나 <code>extendedEnv</code>에 함수 자신을 추가하므로, 함수 본문 평가 시 재귀 호출이 가능하다.</p>
<h3 id="파일-경로"><a class="header" href="#파일-경로">파일 경로</a></h3>
<p><code>loadPrelude</code>는 현재 작업 디렉토리에서 <code>Prelude.fun</code>을 찾는다. 인터프리터는 프로젝트 루트에서 실행되므로 파일이 올바르게 로드된다.</p>
<h3 id="에러-처리"><a class="header" href="#에러-처리">에러 처리</a></h3>
<p>Prelude 로딩 실패는 치명적이지 않다. 경고만 출력하고 빈 환경을 반환한다. 이는 다음과 같은 상황에 유용하다:</p>
<ul>
<li>개발 중 Prelude.fun이 아직 없을 때</li>
<li>Prelude에 문법 에러가 있을 때</li>
<li>테스트 환경에서 Prelude 없이 실행할 때</li>
</ul>
<h2 id="정리-4"><a class="header" href="#정리-4">정리</a></h2>
<p>이 장에서 구현한 내용:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>파일</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>표준 라이브러리 소스</td><td><code>Prelude.fun</code></td><td>FunLang으로 작성된 11개 함수</td></tr>
<tr><td>환경 추출</td><td><code>Prelude.fs::evalToEnv</code></td><td>중첩 let 바인딩을 환경으로 변환</td></tr>
<tr><td>자동 로딩</td><td><code>Prelude.fs::loadPrelude</code></td><td>시작 시 Prelude.fun 파싱 및 로드</td></tr>
<tr><td>REPL 통합</td><td><code>Repl.fs::startRepl</code></td><td>Prelude 환경으로 REPL 시작</td></tr>
<tr><td>CLI 통합</td><td><code>Program.fs::main</code></td><td>평가 모드에서 Prelude 사용</td></tr>
</tbody>
</table>
</div>
<p><strong>Self-Hosted Standard Library의 의미</strong>:</p>
<p>Prelude를 FunLang 자체로 작성함으로써, 언어가 자기 자신의 표준 라이브러리를 표현할 수 있을 만큼 강력하다는 것을 증명했다. 이는 Turing-complete 언어의 핵심 특징이다.</p>
<p><strong>제공되는 함수들</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>카테고리</th><th>함수</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>고차 함수</td><td><code>map</code>, <code>filter</code>, <code>fold</code></td><td>리스트 변환, 필터링, 누적</td></tr>
<tr><td>리스트 유틸리티</td><td><code>length</code>, <code>reverse</code>, <code>append</code></td><td>길이, 뒤집기, 연결</td></tr>
<tr><td>리스트 접근</td><td><code>hd</code>, <code>tl</code></td><td>Head, tail</td></tr>
<tr><td>Combinators</td><td><code>id</code>, <code>const</code>, <code>compose</code></td><td>항등, 상수, 합성</td></tr>
</tbody>
</table>
</div>
<h2 id="테스트-7"><a class="header" href="#테스트-7">테스트</a></h2>
<pre><code class="language-bash"># fslit 통합 테스트
make -C tests

# Expecto 단위 테스트
dotnet run --project FunLang.Tests
</code></pre>
<p>Prelude 함수는 <code>tests/prelude/</code> 디렉토리의 fslit 테스트로 검증된다.</p>
<h2 id="소스-참조-1"><a class="header" href="#소스-참조-1">소스 참조</a></h2>
<p>전체 소스 코드는 다음 위치에서 확인할 수 있다:</p>
<ul>
<li><strong>Prelude.fun</strong>: 표준 라이브러리 소스 (프로젝트 루트)</li>
<li><strong>FunLang/Prelude.fs</strong>: 로딩 인프라 (<code>evalToEnv</code>, <code>loadPrelude</code>)</li>
<li><strong>FunLang/Repl.fs</strong>: REPL 통합 (<code>startRepl</code>)</li>
<li><strong>FunLang/Program.fs</strong>: CLI 통합 (main 함수)</li>
</ul>
<h2 id="관련-문서-8"><a class="header" href="#관련-문서-8">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/write-fsharp-repl-loop.html">write-fsharp-repl-loop</a> - REPL 구현 패턴</li>
<li><a href="../docs/howto/setup-argu-cli.html">setup-argu-cli</a> - Argu CLI 설정</li>
<li><a href="../docs/howto/testing-strategies.html">testing-strategies</a> - 테스트 전략 (fslit, Expecto)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-10-type-system-hindley-milner"><a class="header" href="#chapter-10-type-system-hindley-milner">Chapter 10: Type System (Hindley-Milner)</a></h1>
<p>이 장에서는 FunLang에 <strong>Hindley-Milner 타입 추론 시스템</strong>을 구현한다. 명시적 타입 주석 없이도 모든 표현식의 타입을 자동으로 추론하여, 실행 전에 타입 오류를 발견할 수 있다.</p>
<h2 id="개요-9"><a class="header" href="#개요-9">개요</a></h2>
<p>타입 시스템은 다음 기능을 제공한다:</p>
<ul>
<li><strong>타입 추론</strong>: 명시적 주석 없이 타입 자동 유추</li>
<li><strong>다형성</strong>: <code>let id = fun x -&gt; x</code>가 <code>forall 'a. 'a -&gt; 'a</code> 타입을 갖음</li>
<li><strong>정적 검사</strong>: 실행 전에 <code>1 + true</code> 같은 오류 발견</li>
<li><strong>CLI 통합</strong>: <code>--emit-type</code> 플래그로 타입 표시</li>
</ul>
<p><strong>핵심 아이디어</strong>: Algorithm W를 사용하여 AST를 순회하며 타입 변수와 제약을 수집하고, 단일화(unification)로 해를 구한다.</p>
<h2 id="구현-전략-1"><a class="header" href="#구현-전략-1">구현 전략</a></h2>
<p>타입 시스템은 4단계로 구현된다:</p>
<ol>
<li><strong>Type.fs</strong>: 타입 AST, Scheme, Substitution 연산</li>
<li><strong>Unify.fs</strong>: 단일화 알고리즘과 occurs check</li>
<li><strong>Infer.fs</strong>: Algorithm W 타입 추론</li>
<li><strong>TypeCheck.fs</strong>: Prelude 타입 정의와 CLI 통합</li>
</ol>
<h3 id="왜-hindley-milner인가"><a class="header" href="#왜-hindley-milner인가">왜 Hindley-Milner인가?</a></h3>
<p>Hindley-Milner는 ML 계열 언어(OCaml, F#, Haskell)의 기반이다:</p>
<ul>
<li><strong>완전한 추론</strong>: 타입 주석 없이도 항상 가장 일반적인 타입을 찾음</li>
<li><strong>Let-polymorphism</strong>: <code>let</code> 바인딩에서 다형성 지원</li>
<li><strong>결정 가능성</strong>: 추론이 항상 종료되고 결과가 유일함</li>
</ul>
<h2 id="typefs-타입-정의"><a class="header" href="#typefs-타입-정의">Type.fs: 타입 정의</a></h2>
<p><code>FunLang/Type.fs</code>는 타입 시스템의 기초를 정의한다.</p>
<h3 id="타입-ast"><a class="header" href="#타입-ast">타입 AST</a></h3>
<pre><code class="language-fsharp">type Type =
    | TInt                        // int
    | TBool                       // bool
    | TString                     // string
    | TVar of int                 // 타입 변수 'a, 'b, ... (정수로 구분)
    | TArrow of Type * Type       // 함수 타입 'a -&gt; 'b
    | TTuple of Type list         // 튜플 타입 'a * 'b
    | TList of Type               // 리스트 타입 'a list
</code></pre>
<p><strong>설계 결정</strong>:</p>
<ul>
<li><code>TVar of int</code>: 문자열 대신 정수 사용. 비교/해싱이 빠르고 fresh 변수 생성이 단순</li>
<li>7개 타입 생성자로 FunLang의 모든 값 표현</li>
</ul>
<h3 id="scheme-다형성-지원"><a class="header" href="#scheme-다형성-지원">Scheme: 다형성 지원</a></h3>
<pre><code class="language-fsharp">type Scheme = Scheme of vars: int list * ty: Type
</code></pre>
<p>Scheme은 <code>forall</code> 변수 리스트와 타입을 포함한다:</p>
<ul>
<li><code>id: forall 'a. 'a -&gt; 'a</code> → <code>Scheme([0], TArrow(TVar 0, TVar 0))</code></li>
<li><code>const: forall 'a 'b. 'a -&gt; 'b -&gt; 'a</code> → <code>Scheme([0; 1], TArrow(TVar 0, TArrow(TVar 1, TVar 0)))</code></li>
</ul>
<h3 id="타입-환경과-대체"><a class="header" href="#타입-환경과-대체">타입 환경과 대체</a></h3>
<pre><code class="language-fsharp">type TypeEnv = Map&lt;string, Scheme&gt;
type Subst = Map&lt;int, Type&gt;
</code></pre>
<ul>
<li><strong>TypeEnv</strong>: 변수 이름을 Scheme에 매핑</li>
<li><strong>Subst</strong>: 타입 변수를 구체 타입에 매핑</li>
</ul>
<h3 id="formattype-타입-출력"><a class="header" href="#formattype-타입-출력">formatType: 타입 출력</a></h3>
<pre><code class="language-fsharp">let rec formatType = function
    | TInt -&gt; "int"
    | TBool -&gt; "bool"
    | TString -&gt; "string"
    | TVar n -&gt; sprintf "'%c" (char (97 + n % 26))  // 'a, 'b, ...
    | TArrow (t1, t2) -&gt;
        let left = match t1 with TArrow _ -&gt; sprintf "(%s)" (formatType t1) | _ -&gt; formatType t1
        sprintf "%s -&gt; %s" left (formatType t2)
    | TTuple ts -&gt; ts |&gt; List.map formatType |&gt; String.concat " * "
    | TList t -&gt; sprintf "%s list" (formatType t)
</code></pre>
<p>Arrow 타입의 왼쪽 피연산자만 괄호로 감싼다 (오른쪽 결합).</p>
<h3 id="substitution-연산"><a class="header" href="#substitution-연산">Substitution 연산</a></h3>
<p><strong>apply</strong>: 타입에 대체 적용</p>
<pre><code class="language-fsharp">let rec apply (s: Subst) = function
    | TInt -&gt; TInt
    | TBool -&gt; TBool
    | TString -&gt; TString
    | TVar n -&gt;
        match Map.tryFind n s with
        | Some t -&gt; apply s t  // 재귀! transitive chain 처리
        | None -&gt; TVar n
    | TArrow (t1, t2) -&gt; TArrow (apply s t1, apply s t2)
    | TTuple ts -&gt; TTuple (List.map (apply s) ts)
    | TList t -&gt; TList (apply s t)
</code></pre>
<p><strong>중요</strong>: <code>TVar</code> 케이스에서 <code>apply s t</code>를 재귀 호출한다. <code>{0→TVar 1, 1→TInt}</code>를 <code>TVar 0</code>에 적용하면 <code>TInt</code>가 된다.</p>
<p><strong>compose</strong>: 대체 합성</p>
<pre><code class="language-fsharp">let compose (s2: Subst) (s1: Subst): Subst =
    let s1' = Map.map (fun _ t -&gt; apply s2 t) s1
    Map.fold (fun acc k v -&gt; Map.add k v acc) s1' s2
</code></pre>
<p><code>compose s2 s1</code>은 “s1 먼저, 그 다음 s2” 순서다.</p>
<h3 id="free-variables"><a class="header" href="#free-variables">Free Variables</a></h3>
<pre><code class="language-fsharp">let rec freeVars = function
    | TInt | TBool | TString -&gt; Set.empty
    | TVar n -&gt; Set.singleton n
    | TArrow (t1, t2) -&gt; Set.union (freeVars t1) (freeVars t2)
    | TTuple ts -&gt; ts |&gt; List.map freeVars |&gt; Set.unionMany
    | TList t -&gt; freeVars t

let freeVarsScheme (Scheme (vars, ty)) =
    Set.difference (freeVars ty) (Set.ofList vars)

let freeVarsEnv (env: TypeEnv) =
    env |&gt; Map.values |&gt; Seq.map freeVarsScheme |&gt; Set.unionMany
</code></pre>
<p>Scheme의 free variable은 bound variable을 제외한다.</p>
<h2 id="unifyfs-단일화-알고리즘"><a class="header" href="#unifyfs-단일화-알고리즘">Unify.fs: 단일화 알고리즘</a></h2>
<p><code>FunLang/Unify.fs</code>는 Robinson의 단일화 알고리즘을 구현한다.</p>
<h3 id="occurs-check"><a class="header" href="#occurs-check">Occurs Check</a></h3>
<pre><code class="language-fsharp">exception TypeError of string

let occurs (v: int) (t: Type): bool =
    Set.contains v (freeVars t)
</code></pre>
<p>Occurs check는 무한 타입을 방지한다. <code>'a = 'a -&gt; int</code>는 불가능하다.</p>
<h3 id="unify-함수"><a class="header" href="#unify-함수">unify 함수</a></h3>
<pre><code class="language-fsharp">let rec unify (t1: Type) (t2: Type): Subst =
    match t1, t2 with
    | TInt, TInt -&gt; empty
    | TBool, TBool -&gt; empty
    | TString, TString -&gt; empty

    // 대칭 패턴: TVar는 양쪽 모두 처리
    | TVar n, t | t, TVar n -&gt;
        if t = TVar n then empty
        elif occurs n t then
            raise (TypeError (sprintf "Infinite type: %s = %s"
                (formatType (TVar n)) (formatType t)))
        else
            singleton n t

    // Arrow: 도메인 단일화 → 결과 적용 → 치역 단일화
    | TArrow (a1, b1), TArrow (a2, b2) -&gt;
        let s1 = unify a1 a2
        let s2 = unify (apply s1 b1) (apply s1 b2)
        compose s2 s1

    | TTuple ts1, TTuple ts2 when List.length ts1 = List.length ts2 -&gt;
        List.fold2 (fun s t1 t2 -&gt;
            let s' = unify (apply s t1) (apply s t2)
            compose s' s
        ) empty ts1 ts2

    | TList t1, TList t2 -&gt;
        unify t1 t2

    | _ -&gt;
        raise (TypeError (sprintf "Cannot unify %s with %s"
            (formatType t1) (formatType t2)))
</code></pre>
<p><strong>핵심 포인트</strong>:</p>
<ul>
<li><code>| TVar n, t | t, TVar n -&gt;</code>: 대칭 패턴으로 양방향 처리</li>
<li>Arrow 단일화에서 <code>apply s1 b1</code>: substitution threading</li>
<li>Tuple은 길이가 같아야 하고 각 요소를 순차 단일화</li>
</ul>
<h2 id="inferfs-algorithm-w"><a class="header" href="#inferfs-algorithm-w">Infer.fs: Algorithm W</a></h2>
<p><code>FunLang/Infer.fs</code>는 완전한 타입 추론을 구현한다.</p>
<h3 id="freshvar-새-타입-변수-생성"><a class="header" href="#freshvar-새-타입-변수-생성">freshVar: 새 타입 변수 생성</a></h3>
<pre><code class="language-fsharp">let freshVar =
    let counter = ref 1000  // 0-999는 Prelude용 예약
    fun () -&gt;
        let n = !counter
        counter := n + 1
        TVar n
</code></pre>
<p><strong>중요</strong>: 1000부터 시작하여 Prelude scheme의 bound variable(0-9)과 충돌 방지.</p>
<h3 id="instantiate-scheme-인스턴스화"><a class="header" href="#instantiate-scheme-인스턴스화">instantiate: Scheme 인스턴스화</a></h3>
<pre><code class="language-fsharp">let instantiate (Scheme (vars, ty)): Type =
    match vars with
    | [] -&gt; ty  // Monomorphic - 그대로 반환
    | _ -&gt;
        let freshVars = List.map (fun _ -&gt; freshVar()) vars
        let subst = List.zip vars freshVars |&gt; Map.ofList
        apply subst ty
</code></pre>
<p><code>forall 'a. 'a -&gt; 'a</code>를 인스턴스화하면 <code>'x -&gt; 'x</code> (fresh ’x).</p>
<h3 id="generalize-타입-일반화"><a class="header" href="#generalize-타입-일반화">generalize: 타입 일반화</a></h3>
<pre><code class="language-fsharp">let generalize (env: TypeEnv) (ty: Type): Scheme =
    let envFree = freeVarsEnv env
    let tyFree = freeVars ty
    let vars = Set.difference tyFree envFree |&gt; Set.toList
    Scheme (vars, ty)
</code></pre>
<p>환경에 없는 free variable을 <code>forall</code>로 감싼다.</p>
<h3 id="infer-함수-algorithm-w-핵심"><a class="header" href="#infer-함수-algorithm-w-핵심">infer 함수: Algorithm W 핵심</a></h3>
<pre><code class="language-fsharp">let rec infer (env: TypeEnv) (expr: Expr): Subst * Type =
    match expr with
    // Literals
    | Number _ -&gt; (empty, TInt)
    | Bool _ -&gt; (empty, TBool)
    | String _ -&gt; (empty, TString)

    // Variable
    | Var name -&gt;
        match Map.tryFind name env with
        | Some scheme -&gt; (empty, instantiate scheme)
        | None -&gt; raise (TypeError (sprintf "Unbound variable: %s" name))

    // Lambda
    | Lambda (param, body) -&gt;
        let paramTy = freshVar()
        let bodyEnv = Map.add param (Scheme ([], paramTy)) env
        let s, bodyTy = infer bodyEnv body
        (s, TArrow (apply s paramTy, bodyTy))

    // Application
    | App (func, arg) -&gt;
        let s1, funcTy = infer env func
        let s2, argTy = infer (applyEnv s1 env) arg
        let resultTy = freshVar()
        let s3 = unify (apply s2 funcTy) (TArrow (argTy, resultTy))
        (compose s3 (compose s2 s1), apply s3 resultTy)

    // Let with polymorphism
    | Let (name, value, body) -&gt;
        let s1, valueTy = infer env value
        let env' = applyEnv s1 env
        let scheme = generalize env' (apply s1 valueTy)
        let bodyEnv = Map.add name scheme env'
        let s2, bodyTy = infer bodyEnv body
        (compose s2 s1, bodyTy)

    // ... If, LetRec, Tuple, List, Match, etc.
</code></pre>
<p><strong>핵심 패턴</strong>:</p>
<ol>
<li><code>infer</code>는 <code>(Subst, Type)</code> 튜플 반환</li>
<li>매 단계에서 이전 substitution을 환경에 적용: <code>applyEnv s1 env</code></li>
<li>Let에서 <code>generalize</code> 호출 → let-polymorphism</li>
<li>Lambda param은 <code>Scheme([], ty)</code> → monomorphic</li>
</ol>
<h3 id="let-polymorphism-vs-lambda-monomorphism"><a class="header" href="#let-polymorphism-vs-lambda-monomorphism">Let-Polymorphism vs Lambda Monomorphism</a></h3>
<p><strong>Let은 다형성을 허용</strong>:</p>
<pre><code class="language-funlang">let id = fun x -&gt; x in (id 5, id true)
// id: forall 'a. 'a -&gt; 'a
// 첫 번째 사용: 'a = int
// 두 번째 사용: 'a = bool
// 결과: (int, bool) ✓
</code></pre>
<p><strong>Lambda parameter는 monomorphic</strong>:</p>
<pre><code class="language-funlang">fun f -&gt; (f 1, f true)
// f는 한 타입으로 고정
// f: int -&gt; 'a 또는 f: bool -&gt; 'a 둘 중 하나만 가능
// 타입 오류!
</code></pre>
<h2 id="typecheckfs-통합"><a class="header" href="#typecheckfs-통합">TypeCheck.fs: 통합</a></h2>
<p><code>FunLang/TypeCheck.fs</code>는 Prelude 타입과 typecheck 함수를 제공한다.</p>
<h3 id="initialtypeenv-prelude-함수-타입"><a class="header" href="#initialtypeenv-prelude-함수-타입">initialTypeEnv: Prelude 함수 타입</a></h3>
<pre><code class="language-fsharp">let initialTypeEnv: TypeEnv =
    Map.ofList [
        // map: ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
        "map", Scheme([0; 1], TArrow(TArrow(TVar 0, TVar 1), TArrow(TList(TVar 0), TList(TVar 1))))

        // filter: ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
        "filter", Scheme([0], TArrow(TArrow(TVar 0, TBool), TArrow(TList(TVar 0), TList(TVar 0))))

        // fold: ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b
        "fold", Scheme([0; 1], TArrow(TArrow(TVar 1, TArrow(TVar 0, TVar 1)), TArrow(TVar 1, TArrow(TList(TVar 0), TVar 1))))

        // id: 'a -&gt; 'a
        "id", Scheme([0], TArrow(TVar 0, TVar 0))

        // ... length, reverse, append, const, compose, hd, tl
    ]
</code></pre>
<h3 id="typecheck-함수"><a class="header" href="#typecheck-함수">typecheck 함수</a></h3>
<pre><code class="language-fsharp">let typecheck (expr: Expr): Result&lt;Type, string&gt; =
    try
        let subst, ty = infer initialTypeEnv expr
        Ok(apply subst ty)
    with
    | TypeError msg -&gt; Error(msg)
</code></pre>
<h3 id="cli-통합-1"><a class="header" href="#cli-통합-1">CLI 통합</a></h3>
<p><code>Program.fs</code>에서 <code>--emit-type</code> 플래그 처리:</p>
<pre><code class="language-fsharp">| EmitType -&gt;
    let source = results.GetResult Expr
    let ast = parse source
    match typecheck ast with
    | Ok ty -&gt; printfn "%s" (formatType ty)
    | Error msg -&gt; eprintfn "Error: %s" msg; exit 1
</code></pre>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<h3 id="리터럴-타입-추론"><a class="header" href="#리터럴-타입-추론">리터럴 타입 추론</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e '42'
int

$ dotnet run --project FunLang -- --emit-type -e 'true'
bool

$ dotnet run --project FunLang -- --emit-type -e '"hello"'
string
</code></pre>
<h3 id="함수-타입-추론"><a class="header" href="#함수-타입-추론">함수 타입 추론</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'fun x -&gt; x'
'm -&gt; 'm

$ dotnet run --project FunLang -- --emit-type -e 'fun x -&gt; x + 1'
int -&gt; int

$ dotnet run --project FunLang -- --emit-type -e 'fun x -&gt; fun y -&gt; x + y'
int -&gt; int -&gt; int
</code></pre>
<h3 id="let-polymorphism"><a class="header" href="#let-polymorphism">Let-Polymorphism</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'let id = fun x -&gt; x in (id 5, id true)'
int * bool

$ dotnet run --project FunLang -- --emit-type -e 'let id = fun x -&gt; x in id'
'm -&gt; 'm
</code></pre>
<h3 id="리스트와-튜플"><a class="header" href="#리스트와-튜플">리스트와 튜플</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e '[1, 2, 3]'
int list

$ dotnet run --project FunLang -- --emit-type -e '[]'
'm list

$ dotnet run --project FunLang -- --emit-type -e '(1, true, "hello")'
int * bool * string
</code></pre>
<h3 id="prelude-함수-타입"><a class="header" href="#prelude-함수-타입">Prelude 함수 타입</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'map'
('m -&gt; 'n) -&gt; 'm list -&gt; 'n list

$ dotnet run --project FunLang -- --emit-type -e 'filter'
('m -&gt; bool) -&gt; 'm list -&gt; 'm list

$ dotnet run --project FunLang -- --emit-type -e 'map (fun x -&gt; x + 1)'
int list -&gt; int list
</code></pre>
<h3 id="타입-오류"><a class="header" href="#타입-오류">타입 오류</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e '1 + true'
Error: Cannot unify int with bool

$ dotnet run --project FunLang -- --emit-type -e 'if true then 1 else false'
Error: Cannot unify int with bool

$ dotnet run --project FunLang -- --emit-type -e 'let rec f x = f in f'
Error: Infinite type: 'm = 'm -&gt; 'n
</code></pre>
<h3 id="재귀-함수-타입"><a class="header" href="#재귀-함수-타입">재귀 함수 타입</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'let rec fact n = if n &lt;= 1 then 1 else n * fact (n - 1) in fact'
int -&gt; int
</code></pre>
<h2 id="구현-세부-사항-1"><a class="header" href="#구현-세부-사항-1">구현 세부 사항</a></h2>
<h3 id="substitution-threading"><a class="header" href="#substitution-threading">Substitution Threading</a></h3>
<p>매 추론 단계에서 이전 substitution을 다음 단계에 전파해야 한다:</p>
<pre><code class="language-fsharp">| App (func, arg) -&gt;
    let s1, funcTy = infer env func
    let s2, argTy = infer (applyEnv s1 env) arg  // ← s1 적용
    let s3 = unify (apply s2 funcTy) (TArrow (argTy, resultTy))
    (compose s3 (compose s2 s1), apply s3 resultTy)
</code></pre>
<h3 id="type-variable-충돌-방지"><a class="header" href="#type-variable-충돌-방지">Type Variable 충돌 방지</a></h3>
<p>Prelude scheme은 0-9 범위의 bound variable을 사용하고, <code>freshVar</code>는 1000부터 시작한다:</p>
<pre><code class="language-fsharp">// Prelude: Scheme([0; 1], TArrow(TVar 0, TVar 1))
// Fresh: TVar 1000, TVar 1001, ...
</code></pre>
<h3 id="generalize-타이밍"><a class="header" href="#generalize-타이밍">Generalize 타이밍</a></h3>
<p>Let에서 value 추론 후, substitution을 환경에 적용한 다음 generalize해야 한다:</p>
<pre><code class="language-fsharp">| Let (name, value, body) -&gt;
    let s1, valueTy = infer env value
    let env' = applyEnv s1 env          // 먼저 적용
    let scheme = generalize env' (apply s1 valueTy)  // 그 다음 generalize
</code></pre>
<h2 id="정리-5"><a class="header" href="#정리-5">정리</a></h2>
<p>이 장에서 구현한 내용:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>파일</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>타입 AST</td><td><code>Type.fs</code></td><td>7개 타입 생성자 (TInt, TBool, TString, TVar, TArrow, TTuple, TList)</td></tr>
<tr><td>Substitution</td><td><code>Type.fs</code></td><td>apply, compose, freeVars</td></tr>
<tr><td>단일화</td><td><code>Unify.fs</code></td><td>occurs check, unify</td></tr>
<tr><td>타입 추론</td><td><code>Infer.fs</code></td><td>Algorithm W (freshVar, instantiate, generalize, infer)</td></tr>
<tr><td>통합</td><td><code>TypeCheck.fs</code></td><td>initialTypeEnv, typecheck</td></tr>
<tr><td>CLI</td><td><code>Program.fs</code></td><td>–emit-type 플래그</td></tr>
</tbody>
</table>
</div>
<p><strong>Hindley-Milner의 특징</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>완전한 추론</td><td>타입 주석 없이 가장 일반적인 타입 유추</td></tr>
<tr><td>Let-polymorphism</td><td>let 바인딩에서 다형성 지원</td></tr>
<tr><td>결정 가능성</td><td>항상 종료, 유일한 principal type</td></tr>
<tr><td>Occurs check</td><td>무한 타입 방지</td></tr>
</tbody>
</table>
</div>
<h2 id="테스트-8"><a class="header" href="#테스트-8">테스트</a></h2>
<pre><code class="language-bash"># fslit 통합 테스트
make -C tests type-inference
make -C tests type-errors

# Expecto 단위 테스트
dotnet run --project FunLang.Tests

# 전체 테스트 (460개)
make -C tests &amp;&amp; dotnet run --project FunLang.Tests
</code></pre>
<h2 id="소스-참조-2"><a class="header" href="#소스-참조-2">소스 참조</a></h2>
<p>전체 소스 코드는 다음 위치에서 확인할 수 있다:</p>
<ul>
<li><strong>FunLang/Type.fs</strong>: 타입 정의, Substitution, Free Variables</li>
<li><strong>FunLang/Unify.fs</strong>: 단일화 알고리즘, Occurs Check</li>
<li><strong>FunLang/Infer.fs</strong>: Algorithm W 구현</li>
<li><strong>FunLang/TypeCheck.fs</strong>: Prelude 타입, typecheck 함수</li>
<li><strong>FunLang/Program.fs</strong>: CLI 통합 (–emit-type)</li>
</ul>
<h2 id="다음-단계-양방향-타입-체킹"><a class="header" href="#다음-단계-양방향-타입-체킹">다음 단계: 양방향 타입 체킹</a></h2>
<p>이 장에서 구현한 Algorithm W는 <strong>타입 추론</strong>의 기초다. 하지만 타입 주석을 명시적으로 지원하지 않는다.</p>
<p>FunLang v6.0부터 **양방향 타입 체킹(Bidirectional Type Checking)**을 도입하여:</p>
<ul>
<li>타입 주석 지원: <code>fun (x: int) -&gt; x + 1</code></li>
<li>더 나은 에러 메시지: 예상 타입이 어디서 왔는지 설명</li>
<li>문서화 목적의 명시적 타입: <code>(expr : Type)</code></li>
</ul>
<p>자세한 내용은 <a href="#chapter-12-양방향-타입-체킹-bidirectional-type-checking">Chapter 12: 양방향 타입 체킹</a>을 참고한다.</p>
<blockquote>
<p><strong>Note</strong>: Bidir 모듈(<code>FunLang/Bidir.fs</code>)이 TypeCheck.fs에서 사용된다.
Infer 모듈의 <code>infer</code>/<code>inferWithContext</code>는 참고용으로 유지되며,
<code>freshVar</code>, <code>instantiate</code>, <code>generalize</code> 등의 헬퍼 함수는 Bidir에서 재사용된다.</p>
</blockquote>
<h2 id="관련-문서-9"><a class="header" href="#관련-문서-9">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/implement-hindley-milner-algorithm-w.html">implement-hindley-milner-algorithm-w</a> - Algorithm W 전체 흐름</li>
<li><a href="../docs/howto/implement-let-polymorphism.html">implement-let-polymorphism</a> - Let-polymorphism 구현</li>
<li><a href="../docs/howto/avoid-type-variable-collision.html">avoid-type-variable-collision</a> - 타입 변수 충돌 방지</li>
<li><a href="../docs/howto/write-type-inference-tests.html">write-type-inference-tests</a> - 타입 추론 테스트 방법</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-11-type-error-diagnostics"><a class="header" href="#chapter-11-type-error-diagnostics">Chapter 11: Type Error Diagnostics</a></h1>
<p>이 장에서는 FunLang의 타입 에러에 <strong>정확한 위치 정보와 컨텍스트</strong>를 추가하여 사용자 친화적인 진단 메시지를 생성한다. Rust 컴파일러 스타일의 멀티라인 에러 포맷을 구현한다.</p>
<h2 id="개요-10"><a class="header" href="#개요-10">개요</a></h2>
<p>진단 시스템은 다음 기능을 제공한다:</p>
<ul>
<li><strong>Span 추적</strong>: 모든 AST 노드에 소스 위치 (파일, 라인, 컬럼) 기록</li>
<li><strong>에러 코드</strong>: E0301~E0304로 에러 유형 식별</li>
<li><strong>컨텍스트 스택</strong>: 타입 추론 경로 추적 (어디서 에러가 발생했는지)</li>
<li><strong>Blame Assignment</strong>: Primary/secondary span으로 관련 위치 표시</li>
<li><strong>Rust-style 출력</strong>: 멀티라인 에러 포맷 (위치, 노트, 힌트)</li>
</ul>
<p><strong>핵심 아이디어</strong>: Lexer가 위치를 수집하고, Parser가 AST에 전파하며, 타입 추론이 컨텍스트를 쌓고, 최종적으로 Diagnostic으로 변환하여 출력한다.</p>
<h2 id="구현-전략-2"><a class="header" href="#구현-전략-2">구현 전략</a></h2>
<p>진단 시스템은 4단계로 구현된다:</p>
<ol>
<li><strong>Span Infrastructure</strong>: Lexer/Parser에서 위치 추적</li>
<li><strong>Error Representation</strong>: Diagnostic, TypeError, InferContext, UnifyPath 타입</li>
<li><strong>Blame Assignment</strong>: 컨텍스트 스택에서 secondary span 추출</li>
<li><strong>Output Formatting</strong>: Rust-style 멀티라인 포맷</li>
</ol>
<h3 id="에러-출력-예시"><a class="header" href="#에러-출력-예시">에러 출력 예시</a></h3>
<pre><code>error[E0301]: Type mismatch: expected int but got bool
 --&gt; test.fun:3:10-14
   = in if condition: test.fun:3:4-20
   = note: in if then-branch at test.fun:3:4
   = hint: Check that all branches of your expression return the same type
</code></pre>
<h2 id="astfs-span-타입"><a class="header" href="#astfs-span-타입">Ast.fs: Span 타입</a></h2>
<p><code>FunLang/Ast.fs</code> 상단에 Span 타입과 헬퍼 함수를 정의한다.</p>
<h3 id="span-타입-정의"><a class="header" href="#span-타입-정의">Span 타입 정의</a></h3>
<pre><code class="language-fsharp">/// Source location span for error messages
type Span = {
    FileName: string
    StartLine: int
    StartColumn: int
    EndLine: int
    EndColumn: int
}
</code></pre>
<p><strong>설계 결정</strong>:</p>
<ul>
<li>1-based 라인/컬럼: FsLexYacc Position API와 일치</li>
<li>시작/끝 위치: 단일 토큰부터 복합 표현식까지 표현</li>
</ul>
<h3 id="헬퍼-함수"><a class="header" href="#헬퍼-함수">헬퍼 함수</a></h3>
<pre><code class="language-fsharp">/// Create span from FsLexYacc Position records
let mkSpan (startPos: Position) (endPos: Position) : Span =
    {
        FileName = startPos.FileName
        StartLine = startPos.Line
        StartColumn = startPos.Column
        EndLine = endPos.Line
        EndColumn = endPos.Column
    }

/// Sentinel span for built-in/synthetic definitions
let unknownSpan : Span =
    { FileName = "&lt;unknown&gt;"; StartLine = 0; StartColumn = 0; EndLine = 0; EndColumn = 0 }

/// Format span for error messages
let formatSpan (span: Span) : string =
    if span = unknownSpan then "&lt;unknown location&gt;"
    elif span.StartLine = span.EndLine then
        sprintf "%s:%d:%d-%d" span.FileName span.StartLine span.StartColumn span.EndColumn
    else
        sprintf "%s:%d:%d-%d:%d" span.FileName span.StartLine span.StartColumn span.EndLine span.EndColumn
</code></pre>
<ul>
<li><code>unknownSpan</code>: Prelude 함수처럼 소스가 없는 노드용</li>
<li><code>formatSpan</code>: 같은 라인이면 <code>file:line:col1-col2</code>, 다르면 <code>file:line1:col1-line2:col2</code></li>
</ul>
<h3 id="ast에-span-추가"><a class="header" href="#ast에-span-추가">AST에 Span 추가</a></h3>
<p>모든 Expr/Pattern variant에 <code>span: Span</code>을 <strong>마지막 named parameter</strong>로 추가한다:</p>
<pre><code class="language-fsharp">type Expr =
    | Number of int * span: Span
    | Add of Expr * Expr * span: Span
    | Lambda of string * Expr * span: Span
    | App of Expr * Expr * span: Span
    | Let of string * Expr * Expr * span: Span
    | IfThenElse of Expr * Expr * Expr * span: Span
    // ... 모든 variant에 span 추가
</code></pre>
<p><strong>Named parameter 이유</strong>: F#에서 패턴 매칭 시 <code>_</code>로 무시할 수 있어 기존 코드 호환성 유지.</p>
<pre><code class="language-fsharp">// 기존 코드는 span을 _ 로 무시
| Add (e1, e2, _) -&gt; evalExpr env e1 + evalExpr env e2
</code></pre>
<h3 id="spanof-헬퍼"><a class="header" href="#spanof-헬퍼">spanOf 헬퍼</a></h3>
<pre><code class="language-fsharp">/// Extract span from any expression
let spanOf (expr: Expr) : Span =
    match expr with
    | Number(_, s) | Bool(_, s) | String(_, s) | Var(_, s) -&gt; s
    | Add(_, _, s) | Subtract(_, _, s) | Multiply(_, _, s) | Divide(_, _, s) -&gt; s
    | Lambda(_, _, s) | App(_, _, s) | Let(_, _, _, s) -&gt; s
    // ... 모든 variant
</code></pre>
<h2 id="lexerfsl-위치-초기화"><a class="header" href="#lexerfsl-위치-초기화">Lexer.fsl: 위치 초기화</a></h2>
<p>Lexer에서 위치 추적을 활성화한다.</p>
<h3 id="setinitialpos-함수"><a class="header" href="#setinitialpos-함수">setInitialPos 함수</a></h3>
<pre><code class="language-fsharp">// Lexer.fsl 상단 { } 블록
open FSharp.Text.Lexing

/// Initialize position tracking for the lexbuf
let setInitialPos (lexbuf: LexBuffer&lt;_&gt;) (filename: string) =
    lexbuf.EndPos &lt;- {
        pos_fname = filename
        pos_lnum = 1
        pos_bol = 0
        pos_cnum = 0
        pos_orig_lnum = 1  // 필수! 문서에 없지만 빠지면 컴파일 에러
    }
</code></pre>
<h3 id="newline-위치-갱신"><a class="header" href="#newline-위치-갱신">Newline 위치 갱신</a></h3>
<p><strong>모든</strong> newline 발생 지점에서 <code>NextLine</code>을 호출해야 한다:</p>
<pre><code class="language-fsharp">rule tokenize = parse
    | newline { lexbuf.EndPos &lt;- lexbuf.EndPos.NextLine
                tokenize lexbuf }
    | ...

// 블록 주석 내에서도!
and block_comment depth = parse
    | newline { lexbuf.EndPos &lt;- lexbuf.EndPos.NextLine
                block_comment depth lexbuf }
    | ...
</code></pre>
<p><strong>주의</strong>: <code>AsNewLinePos()</code>는 deprecated. 반드시 <code>NextLine</code> 프로퍼티를 사용한다.</p>
<h2 id="parserfsy-span-전파"><a class="header" href="#parserfsy-span-전파">Parser.fsy: Span 전파</a></h2>
<p>Parser에서 AST 노드에 span을 전달한다.</p>
<h3 id="헬퍼-함수-1"><a class="header" href="#헬퍼-함수-1">헬퍼 함수</a></h3>
<pre><code class="language-fsharp">%{
open FSharp.Text.Parsing  // IParseState 접근

/// Create span from first symbol's start to last symbol's end
let ruleSpan (parseState: IParseState) (firstSym: int) (lastSym: int) : Span =
    mkSpan (parseState.InputStartPosition firstSym) (parseState.InputEndPosition lastSym)

/// Get span of a single symbol
let symSpan (parseState: IParseState) (n: int) : Span =
    mkSpan (parseState.InputStartPosition n) (parseState.InputEndPosition n)
%}
</code></pre>
<ul>
<li><code>ruleSpan</code>: 다중 심볼 규칙용 (e.g., <code>IF Expr THEN Expr ELSE Expr</code>)</li>
<li><code>symSpan</code>: 단일 심볼 규칙용 (e.g., <code>NUMBER</code>)</li>
<li>심볼 번호는 1부터 시작</li>
</ul>
<h3 id="문법-규칙에서-span-전파"><a class="header" href="#문법-규칙에서-span-전파">문법 규칙에서 span 전파</a></h3>
<pre><code class="language-fsharp">Expr:
    // 단일 토큰: symSpan 사용
    | NUMBER        { Number($1, symSpan parseState 1) }
    | TRUE          { Bool(true, symSpan parseState 1) }

    // 다중 심볼: ruleSpan 사용
    | Expr PLUS Expr    { Add($1, $3, ruleSpan parseState 1 3) }
    | IF Expr THEN Expr ELSE Expr
                        { IfThenElse($2, $4, $6, ruleSpan parseState 1 6) }

    // 괄호: 내부 표현식의 span 유지
    | LPAREN Expr RPAREN { $2 }
</code></pre>
<h2 id="diagnosticfs-에러-표현"><a class="header" href="#diagnosticfs-에러-표현">Diagnostic.fs: 에러 표현</a></h2>
<p><code>FunLang/Diagnostic.fs</code>는 타입 에러를 사용자 친화적인 진단으로 변환한다.</p>
<h3 id="diagnostic-타입"><a class="header" href="#diagnostic-타입">Diagnostic 타입</a></h3>
<pre><code class="language-fsharp">/// General error representation with location, message, and helpful context
type Diagnostic = {
    Code: string option           // e.g., Some "E0301"
    Message: string               // Primary error message
    PrimarySpan: Span             // Main error location
    SecondarySpans: (Span * string) list  // Related locations with labels
    Notes: string list            // Additional context
    Hint: string option           // Suggested fix
}
</code></pre>
<h3 id="typeerrorkind"><a class="header" href="#typeerrorkind">TypeErrorKind</a></h3>
<pre><code class="language-fsharp">/// Type error kind - what went wrong
type TypeErrorKind =
    | UnifyMismatch of expected: Type * actual: Type  // E0301
    | OccursCheck of var: int * ty: Type              // E0302
    | UnboundVar of name: string                      // E0303
    | NotAFunction of ty: Type                        // E0304
</code></pre>
<p><strong>에러 코드 체계</strong>:</p>
<ul>
<li><code>E0301</code>: 타입 불일치 (가장 흔함)</li>
<li><code>E0302</code>: Occurs check 실패 (무한 타입)</li>
<li><code>E0303</code>: 정의되지 않은 변수</li>
<li><code>E0304</code>: 함수가 아닌 값 호출</li>
</ul>
<h3 id="infercontext-추론-경로"><a class="header" href="#infercontext-추론-경로">InferContext: 추론 경로</a></h3>
<pre><code class="language-fsharp">/// Inference context - path through the expression being type checked
type InferContext =
    | InIfCond of Span
    | InIfThen of Span
    | InIfElse of Span
    | InAppFun of Span
    | InAppArg of Span
    | InLetRhs of name: string * Span
    | InLetBody of name: string * Span
    | InLetRecBody of name: string * Span
    | InMatch of Span
    | InMatchClause of index: int * Span
    | InTupleElement of index: int * Span
    | InListElement of index: int * Span
    | InConsHead of Span
    | InConsTail of Span
</code></pre>
<p>타입 추론이 AST를 순회하며 컨텍스트를 스택에 push한다. 에러 발생 시 이 스택이 “어디서 에러가 났는지” 알려준다.</p>
<h3 id="unifypath-단일화-경로"><a class="header" href="#unifypath-단일화-경로">UnifyPath: 단일화 경로</a></h3>
<pre><code class="language-fsharp">/// Unification path - where in the type structure unification failed
type UnifyPath =
    | AtFunctionParam of Type
    | AtFunctionReturn of Type
    | AtTupleIndex of index: int * Type
    | AtListElement of Type
</code></pre>
<p><code>(int -&gt; bool, int -&gt; int)</code>을 단일화할 때 <code>AtFunctionReturn</code>에서 실패한다는 정보를 제공한다.</p>
<h3 id="typeerror-통합-에러-타입"><a class="header" href="#typeerror-통합-에러-타입">TypeError: 통합 에러 타입</a></h3>
<pre><code class="language-fsharp">/// Rich type error with full context for diagnostics
type TypeError = {
    Kind: TypeErrorKind
    Span: Span
    Term: Expr option
    ContextStack: InferContext list
    Trace: UnifyPath list
}
</code></pre>
<h3 id="typeerrortodiagnostic-변환"><a class="header" href="#typeerrortodiagnostic-변환">typeErrorToDiagnostic 변환</a></h3>
<pre><code class="language-fsharp">/// Convert TypeError to Diagnostic for display
let typeErrorToDiagnostic (err: TypeError) : Diagnostic =
    let code, message, hint =
        match err.Kind with
        | UnifyMismatch (expected, actual) -&gt;
            Some "E0301",
            sprintf "Type mismatch: expected %s but got %s" (formatType expected) (formatType actual),
            Some "Check that all branches of your expression return the same type"

        | OccursCheck (var, ty) -&gt;
            Some "E0302",
            sprintf "Occurs check: cannot construct infinite type '%c = %s"
                (char (97 + var % 26)) (formatType ty),
            Some "This usually means you're trying to define a recursive type without a base case"

        | UnboundVar name -&gt;
            Some "E0303",
            sprintf "Unbound variable: %s" name,
            Some "Make sure the variable is defined before use"

        | NotAFunction ty -&gt;
            Some "E0304",
            sprintf "Type %s is not a function and cannot be applied" (formatType ty),
            Some "Check that you're calling a function, not a value"

    // ... notes, secondarySpans 구성
</code></pre>
<h2 id="inferfs-컨텍스트-스택-관리"><a class="header" href="#inferfs-컨텍스트-스택-관리">Infer.fs: 컨텍스트 스택 관리</a></h2>
<p>타입 추론 함수가 컨텍스트를 추적하도록 수정한다.</p>
<h3 id="inferwithcontext"><a class="header" href="#inferwithcontext">inferWithContext</a></h3>
<pre><code class="language-fsharp">/// Type inference with context tracking
let rec inferWithContext (env: TypeEnv) (ctx: InferContext list) (expr: Expr) : Subst * Type =
    match expr with
    | IfThenElse (cond, thenExpr, elseExpr, span) -&gt;
        // 조건 추론 시 InIfCond 컨텍스트 push
        let s1, condTy = inferWithContext env (InIfCond (spanOf cond) :: ctx) cond
        let s2 = unifyWithContext condTy TBool ctx []
        // then 브랜치 추론 시 InIfThen 컨텍스트 push
        let s3, thenTy = inferWithContext (applyEnv s2 env) (InIfThen (spanOf thenExpr) :: ctx) thenExpr
        // else 브랜치 추론 시 InIfElse 컨텍스트 push
        let s4, elseTy = inferWithContext (applyEnv s3 env) (InIfElse (spanOf elseExpr) :: ctx) elseExpr
        // ...

    | App (func, arg, span) -&gt;
        let s1, funcTy = inferWithContext env (InAppFun (spanOf func) :: ctx) func
        let s2, argTy = inferWithContext (applyEnv s1 env) (InAppArg (spanOf arg) :: ctx) arg
        // NotAFunction 체크
        match apply s2 funcTy with
        | TInt | TBool | TString | TTuple _ | TList _ as ty -&gt;
            raise (TypeException { Kind = NotAFunction ty; Span = spanOf func; ... })
        | _ -&gt;
            // 정상 단일화
</code></pre>
<p><strong>핵심</strong>: 각 재귀 호출 전에 현재 위치를 컨텍스트 스택에 push한다.</p>
<h2 id="typefs-타입-변수-정규화"><a class="header" href="#typefs-타입-변수-정규화">Type.fs: 타입 변수 정규화</a></h2>
<p>내부 타입 변수 인덱스(1000, 1001, …)를 사용자 친화적인 ’a, ’b, ’c로 변환한다.</p>
<h3 id="formattypenormalized"><a class="header" href="#formattypenormalized">formatTypeNormalized</a></h3>
<pre><code class="language-fsharp">/// Format type with normalized variable names ('a, 'b, 'c based on first appearance)
let formatTypeNormalized (ty: Type) : string =
    // Collect all type variables in order of first appearance
    let rec collectVars acc = function
        | TVar n -&gt; if List.contains n acc then acc else acc @ [n]
        | TArrow(t1, t2) -&gt; collectVars (collectVars acc t1) t2
        | TTuple ts -&gt; List.fold collectVars acc ts
        | TList t -&gt; collectVars acc t
        | TInt | TBool | TString -&gt; acc

    let vars = collectVars [] ty
    let varMap = vars |&gt; List.mapi (fun i v -&gt; (v, i)) |&gt; Map.ofList

    let rec format = function
        | TVar n -&gt;
            match Map.tryFind n varMap with
            | Some idx -&gt; sprintf "'%c" (char (97 + idx % 26))
            | None -&gt; sprintf "'%c" (char (97 + n % 26))
        | TArrow(t1, t2) -&gt;
            let left = match t1 with TArrow _ -&gt; sprintf "(%s)" (format t1) | _ -&gt; format t1
            sprintf "%s -&gt; %s" left (format t2)
        // ...
    format ty
</code></pre>
<p><strong>예시</strong>:</p>
<ul>
<li><code>TVar 1000 -&gt; TVar 1001</code> → <code>'a -&gt; 'b</code> (내부 인덱스 무관, 첫 등장 순서로 정규화)</li>
</ul>
<h2 id="diagnosticfs-포맷팅"><a class="header" href="#diagnosticfs-포맷팅">Diagnostic.fs: 포맷팅</a></h2>
<h3 id="formatdiagnostic"><a class="header" href="#formatdiagnostic">formatDiagnostic</a></h3>
<pre><code class="language-fsharp">/// Format diagnostic for display (Rust-inspired multi-line format)
let formatDiagnostic (diag: Diagnostic) : string =
    let sb = System.Text.StringBuilder()

    // Error header: error[E0301]: Type mismatch
    match diag.Code with
    | Some code -&gt; sb.AppendLine(sprintf "error[%s]: %s" code diag.Message) |&gt; ignore
    | None -&gt; sb.AppendLine(sprintf "error: %s" diag.Message) |&gt; ignore

    // Primary location: --&gt; file.fun:2:5
    sb.AppendLine(sprintf " --&gt; %s" (formatSpan diag.PrimarySpan)) |&gt; ignore

    // Secondary spans (related locations)
    for (span, label) in diag.SecondarySpans do
        sb.AppendLine(sprintf "   = %s: %s" label (formatSpan span)) |&gt; ignore

    // Notes (context stack, trace)
    for note in diag.Notes do
        sb.AppendLine(sprintf "   = note: %s" note) |&gt; ignore

    // Hint
    match diag.Hint with
    | Some hint -&gt; sb.AppendLine(sprintf "   = hint: %s" hint) |&gt; ignore
    | None -&gt; ()

    sb.ToString().TrimEnd()
</code></pre>
<h3 id="contexttosecondaryspans"><a class="header" href="#contexttosecondaryspans">contextToSecondarySpans</a></h3>
<p>컨텍스트 스택에서 관련 위치를 추출한다:</p>
<pre><code class="language-fsharp">/// Extract secondary spans from context stack (limited to 3)
let contextToSecondarySpans (primarySpan: Span) (contexts: InferContext list) : (Span * string) list =
    contexts
    |&gt; List.rev  // 외부→내부 순서로 변환
    |&gt; List.map (function
        | InIfCond span -&gt; (span, "in if condition")
        | InIfThen span -&gt; (span, "in then branch")
        | InIfElse span -&gt; (span, "in else branch")
        | InAppFun span -&gt; (span, "in function position")
        | InAppArg span -&gt; (span, "in argument position")
        // ...
    )
    |&gt; List.filter (fun (span, _) -&gt; span &lt;&gt; primarySpan)  // Primary span 제외
    |&gt; List.distinctBy fst  // 중복 제거
    |&gt; List.truncate 3  // 최대 3개로 제한
</code></pre>
<p><strong>설계 결정</strong>:</p>
<ul>
<li>Primary span 제외: 중복 표시 방지</li>
<li>3개 제한: 과도한 정보는 오히려 방해</li>
</ul>
<h2 id="cli-통합-2"><a class="header" href="#cli-통합-2">CLI 통합</a></h2>
<p><code>Program.fs</code>에서 새 진단 포맷을 사용한다:</p>
<pre><code class="language-fsharp">| EmitType -&gt;
    let source = results.GetResult Expr
    let ast = parse source "&lt;expr&gt;"
    match typecheckWithDiagnostic ast with
    | Ok ty -&gt; printfn "%s" (formatTypeNormalized ty)
    | Error diag -&gt;
        eprintfn "%s" (formatDiagnostic diag)
        exit 1
</code></pre>
<h2 id="examples-10"><a class="header" href="#examples-10">Examples</a></h2>
<h3 id="타입-불일치-e0301"><a class="header" href="#타입-불일치-e0301">타입 불일치 (E0301)</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'if 1 then 2 else 3'
error[E0301]: Type mismatch: expected int but got bool
 --&gt; &lt;expr&gt;:1:0-18
   = hint: Check that all branches of your expression return the same type
</code></pre>
<h3 id="occurs-check-e0302"><a class="header" href="#occurs-check-e0302">Occurs Check (E0302)</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'let rec f x = f in f'
error[E0302]: Occurs check: cannot construct infinite type 'a = 'a -&gt; 'b
 --&gt; &lt;expr&gt;:1:14-14
   = hint: This usually means you're trying to define a recursive type without a base case
</code></pre>
<h3 id="정의되지-않은-변수-e0303"><a class="header" href="#정의되지-않은-변수-e0303">정의되지 않은 변수 (E0303)</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'xyz'
error[E0303]: Unbound variable: xyz
 --&gt; &lt;expr&gt;:1:0-2
   = hint: Make sure the variable is defined before use
</code></pre>
<h3 id="함수가-아닌-값-호출-e0304"><a class="header" href="#함수가-아닌-값-호출-e0304">함수가 아닌 값 호출 (E0304)</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e '1 2'
error[E0304]: Type int is not a function and cannot be applied
 --&gt; &lt;expr&gt;:1:0-1
   = hint: Check that you're calling a function, not a value
</code></pre>
<h3 id="브랜치-타입-불일치"><a class="header" href="#브랜치-타입-불일치">브랜치 타입 불일치</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'if true then 1 else false'
error[E0301]: Type mismatch: expected int but got bool
 --&gt; &lt;expr&gt;:1:0-25
   = hint: Check that all branches of your expression return the same type
</code></pre>
<h3 id="리스트-요소-타입-불일치"><a class="header" href="#리스트-요소-타입-불일치">리스트 요소 타입 불일치</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e '[1, true]'
error[E0301]: Type mismatch: expected int but got bool
 --&gt; &lt;expr&gt;:1:0-8
   = hint: Check that all branches of your expression return the same type
</code></pre>
<h2 id="구현-세부-사항-2"><a class="header" href="#구현-세부-사항-2">구현 세부 사항</a></h2>
<h3 id="context-stack-저장-순서"><a class="header" href="#context-stack-저장-순서">Context Stack 저장 순서</a></h3>
<p>컨텍스트 스택은 <strong>inner-first</strong> (가장 안쪽이 head)로 저장하고, 출력 시 reverse한다:</p>
<pre><code class="language-fsharp">// 저장: [InIfCond; InLetBody; InAppArg] (inner-first)
// 출력: [InAppArg; InLetBody; InIfCond] (outer-first, 사용자 친화적)
let formatContextStack (stack: InferContext list) : string list =
    stack
    |&gt; List.rev  // ← 출력 시 reverse
    |&gt; List.map (function ...)
</code></pre>
<h3 id="secondary-span-제한"><a class="header" href="#secondary-span-제한">Secondary Span 제한</a></h3>
<p>관련 위치가 너무 많으면 오히려 혼란스럽다. 3개로 제한하여 가장 관련성 높은 정보만 표시한다.</p>
<h3 id="notafunction-감지-타이밍"><a class="header" href="#notafunction-감지-타이밍">NotAFunction 감지 타이밍</a></h3>
<p>App 추론에서 단일화 <strong>전에</strong> NotAFunction을 체크한다:</p>
<pre><code class="language-fsharp">| App (func, arg, span) -&gt;
    let s1, funcTy = inferWithContext env ctx func
    let s2, argTy = inferWithContext (applyEnv s1 env) ctx arg
    // 단일화 전에 체크!
    match apply s2 funcTy with
    | TInt | TBool | TString | TTuple _ | TList _ as ty -&gt;
        raise (TypeException { Kind = NotAFunction ty; ... })
    | _ -&gt; // 정상 단일화
</code></pre>
<p>이렇게 하면 “타입 불일치” 대신 더 명확한 “함수가 아님” 에러를 표시할 수 있다.</p>
<h2 id="정리-6"><a class="header" href="#정리-6">정리</a></h2>
<p>이 장에서 구현한 내용:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>파일</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>Span 타입</td><td><code>Ast.fs</code></td><td>소스 위치 (파일, 라인, 컬럼)</td></tr>
<tr><td>Lexer 위치</td><td><code>Lexer.fsl</code></td><td>setInitialPos, NextLine</td></tr>
<tr><td>Parser span</td><td><code>Parser.fsy</code></td><td>ruleSpan, symSpan</td></tr>
<tr><td>Diagnostic</td><td><code>Diagnostic.fs</code></td><td>에러 코드, 메시지, span, 힌트</td></tr>
<tr><td>TypeError</td><td><code>Diagnostic.fs</code></td><td>Kind, ContextStack, Trace</td></tr>
<tr><td>포맷팅</td><td><code>Diagnostic.fs</code></td><td>formatDiagnostic (Rust-style)</td></tr>
<tr><td>정규화</td><td><code>Type.fs</code></td><td>formatTypeNormalized (’a, ’b, ’c)</td></tr>
<tr><td>CLI</td><td><code>Program.fs</code></td><td>새 에러 포맷 출력</td></tr>
</tbody>
</table>
</div>
<p><strong>에러 코드 체계</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>코드</th><th>의미</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td>E0301</td><td>타입 불일치</td><td><code>1 + true</code></td></tr>
<tr><td>E0302</td><td>Occurs check</td><td><code>let rec f x = f</code></td></tr>
<tr><td>E0303</td><td>정의되지 않은 변수</td><td><code>xyz</code></td></tr>
<tr><td>E0304</td><td>함수가 아닌 값 호출</td><td><code>1 2</code></td></tr>
</tbody>
</table>
</div>
<h2 id="테스트-9"><a class="header" href="#테스트-9">테스트</a></h2>
<pre><code class="language-bash"># 타입 에러 골든 테스트 (12개)
make -C tests type-errors

# 전체 fslit 테스트
make -C tests

# Expecto 단위 테스트
dotnet run --project FunLang.Tests

# 전체 테스트 (570개)
make -C tests &amp;&amp; dotnet run --project FunLang.Tests
</code></pre>
<h2 id="소스-참조-3"><a class="header" href="#소스-참조-3">소스 참조</a></h2>
<p>전체 소스 코드는 다음 위치에서 확인할 수 있다:</p>
<ul>
<li><strong>FunLang/Ast.fs</strong>: Span 타입, mkSpan, formatSpan, AST span 필드</li>
<li><strong>FunLang/Lexer.fsl</strong>: setInitialPos, NextLine 위치 갱신</li>
<li><strong>FunLang/Parser.fsy</strong>: ruleSpan, symSpan, span 전파</li>
<li><strong>FunLang/Diagnostic.fs</strong>: Diagnostic, TypeError, InferContext, UnifyPath, formatDiagnostic</li>
<li><strong>FunLang/Type.fs</strong>: formatTypeNormalized</li>
<li><strong>FunLang/Infer.fs</strong>: inferWithContext, 컨텍스트 스택 관리</li>
<li><strong>FunLang/Program.fs</strong>: CLI 통합</li>
</ul>
<h2 id="관련-문서-10"><a class="header" href="#관련-문서-10">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/track-source-positions-fslexyacc.html">track-source-positions-fslexyacc</a> - FsLexYacc 위치 추적</li>
<li><a href="../docs/howto/implement-hindley-milner-algorithm-w.html">implement-hindley-milner-algorithm-w</a> - Algorithm W 타입 추론</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chapter-12-양방향-타입-체킹-bidirectional-type-checking"><a class="header" href="#chapter-12-양방향-타입-체킹-bidirectional-type-checking">Chapter 12: 양방향 타입 체킹 (Bidirectional Type Checking)</a></h1>
<p>이 장에서는 FunLang의 타입 시스템을 <strong>양방향 타입 체킹</strong>으로 확장하여 타입 어노테이션을 지원한다. 기존 Algorithm W는 표현식에서 타입을 “합성“하는 단일 방향만 지원했지만, 양방향 체킹은 추가로 주어진 타입에 대해 표현식을 “검사“하는 기능을 제공한다.</p>
<h2 id="개요-11"><a class="header" href="#개요-11">개요</a></h2>
<p>양방향 타입 체킹은 다음 기능을 제공한다:</p>
<ul>
<li><strong>Synthesis (합성)</strong>: 표현식에서 타입을 추론 (bottom-up)</li>
<li><strong>Checking (검사)</strong>: 예상 타입에 대해 표현식 검증 (top-down)</li>
<li><strong>타입 어노테이션</strong>: <code>(e : T)</code>, <code>fun (x: int) -&gt; e</code></li>
</ul>
<p><strong>핵심 아이디어</strong>: Algorithm W는 모든 타입을 추론하지만, 양방향 체킹은 주어진 타입 정보를 활용하여 더 나은 에러 메시지와 명시적 문서화를 제공한다.</p>
<h2 id="algorithm-w와의-비교"><a class="header" href="#algorithm-w와의-비교">Algorithm W와의 비교</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>특성</th><th>Algorithm W</th><th>Bidirectional</th></tr>
</thead>
<tbody>
<tr><td>방향</td><td>Bottom-up only</td><td>Both directions</td></tr>
<tr><td>어노테이션</td><td>지원 안함</td><td><code>(e : T)</code>, <code>fun (x: T) -&gt; e</code></td></tr>
<tr><td>에러 메시지</td><td>추론된 타입만 표시</td><td>“expected T due to annotation”</td></tr>
<tr><td>다형성</td><td>let-polymorphism</td><td>let-polymorphism (동일)</td></tr>
<tr><td>구현</td><td><code>infer</code> 함수 하나</td><td><code>synth</code> + <code>check</code> 두 함수</td></tr>
</tbody>
</table>
</div>
<p><strong>Algorithm W의 한계</strong>:</p>
<pre><code class="language-funlang">// Algorithm W: 모든 타입을 추론
fun x -&gt; x + 1    // int -&gt; int (추론됨)
</code></pre>
<p><strong>양방향 체킹의 장점</strong>:</p>
<pre><code class="language-funlang">// 명시적 어노테이션으로 의도 표현
fun (x: int) -&gt; x + 1              // int -&gt; int (어노테이션 확인)
(fun x -&gt; x + 1 : int -&gt; int)      // 표현식 전체에 타입 지정
</code></pre>
<p>어노테이션이 있으면 에러 메시지가 더 명확해진다:</p>
<pre><code>// Algorithm W
error: Cannot unify int with bool

// Bidirectional (어노테이션 있을 때)
error[E0301]: Type mismatch: expected int but got bool
   = note: expected int due to annotation at &lt;expr&gt;:1:0-12
</code></pre>
<h2 id="구현-전략-3"><a class="header" href="#구현-전략-3">구현 전략</a></h2>
<p>양방향 타입 체킹은 3단계로 구현된다:</p>
<ol>
<li><strong>Parser Extensions</strong>: 타입 어노테이션 문법 추가</li>
<li><strong>Type Elaboration</strong>: TypeExpr -&gt; Type 변환</li>
<li><strong>Bidir Module</strong>: synth/check 함수 구현</li>
</ol>
<h2 id="typeexpr-타입-표현식-ast"><a class="header" href="#typeexpr-타입-표현식-ast">TypeExpr: 타입 표현식 AST</a></h2>
<p>파서가 인식하는 타입 표현식 문법이다. <code>FunLang/Ast.fs</code>에 정의:</p>
<pre><code class="language-fsharp">/// Type expression AST for type annotations
type TypeExpr =
    | TEInt                               // int
    | TEBool                              // bool
    | TEString                            // string
    | TEList of TypeExpr                  // T list
    | TEArrow of TypeExpr * TypeExpr      // T1 -&gt; T2 (right-associative)
    | TETuple of TypeExpr list            // T1 * T2 * ... (n &gt;= 2)
    | TEVar of string                     // 'a, 'b (includes apostrophe)
</code></pre>
<p><strong>주요 차이점</strong>:</p>
<ul>
<li><code>TypeExpr</code>: 파서가 생성하는 문법 표현 (문자열 <code>'a</code> 포함)</li>
<li><code>Type</code>: 타입 추론에서 사용하는 내부 표현 (<code>TVar of int</code>)</li>
</ul>
<h2 id="elaboratefs-타입-정교화"><a class="header" href="#elaboratefs-타입-정교화">Elaborate.fs: 타입 정교화</a></h2>
<p><code>TypeExpr</code>을 <code>Type</code>으로 변환한다. 핵심은 타입 변수 처리:</p>
<pre><code class="language-fsharp">module Elaborate

/// Type variable environment: maps type variable names to TVar indices
/// Example: 'a -&gt; 0, 'b -&gt; 1
type TypeVarEnv = Map&lt;string, int&gt;

/// Fresh type variable index generator for elaboration
/// Start at 0 (separate range from inference's 1000+)
let freshTypeVarIndex =
    let counter = ref 0
    fun () -&gt;
        let n = !counter
        counter := n + 1
        n
</code></pre>
<p><strong>설계 결정</strong>: 사용자 타입 변수는 0부터, 추론 타입 변수는 1000부터 시작하여 충돌을 방지한다.</p>
<h3 id="elaboratewithvars-핵심-변환-함수"><a class="header" href="#elaboratewithvars-핵심-변환-함수">elaborateWithVars: 핵심 변환 함수</a></h3>
<pre><code class="language-fsharp">/// Elaborate type expression to type, threading type variable environment
/// Returns: (elaborated type, updated environment)
let rec elaborateWithVars (vars: TypeVarEnv) (te: TypeExpr): Type * TypeVarEnv =
    match te with
    | TEInt -&gt; (TInt, vars)
    | TEBool -&gt; (TBool, vars)
    | TEString -&gt; (TString, vars)

    | TEList t -&gt;
        let (ty, vars') = elaborateWithVars vars t
        (TList ty, vars')

    | TEArrow (t1, t2) -&gt;
        let (ty1, vars1) = elaborateWithVars vars t1
        let (ty2, vars2) = elaborateWithVars vars1 t2
        (TArrow (ty1, ty2), vars2)

    | TEVar name -&gt;
        // Type variable: 'a, 'b, etc.
        // If already seen in this scope, reuse index
        // If new, allocate fresh index and record it
        match Map.tryFind name vars with
        | Some idx -&gt; (TVar idx, vars)
        | None -&gt;
            let idx = freshTypeVarIndex()
            let vars' = Map.add name idx vars
            (TVar idx, vars')
</code></pre>
<p><strong>핵심 포인트</strong>:</p>
<ul>
<li>같은 이름의 타입 변수(<code>'a</code>)는 같은 <code>TVar</code> 인덱스를 공유</li>
<li>환경을 threading하여 스코프 내 일관성 유지</li>
</ul>
<h3 id="api-함수"><a class="header" href="#api-함수">API 함수</a></h3>
<pre><code class="language-fsharp">/// Elaborate single type expression with fresh scope
let elaborateTypeExpr (te: TypeExpr): Type =
    let (ty, _) = elaborateWithVars Map.empty te
    ty

/// Elaborate multiple type expressions sharing the same scope
/// Used for curried function parameters: fun (x: 'a) (y: 'a) -&gt; ...
/// Both 'a refer to the same type variable
let elaborateScoped (tes: TypeExpr list): Type list =
    let folder (acc, env) te =
        let (ty, env') = elaborateWithVars env te
        (ty :: acc, env')
    let (revTypes, _) = List.fold folder ([], Map.empty) tes
    List.rev revTypes
</code></pre>
<h2 id="bidirfs-핵심-구현"><a class="header" href="#bidirfs-핵심-구현">Bidir.fs: 핵심 구현</a></h2>
<p>양방향 타입 체킹의 두 가지 모드:</p>
<ul>
<li><strong>synth (합성)</strong>: 표현식 -&gt; 타입 (bottom-up)</li>
<li><strong>check (검사)</strong>: 표현식 + 예상 타입 -&gt; 검증 (top-down)</li>
</ul>
<pre><code class="language-fsharp">module Bidir

open Ast
open Type
open Unify
open Elaborate
open Diagnostic
open Infer  // Reuse freshVar, instantiate, generalize
</code></pre>
<h3 id="synthesis-mode-synth"><a class="header" href="#synthesis-mode-synth">Synthesis Mode (synth)</a></h3>
<p>대부분의 표현식은 타입을 합성한다:</p>
<pre><code class="language-fsharp">/// Synthesize type for expression (inference mode)
/// Returns: (substitution, inferred type)
let rec synth (ctx: InferContext list) (env: TypeEnv) (expr: Expr): Subst * Type =
    match expr with
    // === Literals ===
    | Number (_, _) -&gt; (empty, TInt)
    | Bool (_, _) -&gt; (empty, TBool)
    | String (_, _) -&gt; (empty, TString)

    // === Variables ===
    | Var (name, span) -&gt;
        match Map.tryFind name env with
        | Some scheme -&gt; (empty, instantiate scheme)
        | None -&gt; raise (TypeException { Kind = UnboundVar name; ... })

    // === Lambda (unannotated) - HYBRID approach ===
    | Lambda (param, body, _) -&gt;
        let paramTy = freshVar()
        let bodyEnv = Map.add param (Scheme ([], paramTy)) env
        let s, bodyTy = synth ctx bodyEnv body
        (s, TArrow (apply s paramTy, bodyTy))
</code></pre>
<p><strong>HYBRID approach</strong>: 어노테이션 없는 람다는 Algorithm W처럼 fresh 타입 변수를 사용하여 하위 호환성을 유지한다.</p>
<h3 id="annotated-expressions"><a class="header" href="#annotated-expressions">Annotated Expressions</a></h3>
<p>어노테이션이 있는 표현식은 checking mode로 전환:</p>
<pre><code class="language-fsharp">    // === LambdaAnnot (annotated lambda) ===
    | LambdaAnnot (param, paramTyExpr, body, span) -&gt;
        let paramTy = elaborateTypeExpr paramTyExpr
        let ctx' = InCheckMode (paramTy, "annotation", span) :: ctx
        let bodyEnv = Map.add param (Scheme ([], paramTy)) env
        let s, bodyTy = synth ctx' bodyEnv body
        (s, TArrow (apply s paramTy, bodyTy))

    // === Annot (type annotation) ===
    | Annot (e, tyExpr, span) -&gt;
        let expectedTy = elaborateTypeExpr tyExpr
        let ctx' = InCheckMode (expectedTy, "annotation", span) :: ctx
        let s = check ctx' env e expectedTy
        (s, apply s expectedTy)
</code></pre>
<p><code>InCheckMode</code> 컨텍스트는 에러 발생 시 어노테이션 위치를 표시하는 데 사용된다.</p>
<h3 id="checking-mode-check"><a class="header" href="#checking-mode-check">Checking Mode (check)</a></h3>
<p>예상 타입에 대해 표현식을 검사한다:</p>
<pre><code class="language-fsharp">/// Check expression against expected type (checking mode)
/// Returns: substitution that makes expression have expected type
and check (ctx: InferContext list) (env: TypeEnv) (expr: Expr) (expected: Type): Subst =
    match expr with
    // === Lambda against TArrow (BIDIR-04) ===
    | Lambda (param, body, _) -&gt;
        match expected with
        | TArrow (paramTy, resultTy) -&gt;
            let bodyEnv = Map.add param (Scheme ([], paramTy)) env
            let s = check ctx bodyEnv body resultTy
            let s' = unifyWithContext ctx [] (spanOf expr) (apply s paramTy) paramTy
            compose s' s
        | _ -&gt;
            // Not an arrow type - fall through to subsumption
            let s, actual = synth ctx env expr
            let s' = unifyWithContext ctx [] (spanOf expr) (apply s expected) actual
            compose s' s
</code></pre>
<p>람다를 화살표 타입에 대해 체크할 때, 파라미터 타입을 직접 사용하고 바디를 결과 타입에 대해 체크한다.</p>
<h3 id="subsumption-폴백"><a class="header" href="#subsumption-폴백">Subsumption (폴백)</a></h3>
<p>특별한 체킹 규칙이 없으면 합성 후 단일화:</p>
<pre><code class="language-fsharp">    // === Fallback subsumption (BIDIR-06) ===
    | _ -&gt;
        let s, actual = synth ctx env expr
        let s' = unifyWithContext ctx [] (spanOf expr) (apply s expected) actual
        compose s' s
</code></pre>
<h3 id="let-polymorphism-보존"><a class="header" href="#let-polymorphism-보존">Let-polymorphism 보존</a></h3>
<p>Let 바인딩에서 다형성은 Algorithm W와 동일하게 동작:</p>
<pre><code class="language-fsharp">    // === Let (BIDIR-07 - let-polymorphism) ===
    | Let (name, value, body, span) -&gt;
        let s1, valueTy = synth (InLetRhs (name, span) :: ctx) env value
        let env' = applyEnv s1 env
        let scheme = generalize env' (apply s1 valueTy)
        let bodyEnv = Map.add name scheme env'
        let s2, bodyTy = synth (InLetBody (name, span) :: ctx) bodyEnv body
        (compose s2 s1, bodyTy)
</code></pre>
<h3 id="top-level-entry-point"><a class="header" href="#top-level-entry-point">Top-level Entry Point</a></h3>
<pre><code class="language-fsharp">/// Top-level entry: infer type for expression
let synthTop (env: TypeEnv) (expr: Expr): Type =
    let s, ty = synth [] env expr
    apply s ty
</code></pre>
<h2 id="사용-예제"><a class="header" href="#사용-예제">사용 예제</a></h2>
<h3 id="기본-어노테이션"><a class="header" href="#기본-어노테이션">기본 어노테이션</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e '(42 : int)'
int

$ dotnet run --project FunLang -- --emit-type -e '(true : bool)'
bool
</code></pre>
<h3 id="람다-어노테이션"><a class="header" href="#람다-어노테이션">람다 어노테이션</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'fun (x: int) -&gt; x + 1'
int -&gt; int

$ dotnet run --project FunLang -- --emit-type -e 'fun (x: int) (y: int) -&gt; x + y'
int -&gt; int -&gt; int
</code></pre>
<h3 id="표현식-어노테이션"><a class="header" href="#표현식-어노테이션">표현식 어노테이션</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e '(fun x -&gt; x : int -&gt; int)'
int -&gt; int

$ dotnet run --project FunLang -- --emit-type -e '(let x = 5 in x + 1 : int)'
int
</code></pre>
<h3 id="다형성-let-polymorphism"><a class="header" href="#다형성-let-polymorphism">다형성 (Let-polymorphism)</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'let id = fun x -&gt; x in id'
'm -&gt; 'm

$ dotnet run --project FunLang -- --emit-type -e 'let id = fun x -&gt; x in (id 5, id true)'
int * bool
</code></pre>
<h3 id="타입-에러-4"><a class="header" href="#타입-에러-4">타입 에러</a></h3>
<p>어노테이션이 있으면 에러 메시지에 출처가 표시된다:</p>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e '(true : int)'
error[E0301]: Type mismatch: expected int but got bool
 --&gt; &lt;expr&gt;:1:1-5
   = due to annotation: &lt;expr&gt;:1:0-12
   = note: expected int due to annotation at &lt;expr&gt;:1:0-12
   = hint: The type annotation at &lt;expr&gt;:1:0-12 expects int
</code></pre>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type -e 'fun (x: int) -&gt; x &amp;&amp; true'
error[E0301]: Type mismatch: expected int but got bool
 --&gt; &lt;expr&gt;:1:16-17
   = due to annotation: &lt;expr&gt;:1:0-25
   = note: expected int due to annotation at &lt;expr&gt;:1:0-25
   = hint: The type annotation at &lt;expr&gt;:1:0-25 expects int
</code></pre>
<h2 id="에러-메시지-개선"><a class="header" href="#에러-메시지-개선">에러 메시지 개선</a></h2>
<p>양방향 타입 체킹의 주요 이점 중 하나는 더 나은 에러 메시지다.</p>
<h3 id="incheckmode-컨텍스트"><a class="header" href="#incheckmode-컨텍스트">InCheckMode 컨텍스트</a></h3>
<p><code>Diagnostic.fs</code>에 정의된 컨텍스트:</p>
<pre><code class="language-fsharp">type InferContext =
    // ... 기존 컨텍스트
    | InCheckMode of expected: Type * source: string * Span
</code></pre>
<p>어노테이션이 있으면 에러 발생 시 이 컨텍스트를 통해 “왜 이 타입이 예상되었는지” 설명할 수 있다:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>에러 유형</th><th>Algorithm W</th><th>Bidirectional</th></tr>
</thead>
<tbody>
<tr><td>타입 불일치</td><td>“Cannot unify int with bool”</td><td>“expected int but got bool” + 어노테이션 위치</td></tr>
<tr><td>소스 추적</td><td>없음</td><td>“due to annotation at …”</td></tr>
<tr><td>힌트</td><td>일반적</td><td>어노테이션 특화 힌트</td></tr>
</tbody>
</table>
</div>
<h2 id="구현-세부-사항-3"><a class="header" href="#구현-세부-사항-3">구현 세부 사항</a></h2>
<h3 id="synth-vs-check-선택"><a class="header" href="#synth-vs-check-선택">synth vs check 선택</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>표현식</th><th>synth</th><th>check 활용</th></tr>
</thead>
<tbody>
<tr><td>리터럴</td><td>O</td><td>-</td></tr>
<tr><td>변수</td><td>O</td><td>-</td></tr>
<tr><td>함수 적용</td><td>O</td><td>-</td></tr>
<tr><td>람다 (어노테이션 없음)</td><td>O</td><td>-</td></tr>
<tr><td>람다 (어노테이션 있음)</td><td>O (파라미터 타입 사용)</td><td>-</td></tr>
<tr><td>어노테이션 <code>(e : T)</code></td><td>O (check 호출)</td><td>O</td></tr>
<tr><td>if-then-else</td><td>O</td><td>O (브랜치 체크 시)</td></tr>
</tbody>
</table>
</div>
<h3 id="fresh-variable-범위"><a class="header" href="#fresh-variable-범위">Fresh Variable 범위</a></h3>
<pre><code class="language-fsharp">// Elaborate.fs: 사용자 어노테이션용
let freshTypeVarIndex =
    let counter = ref 0  // 0, 1, 2, ...
    fun () -&gt; ...

// Infer.fs: 추론용
let freshVar =
    let counter = ref 1000  // 1000, 1001, 1002, ...
    fun () -&gt; TVar (!counter; counter := !counter + 1; !counter - 1)
</code></pre>
<h3 id="하위-호환성"><a class="header" href="#하위-호환성">하위 호환성</a></h3>
<p>어노테이션 없는 코드는 기존 Algorithm W와 동일하게 동작한다:</p>
<pre><code class="language-funlang">// 기존 코드 (변경 없이 동작)
fun x -&gt; x + 1            // int -&gt; int
let id = fun x -&gt; x in id // 'a -&gt; 'a

// 새 문법 (선택적 사용)
fun (x: int) -&gt; x + 1     // int -&gt; int (어노테이션)
(fun x -&gt; x : int -&gt; int) // int -&gt; int (어노테이션)
</code></pre>
<h2 id="정리-7"><a class="header" href="#정리-7">정리</a></h2>
<p>이 장에서 구현한 양방향 타입 체킹:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>파일</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>타입 표현식 AST</td><td><code>Ast.fs</code></td><td>TypeExpr (TEInt, TEArrow, TEVar, …)</td></tr>
<tr><td>어노테이션 AST</td><td><code>Ast.fs</code></td><td>Annot, LambdaAnnot 노드</td></tr>
<tr><td>타입 정교화</td><td><code>Elaborate.fs</code></td><td>TypeExpr -&gt; Type 변환</td></tr>
<tr><td>양방향 체킹</td><td><code>Bidir.fs</code></td><td>synth/check 함수</td></tr>
<tr><td>에러 컨텍스트</td><td><code>Diagnostic.fs</code></td><td>InCheckMode 추가</td></tr>
<tr><td>CLI 통합</td><td><code>TypeCheck.fs</code></td><td>synthTop 호출</td></tr>
</tbody>
</table>
</div>
<p><strong>핵심 개념</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>개념</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td>Synthesis</td><td>표현식에서 타입 추론 (bottom-up)</td></tr>
<tr><td>Checking</td><td>예상 타입으로 표현식 검증 (top-down)</td></tr>
<tr><td>Subsumption</td><td>체크 모드에서 합성 후 단일화로 폴백</td></tr>
<tr><td>어노테이션</td><td><code>(e : T)</code>, <code>fun (x: T) -&gt; e</code> 문법</td></tr>
<tr><td>에러 출처</td><td>어노테이션 위치가 에러 메시지에 포함</td></tr>
</tbody>
</table>
</div>
<h2 id="테스트-10"><a class="header" href="#테스트-10">테스트</a></h2>
<pre><code class="language-bash"># 어노테이션 테스트 (type-inference)
make -C tests type-inference

# 어노테이션 에러 테스트 (type-errors)
make -C tests type-errors

# 전체 fslit 테스트
make -C tests

# Expecto 단위 테스트
dotnet run --project FunLang.Tests
</code></pre>
<h2 id="소스-참조-4"><a class="header" href="#소스-참조-4">소스 참조</a></h2>
<p>전체 소스 코드는 다음 위치에서 확인할 수 있다:</p>
<ul>
<li><strong>FunLang/Ast.fs</strong>: TypeExpr, Annot, LambdaAnnot 정의</li>
<li><strong>FunLang/Elaborate.fs</strong>: 타입 표현식 정교화</li>
<li><strong>FunLang/Bidir.fs</strong>: 양방향 타입 체커 (synth/check)</li>
<li><strong>FunLang/Diagnostic.fs</strong>: InCheckMode 컨텍스트</li>
<li><strong>FunLang/TypeCheck.fs</strong>: 진입점 (synthTop 호출)</li>
</ul>
<h2 id="관련-문서-11"><a class="header" href="#관련-문서-11">관련 문서</a></h2>
<ul>
<li><a href="#chapter-10-type-system-hindley-milner">Chapter 10: Type System</a> - Hindley-Milner Algorithm W</li>
<li><a href="#chapter-11-type-error-diagnostics">Chapter 11: Type Error Diagnostics</a> - 에러 메시지 개선</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-a-testing"><a class="header" href="#appendix-a-testing">Appendix A: Testing</a></h1>
<p>FunLang 인터프리터의 품질을 보장하기 위한 세 가지 테스트 전략을 소개한다. 각 접근법은 다른 목적에 최적화되어 있으며, 함께 사용할 때 가장 효과적이다.</p>
<h2 id="개요-12"><a class="header" href="#개요-12">개요</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>도구</th><th>목적</th><th>언제 사용</th></tr>
</thead>
<tbody>
<tr><td><strong>fslit</strong></td><td>CLI 통합 테스트</td><td>회귀 방지, E2E 검증</td></tr>
<tr><td><strong>Expecto</strong></td><td>단위 테스트</td><td>모듈별 로직 검증</td></tr>
<tr><td><strong>FsCheck</strong></td><td>속성 기반 테스트</td><td>수학적 불변식 검증</td></tr>
</tbody>
</table>
</div>
<pre><code>테스트 피라미드:

        ┌─────────┐
        │  fslit  │  CLI 검증 (느림, 넓음)
        └────┬────┘
        ┌────┴────┐
        │ Expecto │  단위 테스트 (빠름)
        └────┬────┘
   ┌─────────┴─────────┐
   │     FsCheck       │  속성 테스트 (자동 생성)
   └───────────────────┘
</code></pre>
<hr>
<h2 id="fslit-파일-기반-테스트"><a class="header" href="#fslit-파일-기반-테스트">fslit: 파일 기반 테스트</a></h2>
<h3 id="설치"><a class="header" href="#설치">설치</a></h3>
<pre><code class="language-bash">dotnet tool install -g fslit
</code></pre>
<h3 id="테스트-구조"><a class="header" href="#테스트-구조">테스트 구조</a></h3>
<pre><code>tests/
├── Makefile
├── cli/              # 기본 평가 테스트
│   ├── 01-simple-add.flt
│   └── 02-precedence.flt
├── emit-tokens/      # --emit-tokens 테스트
├── emit-ast/         # --emit-ast 테스트
└── file-input/       # 파일 입력 테스트
</code></pre>
<h3 id="flt-파일-작성"><a class="header" href="#flt-파일-작성">.flt 파일 작성</a></h3>
<p><strong>기본 형식:</strong></p>
<pre><code class="language-flt">// 테스트 설명
// --- Command: dotnet run --project FunLang -- --expr "2 + 3"
// --- Output:
5
</code></pre>
<p><strong>파일 입력 사용 (%input):</strong></p>
<pre><code class="language-flt">// 파일에서 프로그램 실행
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
(2 + 3) * 4
// --- Output:
20
</code></pre>
<h3 id="실행"><a class="header" href="#실행">실행</a></h3>
<pre><code class="language-bash"># 전체 테스트
make -C tests

# 카테고리별
make -C tests cli
make -C tests emit-ast

# 단일 파일
fslit tests/cli/01-simple-add.flt
</code></pre>
<h3 id="makefile-예시"><a class="header" href="#makefile-예시">Makefile 예시</a></h3>
<pre><code class="language-makefile"># tests/Makefile
.PHONY: all test cli emit-tokens emit-ast

all: test

test:
	@cd .. &amp;&amp; fslit tests/

cli:
	@cd .. &amp;&amp; fslit tests/cli/

emit-tokens:
	@cd .. &amp;&amp; fslit tests/emit-tokens/

emit-ast:
	@cd .. &amp;&amp; fslit tests/emit-ast/

check: build test

build:
	@cd .. &amp;&amp; dotnet build
</code></pre>
<h3 id="핵심-규칙"><a class="header" href="#핵심-규칙">핵심 규칙</a></h3>
<ol>
<li><strong>한 파일 = 한 테스트</strong> (fslit 제약)</li>
<li><strong>출력 정확 일치</strong> (공백, 줄바꿈 포함)</li>
<li><strong>번호 접두사</strong> (<code>01-</code>, <code>02-</code>)로 순서 명시</li>
</ol>
<hr>
<h2 id="expecto-단위-테스트-2"><a class="header" href="#expecto-단위-테스트-2">Expecto: 단위 테스트</a></h2>
<h3 id="프로젝트-설정"><a class="header" href="#프로젝트-설정">프로젝트 설정</a></h3>
<pre><code class="language-bash"># 테스트 프로젝트 생성
dotnet new console -lang F# -n FunLang.Tests -f net10.0
cd FunLang.Tests

# 패키지 추가
dotnet add package Expecto
dotnet add reference ../FunLang/FunLang.fsproj
</code></pre>
<h3 id="테스트-코드"><a class="header" href="#테스트-코드">테스트 코드</a></h3>
<pre><code class="language-fsharp">module FunLang.Tests

open Expecto
open FSharp.Text.Lexing

[&lt;Tests&gt;]
let lexerTests =
    testList "Lexer" [
        test "tokenizes number" {
            let lexbuf = LexBuffer&lt;char&gt;.FromString "42"
            let token = Lexer.tokenize lexbuf
            Expect.equal token (Parser.NUMBER 42) "should be NUMBER(42)"
        }
    ]

[&lt;Tests&gt;]
let parserTests =
    testList "Parser" [
        test "parses addition" {
            let lexbuf = LexBuffer&lt;char&gt;.FromString "2 + 3"
            let ast = Parser.start Lexer.tokenize lexbuf
            Expect.equal ast (Ast.Add(Ast.Number 2, Ast.Number 3)) ""
        }
    ]

[&lt;Tests&gt;]
let evalTests =
    testList "Eval" [
        test "evaluates addition" {
            let expr = Ast.Add(Ast.Number 2, Ast.Number 3)
            Expect.equal (Eval.eval expr) 5 ""
        }
    ]

[&lt;EntryPoint&gt;]
let main argv =
    runTestsWithCLIArgs [] argv &lt;| testList "All" [
        lexerTests
        parserTests
        evalTests
    ]
</code></pre>
<h3 id="실행-1"><a class="header" href="#실행-1">실행</a></h3>
<pre><code class="language-bash"># 전체 테스트
dotnet run --project FunLang.Tests

# 필터링
dotnet run --project FunLang.Tests -- --filter "Lexer"
</code></pre>
<h3 id="주요-expect-함수"><a class="header" href="#주요-expect-함수">주요 Expect 함수</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>함수</th><th>용도</th></tr>
</thead>
<tbody>
<tr><td><code>Expect.equal actual expected msg</code></td><td>동등성</td></tr>
<tr><td><code>Expect.isTrue condition msg</code></td><td>불린</td></tr>
<tr><td><code>Expect.throws&lt;ExnType&gt; (fun () -&gt; ...) msg</code></td><td>예외</td></tr>
<tr><td><code>Expect.isSome option msg</code></td><td>Option 값</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="fscheck-속성-기반-테스트"><a class="header" href="#fscheck-속성-기반-테스트">FsCheck: 속성 기반 테스트</a></h2>
<h3 id="설정"><a class="header" href="#설정">설정</a></h3>
<pre><code class="language-bash">dotnet add package FsCheck
dotnet add package Expecto.FsCheck
</code></pre>
<h3 id="속성-테스트-작성"><a class="header" href="#속성-테스트-작성">속성 테스트 작성</a></h3>
<p>“모든 입력에 대해 이 성질이 유지된다“를 선언한다.</p>
<pre><code class="language-fsharp">open Expecto
open FsCheck

[&lt;Tests&gt;]
let propertyTests =
    testList "Properties" [
        // 숫자는 그대로 평가
        testProperty "number evaluates to itself" &lt;| fun (n: int) -&gt;
            Eval.eval (Ast.Number n) = n

        // 덧셈 교환법칙
        testProperty "addition is commutative" &lt;| fun (a: int) (b: int) -&gt;
            let left = Eval.eval (Ast.Add(Ast.Number a, Ast.Number b))
            let right = Eval.eval (Ast.Add(Ast.Number b, Ast.Number a))
            left = right

        // 0은 덧셈 항등원
        testProperty "zero is additive identity" &lt;| fun (n: int) -&gt;
            Eval.eval (Ast.Add(Ast.Number n, Ast.Number 0)) = n

        // 1은 곱셈 항등원
        testProperty "one is multiplicative identity" &lt;| fun (n: int) -&gt;
            Eval.eval (Ast.Multiply(Ast.Number n, Ast.Number 1)) = n

        // 이중 부정 = 원래 값
        testProperty "double negation is identity" &lt;| fun (n: int) -&gt;
            Eval.eval (Ast.Negate(Ast.Negate(Ast.Number n))) = n
    ]
</code></pre>
<h3 id="조건부-속성"><a class="header" href="#조건부-속성">조건부 속성</a></h3>
<p>특정 조건에서만 성립하는 속성:</p>
<pre><code class="language-fsharp">testProperty "division by non-zero" &lt;| fun (a: int) (b: int) -&gt;
    b &lt;&gt; 0 ==&gt; lazy (
        // 0이 아닐 때만 테스트
        let result = Eval.eval (Ast.Divide(Ast.Number a, Ast.Number b))
        result = a / b
    )
</code></pre>
<h3 id="실패-시-출력"><a class="header" href="#실패-시-출력">실패 시 출력</a></h3>
<p>FsCheck는 실패 시 <strong>최소 반례</strong>를 찾아준다:</p>
<pre><code>Falsifiable, after 42 tests (3 shrinks):
Original: (1073741824, 1073741824)
Shrunk: (1, 2147483647)
</code></pre>
<hr>
<h2 id="examples-11"><a class="header" href="#examples-11">Examples</a></h2>
<h3 id="cli-테스트-추가"><a class="header" href="#cli-테스트-추가">CLI 테스트 추가</a></h3>
<p>새 기능 구현 후 회귀 테스트 추가:</p>
<pre><code class="language-bash"># 1. 실제 출력 확인
$ dotnet run --project FunLang -- --expr "let x = 5 in x + 1"
6

# 2. 테스트 파일 생성
$ cat &gt; tests/variables/01-let-simple.flt &lt;&lt; 'EOF'
// Test: Simple let binding
// --- Command: dotnet run --project FunLang -- --expr "let x = 5 in x + 1"
// --- Output:
6
EOF

# 3. 테스트 실행
$ make -C tests variables
PASS: tests/variables/01-let-simple.flt
Results: 1/1 passed
</code></pre>
<h3 id="전체-테스트-실행"><a class="header" href="#전체-테스트-실행">전체 테스트 실행</a></h3>
<pre><code class="language-bash"># fslit 통합 테스트
$ make -C tests
PASS: tests/cli/01-simple-add.flt
PASS: tests/cli/02-precedence.flt
...
Results: 21/21 passed

# Expecto 단위 테스트
$ dotnet run --project FunLang.Tests
[EXPECTO] 12 tests run - 12 passed, 0 failed

# 모두 통과 확인
</code></pre>
<h3 id="테스트-실패-디버깅"><a class="header" href="#테스트-실패-디버깅">테스트 실패 디버깅</a></h3>
<pre><code class="language-bash"># 토큰 확인
$ dotnet run --project FunLang -- --emit-tokens --expr "2 + 3"
NUMBER(2) PLUS NUMBER(3) EOF

# AST 확인
$ dotnet run --project FunLang -- --emit-ast --expr "2 + 3"
Add (Number 2, Number 3)
</code></pre>
<hr>
<h2 id="테스트-워크플로우"><a class="header" href="#테스트-워크플로우">테스트 워크플로우</a></h2>
<h3 id="개발-중-tdd"><a class="header" href="#개발-중-tdd">개발 중 (TDD)</a></h3>
<pre><code class="language-bash"># 1. 실패하는 테스트 작성
# 2. 구현
# 3. 테스트 통과 확인
dotnet run --project FunLang.Tests -- --filter "NewFeature"
</code></pre>
<h3 id="커밋-전"><a class="header" href="#커밋-전">커밋 전</a></h3>
<pre><code class="language-bash"># 빌드 + 전체 테스트
make -C tests check
dotnet run --project FunLang.Tests
</code></pre>
<h3 id="cicd"><a class="header" href="#cicd">CI/CD</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml
- name: Build
  run: dotnet build

- name: Unit Tests
  run: dotnet run --project FunLang.Tests

- name: Integration Tests
  run: make -C tests
</code></pre>
<hr>
<h2 id="요약-4"><a class="header" href="#요약-4">요약</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>상황</th><th>사용할 도구</th></tr>
</thead>
<tbody>
<tr><td>CLI 동작 검증</td><td>fslit</td></tr>
<tr><td>내부 함수 테스트</td><td>Expecto</td></tr>
<tr><td>수학적 성질 검증</td><td>FsCheck</td></tr>
<tr><td>회귀 방지</td><td>fslit + Expecto</td></tr>
<tr><td>엣지 케이스 발견</td><td>FsCheck</td></tr>
</tbody>
</table>
</div>
<h2 id="관련-문서-12"><a class="header" href="#관련-문서-12">관련 문서</a></h2>
<ul>
<li><a href="../docs/howto/write-fslit-file-tests.html">write-fslit-file-tests</a> — fslit 상세 가이드</li>
<li><a href="../docs/howto/setup-expecto-test-project.html">setup-expecto-test-project</a> — Expecto 프로젝트 설정</li>
<li><a href="../docs/howto/write-fscheck-property-tests.html">write-fscheck-property-tests</a> — FsCheck 속성 테스트</li>
<li><a href="../docs/howto/testing-strategies.html">testing-strategies</a> — 전체 테스트 전략</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-b-comments"><a class="header" href="#appendix-b-comments">Appendix B: Comments</a></h1>
<p>이 부록에서는 FunLang에 주석을 추가한다. 단일행 주석(<code>//</code>)과 중첩 가능한 블록 주석(<code>(* *)</code>)을 구현한다.</p>
<h2 id="개요-13"><a class="header" href="#개요-13">개요</a></h2>
<p>주석은 코드의 가독성을 높이고 문서화에 필수적이다:</p>
<ul>
<li><strong>단일행 주석</strong>: <code>// 이 줄은 무시됨</code></li>
<li><strong>블록 주석</strong>: <code>(* 여러 줄 가능 *)</code></li>
<li><strong>중첩 주석</strong>: <code>(* 외부 (* 내부 *) 외부 *)</code></li>
</ul>
<p>ML 계열 언어(OCaml, F#)의 전통을 따라 블록 주석 중첩을 지원한다.</p>
<h2 id="lexer-구현"><a class="header" href="#lexer-구현">Lexer 구현</a></h2>
<h3 id="단일행-주석"><a class="header" href="#단일행-주석">단일행 주석</a></h3>
<p><code>//</code>로 시작하여 줄 끝까지가 주석이다.</p>
<pre><code class="language-fsharp">// FunLang/Lexer.fsl

rule tokenize = parse
    // ... 다른 규칙들 ...

    // Comments (MUST come before operators to match first)
    | "//" [^ '\n' '\r']* newline  { lexbuf.EndPos &lt;- lexbuf.EndPos.NextLine
                                      tokenize lexbuf }   // 개행 포함
    | "//" [^ '\n' '\r']*          { tokenize lexbuf }   // EOF에서 끝나는 경우
</code></pre>
<p>두 가지 패턴이 필요하다:</p>
<ol>
<li>줄바꿈으로 끝나는 주석 - 위치 추적 업데이트 필요</li>
<li>파일 끝에서 끝나는 주석 - 줄바꿈 없음</li>
</ol>
<h3 id="블록-주석"><a class="header" href="#블록-주석">블록 주석</a></h3>
<p><code>(*</code>로 시작하고 <code>*)</code>로 끝난다. 중첩을 지원하려면 깊이(depth)를 추적해야 한다.</p>
<pre><code class="language-fsharp">rule tokenize = parse
    // ... 다른 규칙들 ...
    | "(*"          { block_comment 1 lexbuf }   // 블록 주석 시작, depth=1

// 블록 주석 핸들러 - 중첩 지원
and block_comment depth = parse
    | "(*"    { block_comment (depth + 1) lexbuf }     // 중첩: depth 증가
    | "*)"    { if depth = 1 then tokenize lexbuf      // 닫기: depth=1이면 복귀
                else block_comment (depth - 1) lexbuf } // 아니면 depth 감소
    | newline { lexbuf.EndPos &lt;- lexbuf.EndPos.NextLine
                block_comment depth lexbuf }           // 줄바꿈 처리
    | eof     { failwith "Unterminated comment" }      // EOF 에러
    | _       { block_comment depth lexbuf }           // 나머지 문자 스킵
</code></pre>
<h2 id="중첩-주석-동작"><a class="header" href="#중첩-주석-동작">중첩 주석 동작</a></h2>
<pre><code>(* depth=1
   (* depth=2
      코드를 임시로 주석 처리
   *) depth=1
   여전히 주석 내부
*) depth=0 → tokenize로 복귀
</code></pre>
<p>중첩 주석의 장점:</p>
<ul>
<li>코드 블록을 임시로 주석 처리할 때 유용</li>
<li>주석 내부에 <code>*)</code> 문자열이 있어도 안전</li>
</ul>
<h2 id="테스트-11"><a class="header" href="#테스트-11">테스트</a></h2>
<h3 id="단일행-주석-1"><a class="header" href="#단일행-주석-1">단일행 주석</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "1 + 2 // 덧셈"
3
</code></pre>
<h3 id="블록-주석-1"><a class="header" href="#블록-주석-1">블록 주석</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "(* 곱셈 *) 3 * 4"
12
</code></pre>
<h3 id="중첩-주석"><a class="header" href="#중첩-주석">중첩 주석</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "(* (* 중첩 *) *) 5"
5
</code></pre>
<h3 id="주석만-있는-경우"><a class="header" href="#주석만-있는-경우">주석만 있는 경우</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr "// 아무것도 없음"
# 파싱 에러 (표현식 없음)
</code></pre>
<h2 id="주의사항"><a class="header" href="#주의사항">주의사항</a></h2>
<h3 id="규칙-순서"><a class="header" href="#규칙-순서">규칙 순서</a></h3>
<p><code>//</code>가 <code>/</code> 보다 먼저 매칭되어야 한다. fslex는 긴 패턴을 먼저 시도하지만, 명시적 순서가 안전하다.</p>
<pre><code class="language-fsharp">// 올바른 순서
| "//"    { ... }  // 먼저
| "/"     { ... }  // 나중

// 잘못된 순서 - "/" 두 개로 인식될 수 있음
| "/"     { ... }
| "//"    { ... }
</code></pre>
<h3 id="eof-처리"><a class="header" href="#eof-처리">EOF 처리</a></h3>
<p>블록 주석이 닫히지 않으면 에러를 발생시킨다:</p>
<pre><code class="language-fsharp">| eof     { failwith "Unterminated comment" }
</code></pre>
<h2 id="요약-5"><a class="header" href="#요약-5">요약</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>주석 유형</th><th>구문</th><th>특징</th></tr>
</thead>
<tbody>
<tr><td>단일행</td><td><code>// ...</code></td><td>줄 끝까지</td></tr>
<tr><td>블록</td><td><code>(* ... *)</code></td><td>여러 줄, 중첩 가능</td></tr>
</tbody>
</table>
</div>
<p><strong>구현 포인트:</strong></p>
<ul>
<li>단일행: 정규식으로 줄 끝까지 매칭</li>
<li>블록: 별도 핸들러 함수로 깊이 추적</li>
<li>줄바꿈 시 위치 정보 업데이트</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-c-strings"><a class="header" href="#appendix-c-strings">Appendix C: Strings</a></h1>
<p>이 부록에서는 FunLang에 문자열 타입을 추가한다. 문자열 리터럴, 이스케이프 시퀀스, 문자열 연산을 구현한다.</p>
<h2 id="개요-14"><a class="header" href="#개요-14">개요</a></h2>
<p>문자열은 실용적인 언어의 필수 기능이다:</p>
<ul>
<li><strong>리터럴</strong>: <code>"hello"</code></li>
<li><strong>이스케이프</strong>: <code>"line1\nline2"</code>, <code>"tab\there"</code></li>
<li><strong>연결</strong>: <code>"hello" + " world"</code></li>
<li><strong>비교</strong>: <code>"abc" = "abc"</code>, <code>"a" &lt; "b"</code></li>
</ul>
<h2 id="ast-확장-7"><a class="header" href="#ast-확장-7">AST 확장</a></h2>
<h3 id="value-타입에-stringvalue-추가"><a class="header" href="#value-타입에-stringvalue-추가">Value 타입에 StringValue 추가</a></h3>
<pre><code class="language-fsharp">// FunLang/Ast.fs

type Value =
    | IntValue of int
    | BoolValue of bool
    | StringValue of string
    | FunctionValue of param: string * body: Expr * closure: Env
    | TupleValue of Value list
    | ListValue of Value list
</code></pre>
<h3 id="expr-타입에-string-추가"><a class="header" href="#expr-타입에-string-추가">Expr 타입에 String 추가</a></h3>
<pre><code class="language-fsharp">type Expr =
    // ... 기존 케이스들 ...
    | String of value: string * span: Span
</code></pre>
<h2 id="lexer-구현-1"><a class="header" href="#lexer-구현-1">Lexer 구현</a></h2>
<h3 id="문자열-리터럴-시작"><a class="header" href="#문자열-리터럴-시작">문자열 리터럴 시작</a></h3>
<p>큰따옴표(<code>"</code>)를 만나면 문자열 읽기 모드로 전환한다.</p>
<pre><code class="language-fsharp">// FunLang/Lexer.fsl

rule tokenize = parse
    // ... 다른 규칙들 ...
    | '"'           { read_string (System.Text.StringBuilder()) lexbuf }
</code></pre>
<h3 id="문자열-읽기-핸들러"><a class="header" href="#문자열-읽기-핸들러">문자열 읽기 핸들러</a></h3>
<p><code>StringBuilder</code>로 문자열을 누적하며 이스케이프를 처리한다.</p>
<pre><code class="language-fsharp">// 문자열 리터럴 핸들러 - 이스케이프 시퀀스 지원
and read_string buf = parse
    | '"'           { STRING (buf.ToString()) }           // 종료
    | "\\n"         { buf.Append('\n') |&gt; ignore          // 개행
                      read_string buf lexbuf }
    | "\\t"         { buf.Append('\t') |&gt; ignore          // 탭
                      read_string buf lexbuf }
    | "\\\\"        { buf.Append('\\') |&gt; ignore          // 백슬래시
                      read_string buf lexbuf }
    | "\\\""        { buf.Append('\"') |&gt; ignore          // 큰따옴표
                      read_string buf lexbuf }
    | newline       { failwith "Newline in string literal" }  // 줄바꿈 에러
    | eof           { failwith "Unterminated string literal" } // EOF 에러
    | _             { buf.Append(lexeme lexbuf) |&gt; ignore
                      read_string buf lexbuf }            // 일반 문자
</code></pre>
<h3 id="지원하는-이스케이프-시퀀스"><a class="header" href="#지원하는-이스케이프-시퀀스">지원하는 이스케이프 시퀀스</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>이스케이프</th><th>문자</th><th>설명</th></tr>
</thead>
<tbody>
<tr><td><code>\n</code></td><td>개행</td><td>줄바꿈</td></tr>
<tr><td><code>\t</code></td><td>탭</td><td>수평 탭</td></tr>
<tr><td><code>\\</code></td><td><code>\</code></td><td>백슬래시</td></tr>
<tr><td><code>\"</code></td><td><code>"</code></td><td>큰따옴표</td></tr>
</tbody>
</table>
</div>
<h2 id="parser-확장-6"><a class="header" href="#parser-확장-6">Parser 확장</a></h2>
<pre><code class="language-fsharp">// FunLang/Parser.fsy

%token &lt;string&gt; STRING

Atom:
    | NUMBER                    { Number ($1, mkSpan parseState 1 1) }
    | TRUE                      { Bool (true, mkSpan parseState 1 1) }
    | FALSE                     { Bool (false, mkSpan parseState 1 1) }
    | STRING                    { String ($1, mkSpan parseState 1 1) }
    | IDENT                     { Var ($1, mkSpan parseState 1 1) }
    // ... 나머지 ...
</code></pre>
<h2 id="eval-확장"><a class="header" href="#eval-확장">Eval 확장</a></h2>
<h3 id="문자열-연산-평가"><a class="header" href="#문자열-연산-평가">문자열 연산 평가</a></h3>
<pre><code class="language-fsharp">// FunLang/Eval.fs

let rec eval (env: Env) (expr: Expr): Value =
    match expr with
    // 리터럴
    | String (s, _) -&gt; StringValue s

    // 연결 (+ 연산자 오버로딩)
    | Add (e1, e2, _) -&gt;
        match eval env e1, eval env e2 with
        | IntValue a, IntValue b -&gt; IntValue (a + b)
        | StringValue a, StringValue b -&gt; StringValue (a + b)
        | _ -&gt; failwith "Type error in addition"

    // 비교
    | Equal (e1, e2, _) -&gt;
        match eval env e1, eval env e2 with
        | IntValue a, IntValue b -&gt; BoolValue (a = b)
        | BoolValue a, BoolValue b -&gt; BoolValue (a = b)
        | StringValue a, StringValue b -&gt; BoolValue (a = b)
        | _ -&gt; failwith "Type error in equality"
</code></pre>
<h3 id="문자열-비교"><a class="header" href="#문자열-비교">문자열 비교</a></h3>
<p>문자열은 사전순(lexicographic) 비교를 지원한다:</p>
<pre><code class="language-fsharp">| LessThan (e1, e2, _) -&gt;
    match eval env e1, eval env e2 with
    | IntValue a, IntValue b -&gt; BoolValue (a &lt; b)
    | StringValue a, StringValue b -&gt; BoolValue (a &lt; b)
    | _ -&gt; failwith "Type error in comparison"
</code></pre>
<h2 id="format-확장"><a class="header" href="#format-확장">Format 확장</a></h2>
<pre><code class="language-fsharp">// FunLang/Format.fs

let formatValue (value: Value): string =
    match value with
    | IntValue n -&gt; string n
    | BoolValue b -&gt; if b then "true" else "false"
    | StringValue s -&gt; sprintf "\"%s\"" (escapeString s)
    | FunctionValue _ -&gt; "&lt;function&gt;"
    | TupleValue vs -&gt; sprintf "(%s)" (String.concat ", " (List.map formatValue vs))
    | ListValue vs -&gt; sprintf "[%s]" (String.concat "; " (List.map formatValue vs))

// 출력 시 이스케이프 복원
let private escapeString (s: string) =
    s.Replace("\\", "\\\\")
     .Replace("\"", "\\\"")
     .Replace("\n", "\\n")
     .Replace("\t", "\\t")
</code></pre>
<h2 id="type-확장"><a class="header" href="#type-확장">Type 확장</a></h2>
<pre><code class="language-fsharp">// FunLang/Type.fs

type Type =
    | TInt
    | TBool
    | TString
    | TArrow of Type * Type
    | TVar of int
    | TTuple of Type list
    | TList of Type
</code></pre>
<h2 id="테스트-12"><a class="header" href="#테스트-12">테스트</a></h2>
<h3 id="기본-리터럴"><a class="header" href="#기본-리터럴">기본 리터럴</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr '"hello"'
"hello"
</code></pre>
<h3 id="이스케이프-시퀀스"><a class="header" href="#이스케이프-시퀀스">이스케이프 시퀀스</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr '"line1\nline2"'
"line1\nline2"

$ dotnet run --project FunLang -- --expr '"tab\there"'
"tab\there"
</code></pre>
<h3 id="문자열-연결"><a class="header" href="#문자열-연결">문자열 연결</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr '"hello" + " " + "world"'
"hello world"
</code></pre>
<h3 id="문자열-비교-1"><a class="header" href="#문자열-비교-1">문자열 비교</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --expr '"abc" = "abc"'
true

$ dotnet run --project FunLang -- --expr '"apple" &lt; "banana"'
true
</code></pre>
<h3 id="타입-추론"><a class="header" href="#타입-추론">타입 추론</a></h3>
<pre><code class="language-bash">$ dotnet run --project FunLang -- --emit-type --expr '"hello"'
string

$ dotnet run --project FunLang -- --emit-type --expr 'fun s -&gt; s + "!"'
string -&gt; string
</code></pre>
<h2 id="제한사항"><a class="header" href="#제한사항">제한사항</a></h2>
<p>현재 구현에서 지원하지 않는 기능:</p>
<ul>
<li>문자열 인덱싱 (<code>s.[0]</code>)</li>
<li>문자열 슬라이싱 (<code>s.[1..3]</code>)</li>
<li>문자열 길이 함수 (Prelude에서 추가 가능)</li>
<li>유니코드 이스케이프 (<code>\uXXXX</code>)</li>
</ul>
<h2 id="요약-6"><a class="header" href="#요약-6">요약</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>구문</th><th>예시</th></tr>
</thead>
<tbody>
<tr><td>리터럴</td><td><code>"..."</code></td><td><code>"hello"</code></td></tr>
<tr><td>이스케이프</td><td><code>\n</code>, <code>\t</code>, <code>\\</code>, <code>\"</code></td><td><code>"line1\nline2"</code></td></tr>
<tr><td>연결</td><td><code>+</code></td><td><code>"a" + "b"</code></td></tr>
<tr><td>비교</td><td><code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td><code>"a" &lt; "b"</code></td></tr>
</tbody>
</table>
</div>
<p><strong>구현 포인트:</strong></p>
<ul>
<li>Lexer: 별도 핸들러로 이스케이프 처리</li>
<li>Eval: <code>+</code> 연산자 오버로딩</li>
<li>Type: <code>TString</code> 타입 추가</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-d-repl"><a class="header" href="#appendix-d-repl">Appendix D: REPL</a></h1>
<p>이 부록에서는 FunLang의 대화형 REPL(Read-Eval-Print Loop)을 구현한다. 환경 스레딩, 에러 복구, 종료 명령을 포함한다.</p>
<h2 id="개요-15"><a class="header" href="#개요-15">개요</a></h2>
<p>REPL은 인터프리터 언어의 핵심 기능이다:</p>
<ul>
<li><strong>즉각적 피드백</strong>: 코드를 입력하면 바로 결과 확인</li>
<li><strong>환경 유지</strong>: 이전에 정의한 변수/함수 사용 가능</li>
<li><strong>에러 복구</strong>: 오류 발생 후에도 계속 사용 가능</li>
<li><strong>대화형 탐색</strong>: 언어 기능을 실험하기 좋음</li>
</ul>
<pre><code>$ dotnet run --project FunLang -- --repl
FunLang REPL
Type '#quit' or Ctrl+D to quit.

funlang&gt; let x = 42
42
funlang&gt; x + 1
43
funlang&gt; #quit
</code></pre>
<h2 id="구현"><a class="header" href="#구현">구현</a></h2>
<h3 id="모듈-구조"><a class="header" href="#모듈-구조">모듈 구조</a></h3>
<pre><code class="language-fsharp">// FunLang/Repl.fs

module Repl

open System
open FSharp.Text.Lexing
open Ast
open Eval

/// Parse a string input and return the AST
let private parse (input: string) : Expr =
    let lexbuf = LexBuffer&lt;char&gt;.FromString input
    Lexer.setInitialPos lexbuf "&lt;repl&gt;"
    Parser.start Lexer.tokenize lexbuf
</code></pre>
<h3 id="repl-루프"><a class="header" href="#repl-루프">REPL 루프</a></h3>
<p>재귀 함수로 환경을 스레딩한다:</p>
<pre><code class="language-fsharp">/// REPL loop with environment threading
let rec private replLoop (env: Env) : unit =
    // 1. 프롬프트 출력
    Console.Write "funlang&gt; "
    Console.Out.Flush()

    // 2. 입력 읽기
    match Console.ReadLine() with
    | null -&gt;
        // EOF (Ctrl+D on Unix, Ctrl+Z on Windows)
        printfn ""

    | "#quit" -&gt;
        // 명시적 종료 명령
        ()

    | "" -&gt;
        // 빈 줄 - 계속
        replLoop env

    | line -&gt;
        // 3. 평가 시도
        try
            let ast = parse line
            let result = eval env ast
            printfn "%s" (formatValue result)
            replLoop env
        with ex -&gt;
            // 4. 에러 복구 - 에러 출력 후 계속
            eprintfn "Error: %s" ex.Message
            replLoop env
</code></pre>
<h3 id="진입점"><a class="header" href="#진입점">진입점</a></h3>
<pre><code class="language-fsharp">/// Start the REPL with welcome message
let startRepl () : int =
    printfn "FunLang REPL"
    printfn "Type '#quit' or Ctrl+D to quit."
    printfn ""
    let initialEnv = Prelude.loadPrelude()  // Prelude 함수들 로드
    replLoop initialEnv
    0  // 종료 코드
</code></pre>
<h2 id="핵심-설계"><a class="header" href="#핵심-설계">핵심 설계</a></h2>
<h3 id="환경-스레딩"><a class="header" href="#환경-스레딩">환경 스레딩</a></h3>
<p>REPL에서 정의한 변수를 다음 입력에서 사용하려면 환경을 유지해야 한다.</p>
<pre><code class="language-fsharp">// 잘못된 방식 - 환경이 유지되지 않음
let rec replLoop () =
    let env = Map.empty  // 매번 새로운 환경
    // ...

// 올바른 방식 - 환경을 인자로 전달
let rec replLoop (env: Env) =
    // env가 누적됨
    // ...
    replLoop env  // 동일한 환경으로 재귀
</code></pre>
<p><strong>현재 구현의 제한:</strong></p>
<ul>
<li><code>let x = 1</code>은 <code>1</code>을 반환하지만 환경에 <code>x</code>를 추가하지 않음</li>
<li>환경을 업데이트하려면 <code>evalToEnv</code> 패턴 필요 (현재 미구현)</li>
</ul>
<h3 id="에러-복구"><a class="header" href="#에러-복구">에러 복구</a></h3>
<p>try-with로 파싱/평가 에러를 잡아서 REPL이 죽지 않게 한다:</p>
<pre><code class="language-fsharp">try
    let ast = parse line
    let result = eval env ast
    printfn "%s" (formatValue result)
    replLoop env
with ex -&gt;
    eprintfn "Error: %s" ex.Message
    replLoop env  // 에러 후에도 계속
</code></pre>
<h3 id="종료-방법"><a class="header" href="#종료-방법">종료 방법</a></h3>
<p>세 가지 종료 방법을 지원한다:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>방법</th><th>동작</th></tr>
</thead>
<tbody>
<tr><td><code>#quit</code></td><td>명시적 종료 명령</td></tr>
<tr><td>Ctrl+D</td><td>EOF 신호 (Unix)</td></tr>
<tr><td>Ctrl+Z</td><td>EOF 신호 (Windows)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-fsharp">match Console.ReadLine() with
| null -&gt;     // EOF - Ctrl+D 또는 Ctrl+Z
    printfn ""
| "#quit" -&gt;  // 명시적 명령
    ()
</code></pre>
<h2 id="cli-통합-3"><a class="header" href="#cli-통합-3">CLI 통합</a></h2>
<h3 id="programfs-2"><a class="header" href="#programfs-2">Program.fs</a></h3>
<pre><code class="language-fsharp">// FunLang/Program.fs

type CliArgs =
    | [&lt;MainCommand&gt;] Expression of expr: string
    | [&lt;AltCommandLine("-e")&gt;] Expr of expr: string
    | Repl
    | Emit_Ast
    | Emit_Type
    | Emit_Tokens

let run (args: ParseResults&lt;CliArgs&gt;) =
    if args.Contains Repl then
        Repl.startRepl()
    else
        // 파일 또는 표현식 평가
        // ...
</code></pre>
<h3 id="사용법"><a class="header" href="#사용법">사용법</a></h3>
<pre><code class="language-bash"># REPL 시작
$ dotnet run --project FunLang -- --repl

# 표현식 평가 (단발성)
$ dotnet run --project FunLang -- --expr "1 + 2"
3
</code></pre>
<h2 id="테스트-13"><a class="header" href="#테스트-13">테스트</a></h2>
<h3 id="기본-동작"><a class="header" href="#기본-동작">기본 동작</a></h3>
<pre><code>funlang&gt; 1 + 2
3
funlang&gt; true &amp;&amp; false
false
funlang&gt; "hello"
"hello"
</code></pre>
<h3 id="prelude-함수"><a class="header" href="#prelude-함수">Prelude 함수</a></h3>
<pre><code>funlang&gt; map (fun x -&gt; x * 2) [1; 2; 3]
[2; 4; 6]
funlang&gt; length [1; 2; 3; 4; 5]
5
</code></pre>
<h3 id="에러-복구-1"><a class="header" href="#에러-복구-1">에러 복구</a></h3>
<pre><code>funlang&gt; 1 / 0
Error: Division by zero
funlang&gt; 1 + true
Error: Type error in addition
funlang&gt; 1 + 2
3
</code></pre>
<h3 id="다중-줄-미지원"><a class="header" href="#다중-줄-미지원">다중 줄 (미지원)</a></h3>
<p>현재는 한 줄씩만 처리한다:</p>
<pre><code>funlang&gt; let f = fun x -&gt;
Error: ...  // 파싱 에러

funlang&gt; let f = fun x -&gt; x + 1 in f 5
6  // 한 줄에 작성하면 동작
</code></pre>
<h2 id="향후-개선"><a class="header" href="#향후-개선">향후 개선</a></h2>
<h3 id="환경-업데이트"><a class="header" href="#환경-업데이트">환경 업데이트</a></h3>
<pre><code class="language-fsharp">// evalToEnv: 환경을 반환하는 eval
let rec evalToEnv (env: Env) (expr: Expr): Env * Value =
    match expr with
    | Let (name, value, body, _) -&gt;
        let v = eval env value
        let newEnv = Map.add name v env
        evalToEnv newEnv body
    | _ -&gt;
        (env, eval env expr)
</code></pre>
<h3 id="다중-줄-입력"><a class="header" href="#다중-줄-입력">다중 줄 입력</a></h3>
<pre><code class="language-fsharp">let rec readMultiLine (acc: string) =
    let line = Console.ReadLine()
    if line.EndsWith(";;") then
        acc + line.[..^2]  // ;; 제거
    else
        readMultiLine (acc + line + "\n")
</code></pre>
<h3 id="히스토리"><a class="header" href="#히스토리">히스토리</a></h3>
<p>ReadLine 라이브러리 사용:</p>
<pre><code class="language-fsharp">// NuGet: ReadLine
ReadLine.HistoryEnabled &lt;- true
let line = ReadLine.Read("funlang&gt; ")
</code></pre>
<h2 id="요약-7"><a class="header" href="#요약-7">요약</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>기능</th><th>구현</th></tr>
</thead>
<tbody>
<tr><td>루프</td><td><code>let rec replLoop (env: Env)</code></td></tr>
<tr><td>환경</td><td>재귀 인자로 스레딩</td></tr>
<tr><td>에러 복구</td><td>try-with로 감싸기</td></tr>
<tr><td>종료</td><td><code>#quit</code>, Ctrl+D, Ctrl+Z</td></tr>
<tr><td>Prelude</td><td><code>loadPrelude()</code>로 초기 환경</td></tr>
</tbody>
</table>
</div>
<p><strong>구현 포인트:</strong></p>
<ul>
<li>재귀 함수로 무한 루프 표현</li>
<li>환경을 인자로 전달하여 상태 유지</li>
<li>에러 발생 시 환경 유지하고 계속</li>
<li>Prelude 함수들을 초기 환경에 로드</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
