%{
open Ast
%}

// Token declarations
%token <int> NUMBER
%token <string> IDENT
%token PLUS MINUS STAR SLASH
%token LPAREN RPAREN
%token LET IN EQUALS
%token TRUE FALSE IF THEN ELSE
%token LT GT LE GE NE
%token AND OR
// Phase 5: Function tokens
%token FUN REC ARROW
%token EOF

// Precedence declarations (lowest to highest)
// %nonassoc for comparisons prevents "1 < 2 < 3" (parse error - avoids type confusion)
%left OR
%left AND
%nonassoc EQUALS LT GT LE GE NE

// Start symbol and its type
%start start
%type <Ast.Expr> start

%%

// Grammar rules
// Keep Term/Factor pattern for arithmetic (already tested and working)
// Use precedence declarations for new operators

start:
    | Expr EOF           { $1 }

Expr:
    // Let expression - lowest precedence
    | LET IDENT EQUALS Expr IN Expr  { Let($2, $4, $6) }
    // If-then-else - low precedence, branches can contain any expression
    | IF Expr THEN Expr ELSE Expr    { If($2, $4, $6) }
    // Phase 5: Function definitions
    | LET REC IDENT IDENT EQUALS Expr IN Expr  { LetRec($3, $4, $6, $8) }
    | FUN IDENT ARROW Expr                     { Lambda($2, $4) }
    // Logical operators (precedence from %left declarations)
    | Expr OR Expr                   { Or($1, $3) }
    | Expr AND Expr                  { And($1, $3) }
    // Comparison operators (precedence from %nonassoc declarations)
    | Expr EQUALS Expr               { Equal($1, $3) }
    | Expr LT Expr                   { LessThan($1, $3) }
    | Expr GT Expr                   { GreaterThan($1, $3) }
    | Expr LE Expr                   { LessEqual($1, $3) }
    | Expr GE Expr                   { GreaterEqual($1, $3) }
    | Expr NE Expr                   { NotEqual($1, $3) }
    // Arithmetic - uses Term/Factor for precedence
    | Expr PLUS Term                 { Add($1, $3) }
    | Expr MINUS Term                { Subtract($1, $3) }
    | Term                           { $1 }

Term:
    | Term STAR Factor   { Multiply($1, $3) }
    | Term SLASH Factor  { Divide($1, $3) }
    | Factor             { $1 }

// Factor: includes unary minus and function application
// Unary minus binds tighter than multiplication but looser than application
Factor:
    | MINUS Factor       { Negate($2) }
    | AppExpr            { $1 }

// Phase 5: Function application (left-associative, highest precedence)
// f 1 2 parses as App(App(f, 1), 2) enabling currying
// Uses Atom to avoid ambiguity: "f -1" is subtraction, "f (-1)" is app with negative
AppExpr:
    | AppExpr Atom       { App($1, $2) }
    | Atom               { $1 }

// Atom: The most basic expressions, no operators
// Used as function arguments in application
Atom:
    | NUMBER             { Number($1) }
    | IDENT              { Var($1) }
    | TRUE               { Bool(true) }
    | FALSE              { Bool(false) }
    | LPAREN Expr RPAREN { $2 }
