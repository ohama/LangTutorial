%{
open Ast
open FSharp.Text.Lexing
open FSharp.Text.Parsing

/// Create span from first symbol's start to last symbol's end
let ruleSpan (parseState: IParseState) (firstSym: int) (lastSym: int) : Span =
    mkSpan (parseState.InputStartPosition firstSym) (parseState.InputEndPosition lastSym)

/// Get span of a single symbol
let symSpan (parseState: IParseState) (n: int) : Span =
    mkSpan (parseState.InputStartPosition n) (parseState.InputEndPosition n)
%}

// Token declarations
%token <int> NUMBER
%token <string> IDENT
%token <string> STRING
%token PLUS MINUS STAR SLASH
%token LPAREN RPAREN
%token LET IN EQUALS
%token TRUE FALSE IF THEN ELSE
%token LT GT LE GE NE
%token AND OR
// Phase 5: Function tokens
%token FUN REC ARROW
// Phase 1 (v3.0): Tuple tokens
%token COMMA
%token UNDERSCORE
// Phase 2 (v3.0): List tokens
%token LBRACKET RBRACKET CONS
// Phase 3 (v3.0): Pattern matching tokens
%token MATCH WITH PIPE
// v6.0: Type annotation tokens
%token COLON
%token TYPE_INT TYPE_BOOL TYPE_STRING TYPE_LIST
%token <string> TYPE_VAR
%token EOF

// Precedence declarations (lowest to highest)
// %nonassoc for comparisons prevents "1 < 2 < 3" (parse error - avoids type confusion)
%left OR
%left AND
%nonassoc EQUALS LT GT LE GE NE
%right CONS    // Right-associative: 1 :: 2 :: [] = 1 :: (2 :: [])

// Start symbol and its type
%start start
%type <Ast.Expr> start

%%

// Grammar rules
// Keep Term/Factor pattern for arithmetic (already tested and working)
// Use precedence declarations for new operators

start:
    | Expr EOF           { $1 }

Expr:
    // Phase 3 (v3.0): Match expression - lowest precedence
    | MATCH Expr WITH MatchClauses   { Match($2, $4, ruleSpan parseState 1 4) }
    // Let expression - lowest precedence
    | LET IDENT EQUALS Expr IN Expr  { Let($2, $4, $6, ruleSpan parseState 1 6) }
    // Phase 1 (v3.0): Let with pattern binding
    | LET TuplePattern EQUALS Expr IN Expr  { LetPat($2, $4, $6, ruleSpan parseState 1 6) }
    // If-then-else - low precedence, branches can contain any expression
    | IF Expr THEN Expr ELSE Expr    { If($2, $4, $6, ruleSpan parseState 1 6) }
    // Phase 5: Function definitions
    | LET REC IDENT IDENT EQUALS Expr IN Expr  { LetRec($3, $4, $6, $8, ruleSpan parseState 1 8) }
    | FUN IDENT ARROW Expr                     { Lambda($2, $4, ruleSpan parseState 1 4) }
    // Logical operators (precedence from %left declarations)
    | Expr OR Expr                   { Or($1, $3, ruleSpan parseState 1 3) }
    | Expr AND Expr                  { And($1, $3, ruleSpan parseState 1 3) }
    // Comparison operators (precedence from %nonassoc declarations)
    | Expr EQUALS Expr               { Equal($1, $3, ruleSpan parseState 1 3) }
    | Expr LT Expr                   { LessThan($1, $3, ruleSpan parseState 1 3) }
    | Expr GT Expr                   { GreaterThan($1, $3, ruleSpan parseState 1 3) }
    | Expr LE Expr                   { LessEqual($1, $3, ruleSpan parseState 1 3) }
    | Expr GE Expr                   { GreaterEqual($1, $3, ruleSpan parseState 1 3) }
    | Expr NE Expr                   { NotEqual($1, $3, ruleSpan parseState 1 3) }
    // Phase 2 (v3.0): Cons operator (lower precedence than arithmetic)
    | Expr CONS Expr                 { Cons($1, $3, ruleSpan parseState 1 3) }
    // Arithmetic - uses Term/Factor for precedence
    | Expr PLUS Term                 { Add($1, $3, ruleSpan parseState 1 3) }
    | Expr MINUS Term                { Subtract($1, $3, ruleSpan parseState 1 3) }
    | Term                           { $1 }

Term:
    | Term STAR Factor   { Multiply($1, $3, ruleSpan parseState 1 3) }
    | Term SLASH Factor  { Divide($1, $3, ruleSpan parseState 1 3) }
    | Factor             { $1 }

// Factor: includes unary minus and function application
// Unary minus binds tighter than multiplication but looser than application
Factor:
    | MINUS Factor       { Negate($2, ruleSpan parseState 1 2) }
    | AppExpr            { $1 }

// Phase 5: Function application (left-associative, highest precedence)
// f 1 2 parses as App(App(f, 1), 2) enabling currying
// Uses Atom to avoid ambiguity: "f -1" is subtraction, "f (-1)" is app with negative
AppExpr:
    | AppExpr Atom       { App($1, $2, ruleSpan parseState 1 2) }
    | Atom               { $1 }

// Atom: The most basic expressions, no operators
// Used as function arguments in application
Atom:
    | NUMBER             { Number($1, symSpan parseState 1) }
    | IDENT              { Var($1, symSpan parseState 1) }
    | TRUE               { Bool(true, symSpan parseState 1) }
    | FALSE              { Bool(false, symSpan parseState 1) }
    | STRING             { String($1, symSpan parseState 1) }
    | LPAREN Expr RPAREN { $2 }  // Preserve inner expr's span
    // v6.0: Annotated expression - (e : T)
    | LPAREN Expr COLON TypeExpr RPAREN  { Annot($2, $4, ruleSpan parseState 1 5) }
    // Phase 1 (v3.0): Tuple expressions - (e1, e2, ...)
    | LPAREN Expr COMMA ExprList RPAREN  { Tuple($2 :: $4, ruleSpan parseState 1 5) }
    // Phase 2 (v3.0): List literals
    | LBRACKET RBRACKET                      { EmptyList(ruleSpan parseState 1 2) }
    | LBRACKET Expr RBRACKET                 { List([$2], ruleSpan parseState 1 3) }
    | LBRACKET Expr COMMA ExprList RBRACKET  { List($2 :: $4, ruleSpan parseState 1 5) }

// Phase 1 (v3.0): Comma-separated expression list for tuples
ExprList:
    | Expr                        { [$1] }
    | Expr COMMA ExprList         { $1 :: $3 }

// Phase 1 (v3.0): Tuple pattern for let bindings
TuplePattern:
    | LPAREN PatternList RPAREN   { TuplePat($2, ruleSpan parseState 1 3) }

PatternList:
    | Pattern COMMA Pattern       { [$1; $3] }
    | Pattern COMMA PatternList   { $1 :: $3 }

Pattern:
    | LPAREN PatternList RPAREN   { TuplePat($2, ruleSpan parseState 1 3) }
    | IDENT                       { VarPat($1, symSpan parseState 1) }
    | UNDERSCORE                  { WildcardPat(symSpan parseState 1) }
    // Phase 3 (v3.0): Extended patterns for match expressions
    | NUMBER                      { ConstPat(IntConst($1), symSpan parseState 1) }
    | TRUE                        { ConstPat(BoolConst(true), symSpan parseState 1) }
    | FALSE                       { ConstPat(BoolConst(false), symSpan parseState 1) }
    | LBRACKET RBRACKET           { EmptyListPat(ruleSpan parseState 1 2) }
    | Pattern CONS Pattern        { ConsPat($1, $3, ruleSpan parseState 1 3) }

// Phase 3 (v3.0): Match clauses (non-empty, requires leading PIPE)
MatchClauses:
    | PIPE Pattern ARROW Expr                { [($2, $4)] }
    | PIPE Pattern ARROW Expr MatchClauses   { ($2, $4) :: $5 }

// v6.0: Type expression grammar
// Precedence via grammar structure (not %left/%right):
//   Arrow (lowest) -> Tuple -> Atomic (highest)

TypeExpr:
    | ArrowType                     { $1 }

// Arrow is right-associative: int -> int -> int = int -> (int -> int)
ArrowType:
    | TupleType ARROW ArrowType     { TEArrow($1, $3) }
    | TupleType                     { $1 }

// Tuple types: int * bool * string (at least 2 elements)
TupleType:
    | AtomicType STAR TupleTypeList { TETuple($1 :: $3) }
    | AtomicType                    { $1 }

TupleTypeList:
    | AtomicType STAR TupleTypeList { $1 :: $3 }
    | AtomicType                    { [$1] }

// Atomic types: base types, type variables, list types, parenthesized
AtomicType:
    | TYPE_INT                      { TEInt }
    | TYPE_BOOL                     { TEBool }
    | TYPE_STRING                   { TEString }
    | TYPE_VAR                      { TEVar($1) }
    | AtomicType TYPE_LIST          { TEList($1) }
    | LPAREN TypeExpr RPAREN        { $2 }
