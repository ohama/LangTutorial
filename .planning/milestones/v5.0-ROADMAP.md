# Milestone v5.0: 타입 에러 진단

**Status:** SHIPPED 2026-02-03
**Phases:** 1-4
**Total Plans:** 7

## Overview

Transform v4.0's basic type errors into precise diagnostics with location tracking, context awareness, and helpful messages. Build Span infrastructure to track source locations, define rich Diagnostic types with context stacks and unification traces, integrate blame assignment into Algorithm W, and render user-friendly error messages with type pretty-printing.

## Phases

### Phase 1: Span Infrastructure

**Goal**: Source location tracking across lexer, parser, and AST
**Depends on**: Nothing (foundation for all diagnostics)
**Requirements**: SPAN-01, SPAN-02, SPAN-03, SPAN-04
**Plans**: 2 plans

Plans:
- [x] 01-01-PLAN.md — Span type definition + Lexer position tracking
- [x] 01-02-PLAN.md — AST span integration + Parser propagation

**Success Criteria**:
1. Every Expr node carries span information (file, start/end line and column)
2. Lexer generates position data for every token
3. Parser propagates spans from tokens to AST nodes
4. Span type can represent unknown locations for built-in definitions

### Phase 2: Error Representation

**Goal**: Rich diagnostic types with context stacks and unification traces
**Depends on**: Phase 1 (needs Span)
**Requirements**: DIAG-01, DIAG-02, DIAG-03, DIAG-04, CTX-01, CTX-02, CTX-03, TRACE-01, TRACE-02, TRACE-03
**Plans**: 2 plans

Plans:
- [x] 02-01-PLAN.md — Diagnostic types definition (Diagnostic, TypeError, InferContext, UnifyPath)
- [x] 02-02-PLAN.md — Integration into Unify.fs and Infer.fs with context/trace threading

**Success Criteria**:
1. Diagnostic type represents errors with code, message, spans, notes, and hints
2. TypeError captures kind (UnifyMismatch, OccursCheck, UnboundVar, NotAFunction), expected/actual types, and term
3. InferContext tracks inference path (InIfCond, InAppFun, InLetRhs, etc.)
4. UnifyPath records structural failure location (AtFunctionReturn, AtTupleIndex, etc.)
5. TypeError includes context stack and unification trace

### Phase 3: Blame Assignment

**Goal**: Accurate error location selection integrated with Algorithm W
**Depends on**: Phase 2 (needs error representation)
**Requirements**: BLAME-01, BLAME-02, BLAME-03
**Plans**: 1 plan

Plans:
- [x] 03-01-PLAN.md — Secondary span extraction from context stack

**Success Criteria**:
1. Primary span points to the most direct cause of the error
2. Secondary spans highlight related expressions contributing to the error
3. Innermost expressions are prioritized for blame assignment
4. Type inference functions maintain context stack during recursion

### Phase 4: Output & Testing

**Goal**: User-friendly error messages and comprehensive diagnostic tests
**Depends on**: Phase 3 (needs blame assignment)
**Requirements**: OUT-01, OUT-02, OUT-03, OUT-04, TEST-01, TEST-02, TEST-03, TEST-04, TEST-05, TEST-06
**Plans**: 2 plans

Plans:
- [x] 04-01-PLAN.md — Formatting functions (formatTypeNormalized, formatDiagnostic)
- [x] 04-02-PLAN.md — CLI integration and golden tests (12 test files)

**Success Criteria**:
1. Error codes follow defined schema (E0301, etc.)
2. Error messages show location, expected/actual types, context summary, and hints
3. Type variables are normalized to a,b,c format in output
4. CLI displays new error format when type checking fails
5. Tests cover if-condition type errors, non-function calls, argument mismatches, let RHS errors, and occurs check
6. Golden test framework validates diagnostic output format

---

## Milestone Summary

**Key Decisions:**

| Phase | Decision | Rationale | Impact |
|-------|----------|-----------|--------|
| 01-01 | Use NextLine property instead of AsNewLinePos() | AsNewLinePos() deprecated, NextLine is modern API | Cleaner code, no deprecation warnings |
| 01-01 | Track position in all three newline contexts | Comments can span multiple lines, need accurate tracking | Complete position accuracy for error messages |
| 01-01 | Use 1-based indexing for line/column | Matches FsLexYacc Position API convention | Consistent with F# compiler error format |
| 01-02 | Span as LAST named parameter | F# DU convention, enables pattern matching with _ | Clean pattern matching in all consumers |
| 01-02 | Use parseState.InputStartPosition/InputEndPosition | FsYacc standard API for position tracking | Accurate span from parser rules |
| 02-01 | SecondarySpans initialized empty | Phase 3 (Blame Assignment) will populate with related expression locations | typeErrorToDiagnostic returns empty SecondarySpans list |
| 02-01 | Error codes E0301-E0304 | Unique codes for UnifyMismatch, OccursCheck, UnboundVar, NotAFunction | Users can reference specific error types in documentation |
| 02-01 | Context stack and trace stored inner-first | Natural for pushing during inference, reversed for display | formatContextStack and formatTrace reverse before formatting |
| 02-02 | unifyWithContext threads context and trace | Build UnifyPath as descending into type structure for structural failure location | AtFunctionParam, AtFunctionReturn, AtTupleIndex, AtListElement track position within types |
| 02-02 | inferWithContext maintains context stack | Push InferContext before recursing for all expression types requiring recursion | Provides inference path showing where in code type checking occurred |
| 02-02 | Backward-compatible wrapper functions | unify and infer call new functions with empty context | Existing code continues to work without changes |
| 02-02 | TypeCheck dual API | typecheck (string-based) and typecheckWithDiagnostic (Diagnostic-based) | Backward compatibility + rich error access for future phases |
| 03-01 | Secondary spans processed outer-to-inner | Matches formatContextStack display order, more intuitive for users | Consistent context navigation |
| 03-01 | Primary span excluded from secondary spans | Avoid duplication in diagnostic display | Cleaner error output |
| 03-01 | Secondary spans limited to 3 | Research pattern: avoid clutter while showing relevant context | Focused, actionable diagnostics |
| 04-01 | Normalized variables use first-appearance order | Consistent 'a, 'b, 'c naming regardless of internal TVar indices | User-friendly type display |
| 04-01 | Diagnostic format follows Rust-style | error[CODE]: message -> location = context | Modern, familiar format |
| 04-02 | NotAFunction detection in App case | Detect non-function types before unification for clearer E0304 messages | Better error messaging for function application |
| 04-02 | Tests use --expr for predictable filename | File input produces temp paths in diagnostics | Stable golden test output |

**Issues Resolved:**
- Position record required pos_orig_lnum field (documented fix in 01-01)
- Assignment returns unit issue in comment rules (added semicolon)
- EmptyList and WildcardPat changed from constants to cases with span
- String/tuple equality tests failing (pre-existing design issue, not v5.0 scope)

**Technical Debt Incurred:**
- String/tuple operators supported in evaluator but rejected by type checker (pre-v5.0 issue)

---

*Archived: 2026-02-03 as part of v5.0 milestone completion*
*For current project status, see .planning/ROADMAP.md (created for next milestone)*
