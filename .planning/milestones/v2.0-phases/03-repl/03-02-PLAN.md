---
phase: 03-repl
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - FunLang/Repl.fs
  - FunLang/FunLang.fsproj
  - FunLang/Program.fs
  - FunLang.Tests/ReplTests.fs
  - FunLang.Tests/FunLang.Tests.fsproj
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can start REPL with funlang --repl"
    - "User sees welcome message with version and exit instructions"
    - "User sees funlang> prompt"
    - "User can evaluate expressions and see results"
    - "Errors show message but REPL continues"
    - "Ctrl+D (EOF) exits cleanly"
    - "exit command exits cleanly"
    - "Empty lines are handled gracefully"
  artifacts:
    - path: "FunLang/Repl.fs"
      provides: "REPL loop implementation"
      exports: ["startRepl"]
      min_lines: 25
    - path: "FunLang.Tests/ReplTests.fs"
      provides: "REPL unit tests"
      contains: "testList"
  key_links:
    - from: "FunLang/Program.fs"
      to: "FunLang/Repl.fs"
      via: "Repl.startRepl()"
      pattern: "Repl\\.startRepl"
    - from: "FunLang/Repl.fs"
      to: "FunLang/Eval.fs"
      via: "eval function"
      pattern: "eval.*env"
---

<objective>
Implement interactive REPL with environment persistence and error recovery

Purpose: Provide an interactive shell for evaluating FunLang expressions, making the language more accessible for exploration and learning
Output: Working REPL that can be invoked with `funlang --repl` or `funlang` (no args)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-repl/03-RESEARCH.md
@.planning/phases/03-repl/03-01-SUMMARY.md

@FunLang/Program.fs
@FunLang/Eval.fs
@FunLang/Cli.fs
@FunLang/FunLang.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Repl.fs module with REPL loop</name>
  <files>FunLang/Repl.fs, FunLang/FunLang.fsproj</files>
  <action>
1. Add Repl.fs to FunLang.fsproj compile order (AFTER Eval.fs, BEFORE Cli.fs):
   ```xml
   <!-- 8. REPL implementation (uses Eval) -->
   <Compile Include="Repl.fs" />

   <!-- 9. CLI argument parsing (uses Argu) -->
   <Compile Include="Cli.fs" />
   ```

2. Create FunLang/Repl.fs with complete REPL implementation:

```fsharp
module Repl

open System
open FSharp.Text.Lexing
open Ast
open Eval

/// Parse a string input and return the AST
let private parse (input: string) : Expr =
    let lexbuf = LexBuffer<char>.FromString input
    Parser.start Lexer.tokenize lexbuf

/// REPL loop with environment threading
/// - env: Current environment (accumulates let bindings if we add that feature)
/// - Returns unit when user exits
let rec private replLoop (env: Env) : unit =
    // Print prompt and flush to ensure it appears before input
    Console.Write "funlang> "
    Console.Out.Flush()

    match Console.ReadLine() with
    | null ->
        // EOF (Ctrl+D on Unix, Ctrl+Z on Windows)
        printfn ""  // Newline for clean exit
    | "exit" ->
        // Explicit exit command
        ()
    | "" ->
        // Empty line - just continue
        replLoop env
    | line ->
        try
            let ast = parse line
            let result = eval env ast
            printfn "%s" (formatValue result)
            // Currently env doesn't change because let requires in-body
            // Future: could extract top-level let bindings
            replLoop env
        with ex ->
            // Error recovery - print error, continue with same env
            eprintfn "Error: %s" ex.Message
            replLoop env

/// Start the REPL with welcome message
let startRepl () : int =
    printfn "FunLang REPL v2.0"
    printfn "Type 'exit' or Ctrl+D to quit."
    printfn ""
    replLoop emptyEnv
    0  // Exit code
```

NOTE on environment persistence: Current FunLang requires `let x = 5 in body`. The environment doesn't persist between inputs because each expression is self-contained. This is correct behavior. Future enhancement could add statement-level `let` without `in`.

NOTE on parse duplication: The parse function is duplicated from Program.fs. This is intentional to keep Repl.fs self-contained. Could be extracted to a shared module in future refactoring.
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang
```
Build should succeed with Repl.fs compiled.
  </verify>
  <done>
- Repl.fs exists with startRepl function
- FunLang.fsproj includes Repl.fs in correct compile order
- Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire REPL into Program.fs and add no-args behavior</name>
  <files>FunLang/Program.fs</files>
  <action>
Update Program.fs to:
1. Open Repl module
2. Replace placeholder startRepl() with Repl.startRepl()
3. When no arguments provided, start REPL (not show usage)

Changes needed:
1. Add `open Repl` at top (or just call `Repl.startRepl()`)
2. In the Repl case: `Repl.startRepl()`
3. In the "no arguments" else branch at bottom: Start REPL instead of showing usage

```fsharp
// Change from:
elif results.Contains Repl then
    startRepl()

// To:
elif results.Contains Repl then
    Repl.startRepl()

// And change the no-args case from:
else
    printfn "%s" (parser.PrintUsage())
    0

// To:
else
    // No arguments - start REPL
    Repl.startRepl()
```

Also remove the local startRepl placeholder function that was added in Plan 01.
  </action>
  <verify>
Test REPL manually:
```bash
cd /home/shoh/vibe-coding/LangTutorial

# With --repl flag
echo -e "2 + 3\nexit" | dotnet run --project FunLang -- --repl

# With no arguments (should also start REPL)
echo -e "2 + 3\nexit" | dotnet run --project FunLang
```

Expected output for both:
```
FunLang REPL v2.0
Type 'exit' or Ctrl+D to quit.

funlang> 5
funlang>
```
  </verify>
  <done>
- --repl flag starts actual REPL
- No arguments starts REPL
- Welcome message displays
- Prompt displays
- Expressions evaluate correctly
- exit command works
  </done>
</task>

<task type="auto">
  <name>Task 3: Add REPL and CLI tests</name>
  <files>FunLang.Tests/ReplTests.fs, FunLang.Tests/FunLang.Tests.fsproj, tests/repl.fslit</files>
  <action>
1. Add ReplTests.fs to FunLang.Tests.fsproj (BEFORE Program.fs):
   ```xml
   <Compile Include="ReplTests.fs" />
   ```

2. Create FunLang.Tests/ReplTests.fs with REPL and CLI tests:

```fsharp
module ReplTests

open Expecto
open Eval
open Ast

/// Test the core evaluation that REPL uses
[<Tests>]
let replEvalTests =
    testList "REPL evaluation" [
        testCase "evaluates arithmetic" <| fun _ ->
            let result = evalExpr (Add (Number 2, Number 3))
            Expect.equal result (IntValue 5) "2 + 3 = 5"

        testCase "evaluates strings" <| fun _ ->
            let result = evalExpr (String "hello")
            Expect.equal result (StringValue "hello") "string literal"

        testCase "evaluates let expressions" <| fun _ ->
            let expr = Let ("x", Number 5, Add (Var "x", Number 3))
            let result = evalExpr expr
            Expect.equal result (IntValue 8) "let x = 5 in x + 3"

        testCase "error on undefined variable" <| fun _ ->
            Expect.throws (fun () -> evalExpr (Var "undefined") |> ignore)
                "undefined variable should throw"

        testCase "error recovery preserves environment" <| fun _ ->
            // This tests the concept - env doesn't change on error
            let env = Map.add "x" (IntValue 10) emptyEnv
            let result = eval env (Var "x")
            Expect.equal result (IntValue 10) "env preserved after error"
    ]

/// Test CLI argument parsing
[<Tests>]
let cliTests =
    testList "CLI arguments" [
        testCase "--expr evaluates expression" <| fun _ ->
            // This is tested by fslit, but good to have unit test too
            let result = evalExpr (Number 42)
            Expect.equal result (IntValue 42) "basic evaluation"

        testCase "formatValue works for all types" <| fun _ ->
            Expect.equal (formatValue (IntValue 42)) "42" "int"
            Expect.equal (formatValue (BoolValue true)) "true" "bool true"
            Expect.equal (formatValue (BoolValue false)) "false" "bool false"
            Expect.equal (formatValue (StringValue "hi")) "\"hi\"" "string"
            let fn = FunctionValue ("x", Var "x", Map.empty)
            Expect.equal (formatValue fn) "<function>" "function"
    ]
```

3. Create tests/repl.fslit with CLI integration tests:

```markdown
# REPL CLI Tests

## --repl flag is recognized

$ funlang --repl < /dev/null
FunLang REPL v2.0
Type 'exit' or Ctrl+D to quit.

funlang>

## -e alias works

$ funlang -e "2 + 3"
5

## --help shows repl option

$ funlang --help
USAGE: funlang [--help] [--expr <expression>] [--emit-tokens] [--emit-ast] [--emit-type] [--repl]
               [<filename>]

OPTIONS:

    --expr, -e <expression>
                          evaluate expression
    --emit-tokens         show lexer tokens
    --emit-ast            show parsed AST
    --emit-type           show inferred types (reserved)
    --repl                start interactive REPL
    --help                display this list of options.

```

NOTE: The exact --help output format is generated by Argu. After running once, update the expected output in fslit to match actual Argu output.
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial

# Run Expecto tests
dotnet run --project FunLang.Tests

# Run fslit tests
make -C tests
```
  </verify>
  <done>
- ReplTests.fs exists with REPL evaluation tests
- repl.fslit exists with CLI integration tests
- All new tests pass
- Existing tests still pass
  </done>
</task>

</tasks>

<verification>
Complete test verification:
```bash
cd /home/shoh/vibe-coding/LangTutorial

# All tests must pass
make -C tests
dotnet run --project FunLang.Tests
```

Manual REPL testing:
```bash
# Start REPL and test interactively
dotnet run --project FunLang -- --repl
# Then type:
#   2 + 3          -> 5
#   "hello"        -> "hello"
#   let x = 5 in x * 2  -> 10
#   undefined      -> Error: Undefined variable: undefined
#   2 + 3          -> 5 (still works after error)
#   exit           -> exits

# Test EOF handling
echo "1 + 1" | dotnet run --project FunLang -- --repl
# Should show welcome, prompt, result, then clean exit on EOF
```
</verification>

<success_criteria>
1. `funlang --repl` starts REPL
2. `funlang` (no args) starts REPL
3. Welcome message shows version and exit instructions
4. `funlang> ` prompt appears
5. Expressions evaluate correctly
6. Errors show message, REPL continues
7. `exit` command exits
8. Ctrl+D (EOF) exits cleanly
9. Empty lines don't crash
10. All 93+ fslit tests pass
11. All 168+ Expecto tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-repl/03-02-SUMMARY.md`
</output>
