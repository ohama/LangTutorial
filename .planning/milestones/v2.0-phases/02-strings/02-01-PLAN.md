---
phase: 02-strings
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Ast.fs
  - FunLang/Lexer.fsl
  - FunLang/Parser.fsy
  - FunLang/Eval.fs
  - FunLang/Format.fs
  - tests/strings/
  - tests/Makefile
  - FunLang.Tests/Program.fs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can write string literals like \"hello\""
    - "User can use escape sequences \\n, \\t, \\\\, \\\""
    - "User can concatenate strings with +"
    - "User can compare strings with = and <>"
    - "Unterminated strings produce clear error"
    - "Mixed type operations (string + int) produce type error"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "String expr and StringValue types"
      contains: "| String of string"
    - path: "FunLang/Lexer.fsl"
      provides: "STRING token and read_string state machine"
      contains: "and read_string"
    - path: "FunLang/Parser.fsy"
      provides: "STRING token declaration and Atom rule"
      contains: "%token <string> STRING"
    - path: "FunLang/Eval.fs"
      provides: "String evaluation and extended operators"
      contains: "| StringValue"
    - path: "FunLang/Format.fs"
      provides: "StringValue formatting"
      contains: "| StringValue"
    - path: "tests/strings/"
      provides: "fslit tests for string functionality"
      min_files: 12
  key_links:
    - from: "FunLang/Lexer.fsl"
      to: "Parser.STRING"
      via: "STRING token emission"
      pattern: "STRING \\(buf\\.ToString\\(\\)\\)"
    - from: "FunLang/Parser.fsy"
      to: "Ast.String"
      via: "Atom rule"
      pattern: "STRING.*\\{ String\\(\\$1\\) \\}"
    - from: "FunLang/Eval.fs"
      to: "Ast.StringValue"
      via: "String expr evaluation"
      pattern: "\\| String s -> StringValue s"
---

<objective>
Add string data type support to FunLang

Purpose: Enable string literals, escape sequences, concatenation, and comparison for practical programming
Output: Working string type with full pipeline integration (lexer -> parser -> AST -> eval -> format)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/02-strings/02-RESEARCH.md

# Existing implementation patterns
@FunLang/Ast.fs
@FunLang/Lexer.fsl
@FunLang/Parser.fsy
@FunLang/Eval.fs
@FunLang/Format.fs
@TESTING.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add String AST, Lexer, and Parser support</name>
  <files>
    FunLang/Ast.fs
    FunLang/Lexer.fsl
    FunLang/Parser.fsy
  </files>
  <action>
    **Ast.fs:**
    1. Add `| String of string` case to `Expr` type (after Bool)
    2. Add `| StringValue of string` case to `Value` type (after FunctionValue)

    **Parser.fsy (BEFORE Lexer.fsl - build order requirement):**
    1. Add `%token <string> STRING` to token declarations (after IDENT line)
    2. Add `| STRING { String($1) }` to Atom rule (after FALSE line)

    **Lexer.fsl:**
    1. Add string entry point in tokenize rule (BEFORE single-char operators):
       ```
       | '"'    { read_string (System.Text.StringBuilder()) lexbuf }
       ```
    2. Add `and read_string` state machine at end of file (after block_comment):
       ```
       // String literal handler with escape sequences
       and read_string (buf: System.Text.StringBuilder) = parse
           | '"'                        { STRING (buf.ToString()) }
           // Escape sequences - MUST come before generic char matcher
           | '\\' 'n'                   { buf.Append('\n') |> ignore; read_string buf lexbuf }
           | '\\' 't'                   { buf.Append('\t') |> ignore; read_string buf lexbuf }
           | '\\' '\\'                  { buf.Append('\\') |> ignore; read_string buf lexbuf }
           | '\\' '"'                   { buf.Append('"') |> ignore; read_string buf lexbuf }
           // Normal characters (excluding quote, backslash, newline)
           | [^ '"' '\\' '\n' '\r']+    { buf.Append(lexeme lexbuf) |> ignore; read_string buf lexbuf }
           // Error cases
           | '\n' | '\r' | "\r\n"       { failwith "Newline in string literal" }
           | eof                        { failwith "Unterminated string literal" }
           | _                          { failwithf "Invalid character in string: %s" (lexeme lexbuf) }
       ```

    **Critical order:**
    - Escape sequence rules (`'\\' 'n'` etc.) BEFORE generic char matcher
    - Newline/EOF error rules BEFORE catch-all `_`
    - String entry point `'"'` BEFORE comment rules (after keywords, before multi-char operators)
  </action>
  <verify>
    ```bash
    dotnet build FunLang/FunLang.fsproj
    # Should compile without errors
    # No "undefined STRING" errors
    ```
  </verify>
  <done>
    - String/StringValue in AST compiles
    - STRING token declared in Parser.fsy
    - read_string state machine in Lexer.fsl
    - Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Add String evaluation and formatting</name>
  <files>
    FunLang/Eval.fs
    FunLang/Format.fs
  </files>
  <action>
    **Eval.fs:**
    1. Add String literal evaluation (after Bool case):
       ```fsharp
       | String s -> StringValue s
       ```

    2. Extend Add operation to support string concatenation:
       ```fsharp
       | Add (left, right) ->
           match eval env left, eval env right with
           | IntValue l, IntValue r -> IntValue (l + r)
           | StringValue l, StringValue r -> StringValue (l + r)    // NEW
           | _ -> failwith "Type error: + requires operands of same type (int or string)"
       ```

    3. Extend Equal operation to support string comparison:
       ```fsharp
       | Equal (left, right) ->
           match eval env left, eval env right with
           | IntValue l, IntValue r -> BoolValue (l = r)
           | BoolValue l, BoolValue r -> BoolValue (l = r)
           | StringValue l, StringValue r -> BoolValue (l = r)    // NEW
           | _ -> failwith "Type error: = requires operands of same type"
       ```

    4. Extend NotEqual operation to support string comparison:
       ```fsharp
       | NotEqual (left, right) ->
           match eval env left, eval env right with
           | IntValue l, IntValue r -> BoolValue (l <> r)
           | BoolValue l, BoolValue r -> BoolValue (l <> r)
           | StringValue l, StringValue r -> BoolValue (l <> r)    // NEW
           | _ -> failwith "Type error: <> requires operands of same type"
       ```

    5. Update formatValue to handle StringValue (with quotes for output):
       ```fsharp
       let formatValue (v: Value) : string =
           match v with
           | IntValue n -> string n
           | BoolValue b -> if b then "true" else "false"
           | FunctionValue _ -> "<function>"
           | StringValue s -> sprintf "\"%s\"" s    // NEW: quoted output
       ```

    **Format.fs:**
    1. Add STRING token formatting in formatToken:
       ```fsharp
       | Parser.STRING s -> sprintf "STRING(%s)" s
       ```
       Add after the existing token cases (before EOF).
  </action>
  <verify>
    ```bash
    dotnet build FunLang/FunLang.fsproj
    dotnet run --project FunLang -- --expr '"hello"'
    # Expected: "hello"

    dotnet run --project FunLang -- --expr '"a" + "b"'
    # Expected: "ab"

    dotnet run --project FunLang -- --expr '"test" = "test"'
    # Expected: true
    ```
  </verify>
  <done>
    - String literal `"hello"` evaluates to StringValue "hello"
    - String concatenation `"a" + "b"` returns `"ab"`
    - String comparison `"a" = "a"` returns true
    - formatValue returns quoted strings
    - formatToken handles STRING token
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests</name>
  <files>
    tests/strings/
    tests/Makefile
    FunLang.Tests/Program.fs
  </files>
  <action>
    **Create tests/strings/ directory with fslit tests (15 files):**

    1. `01-simple-string.flt` - Basic string literal
       ```
       // Simple string literal
       // --- Command: dotnet run --project FunLang -- %input
       // --- Input:
       "hello"
       // --- Output:
       "hello"
       ```

    2. `02-empty-string.flt` - Empty string (STR-09)
       ```
       // Empty string literal
       // --- Command: dotnet run --project FunLang -- %input
       // --- Input:
       ""
       // --- Output:
       ""
       ```

    3. `03-escape-newline.flt` - Escape \n (STR-04)
       ```
       // Newline escape sequence
       // --- Command: dotnet run --project FunLang -- --emit-tokens %input
       // --- Input:
       "a\nb"
       // --- Output:
       STRING(a
       b) EOF
       ```

    4. `04-escape-tab.flt` - Escape \t (STR-05)
       ```
       // Tab escape sequence
       // --- Command: dotnet run --project FunLang -- --emit-tokens %input
       // --- Input:
       "a\tb"
       // --- Output:
       STRING(a	b) EOF
       ```

    5. `05-escape-backslash.flt` - Escape \\ (STR-02)
       ```
       // Backslash escape sequence
       // --- Command: dotnet run --project FunLang -- %input
       // --- Input:
       "a\\b"
       // --- Output:
       "a\b"
       ```

    6. `06-escape-quote.flt` - Escape \" (STR-03)
       ```
       // Quote escape sequence
       // --- Command: dotnet run --project FunLang -- %input
       // --- Input:
       "say \"hi\""
       // --- Output:
       "say "hi""
       ```

    7. `07-concat-strings.flt` - String concatenation (STR-06)
       ```
       // String concatenation
       // --- Command: dotnet run --project FunLang -- %input
       // --- Input:
       "hello" + " " + "world"
       // --- Output:
       "hello world"
       ```

    8. `08-concat-empty.flt` - Concatenate with empty string
       ```
       // Concatenate with empty string
       // --- Command: dotnet run --project FunLang -- %input
       // --- Input:
       "" + "text"
       // --- Output:
       "text"
       ```

    9. `09-equal-true.flt` - String equality true (STR-07)
       ```
       // String equality - true
       // --- Command: dotnet run --project FunLang -- %input
       // --- Input:
       "abc" = "abc"
       // --- Output:
       true
       ```

    10. `10-equal-false.flt` - String equality false
        ```
        // String equality - false
        // --- Command: dotnet run --project FunLang -- %input
        // --- Input:
        "abc" = "xyz"
        // --- Output:
        false
        ```

    11. `11-notequal-true.flt` - String not-equal true (STR-08)
        ```
        // String not-equal - true
        // --- Command: dotnet run --project FunLang -- %input
        // --- Input:
        "abc" <> "xyz"
        // --- Output:
        true
        ```

    12. `12-notequal-false.flt` - String not-equal false
        ```
        // String not-equal - false
        // --- Command: dotnet run --project FunLang -- %input
        // --- Input:
        "abc" <> "abc"
        // --- Output:
        false
        ```

    13. `13-string-in-let.flt` - String in let binding
        ```
        // String in let binding
        // --- Command: dotnet run --project FunLang -- %input
        // --- Input:
        let s = "hello" in s + " world"
        // --- Output:
        "hello world"
        ```

    14. `14-string-in-if.flt` - String in if expression
        ```
        // String in if expression
        // --- Command: dotnet run --project FunLang -- %input
        // --- Input:
        if "a" = "a" then "yes" else "no"
        // --- Output:
        "yes"
        ```

    15. `15-unterminated-error.flt` - Unterminated string error (STR-10)
        ```
        // Unterminated string error
        // --- Command: dotnet run --project FunLang -- %input 2>&1
        // --- Input:
        "unclosed
        // --- Output:
        Error: Newline in string literal
        ```

    **Update tests/Makefile:**
    Add `strings` target to .PHONY line and add:
    ```makefile
    strings:
    	@cd .. && fslit tests/strings/
    ```

    **Update FunLang.Tests/Program.fs:**
    Add Phase 2 String tests section (after commentTests, before phase2Tests):

    ```fsharp
    // ============================================================
    // Phase 2: Strings (v2.0)
    // ============================================================

    [<Tests>]
    let stringTests =
        testList "Strings" [
            testList "STR-01: String Literals" [
                test "simple string" {
                    let result = parseAndEval "\"hello\""
                    Expect.equal result (StringValue "hello") ""
                }
                test "empty string" {
                    let result = parseAndEval "\"\""
                    Expect.equal result (StringValue "") ""
                }
                test "string with spaces" {
                    let result = parseAndEval "\"hello world\""
                    Expect.equal result (StringValue "hello world") ""
                }
            ]

            testList "STR-02 to STR-05: Escape Sequences" [
                test "escape backslash" {
                    let result = parseAndEval "\"a\\\\b\""
                    Expect.equal result (StringValue "a\\b") ""
                }
                test "escape quote" {
                    let result = parseAndEval "\"say \\\"hi\\\"\""
                    Expect.equal result (StringValue "say \"hi\"") ""
                }
                test "escape newline" {
                    let result = parseAndEval "\"line1\\nline2\""
                    Expect.equal result (StringValue "line1\nline2") ""
                }
                test "escape tab" {
                    let result = parseAndEval "\"col1\\tcol2\""
                    Expect.equal result (StringValue "col1\tcol2") ""
                }
                test "multiple escapes" {
                    let result = parseAndEval "\"a\\tb\\nc\""
                    Expect.equal result (StringValue "a\tb\nc") ""
                }
            ]

            testList "STR-06: String Concatenation" [
                test "concat two strings" {
                    let result = parseAndEval "\"hello\" + \" world\""
                    Expect.equal result (StringValue "hello world") ""
                }
                test "concat three strings" {
                    let result = parseAndEval "\"a\" + \"b\" + \"c\""
                    Expect.equal result (StringValue "abc") ""
                }
                test "concat with empty" {
                    let result = parseAndEval "\"\" + \"text\""
                    Expect.equal result (StringValue "text") ""
                }
                test "concat empty with empty" {
                    let result = parseAndEval "\"\" + \"\""
                    Expect.equal result (StringValue "") ""
                }
            ]

            testList "STR-07 and STR-08: String Comparison" [
                test "equal true" {
                    let result = evaluateToBool "\"abc\" = \"abc\""
                    Expect.isTrue result ""
                }
                test "equal false" {
                    let result = evaluateToBool "\"abc\" = \"xyz\""
                    Expect.isFalse result ""
                }
                test "not equal true" {
                    let result = evaluateToBool "\"abc\" <> \"xyz\""
                    Expect.isTrue result ""
                }
                test "not equal false" {
                    let result = evaluateToBool "\"abc\" <> \"abc\""
                    Expect.isFalse result ""
                }
                test "empty string equal" {
                    let result = evaluateToBool "\"\" = \"\""
                    Expect.isTrue result ""
                }
            ]

            testList "STR-10 to STR-12: Error Handling" [
                test "unterminated string throws" {
                    Expect.throws
                        (fun () -> parseAndEval "\"unclosed" |> ignore)
                        "should throw on unterminated string"
                }
                test "string + int throws type error" {
                    Expect.throws
                        (fun () -> parseAndEval "\"text\" + 1" |> ignore)
                        "should throw on string + int"
                }
                test "int + string throws type error" {
                    Expect.throws
                        (fun () -> parseAndEval "1 + \"text\"" |> ignore)
                        "should throw on int + string"
                }
                test "string = int throws type error" {
                    Expect.throws
                        (fun () -> parseAndEval "\"text\" = 1" |> ignore)
                        "should throw on string = int"
                }
            ]

            testList "Integration" [
                test "string in let binding" {
                    let result = parseAndEval "let s = \"hello\" in s"
                    Expect.equal result (StringValue "hello") ""
                }
                test "string concat in let" {
                    let result = parseAndEval "let s = \"hello\" in s + \" world\""
                    Expect.equal result (StringValue "hello world") ""
                }
                test "string in if condition" {
                    let result = evaluate "if \"a\" = \"a\" then 1 else 0"
                    Expect.equal result 1 ""
                }
                test "string result from if" {
                    let result = parseAndEval "if true then \"yes\" else \"no\""
                    Expect.equal result (StringValue "yes") ""
                }
            ]

            testList "Lexer" [
                test "tokenizes string" {
                    let lexbuf = LexBuffer<char>.FromString "\"hello\""
                    let token = Lexer.tokenize lexbuf
                    Expect.equal token (Parser.STRING "hello") ""
                }
                test "tokenizes empty string" {
                    let lexbuf = LexBuffer<char>.FromString "\"\""
                    let token = Lexer.tokenize lexbuf
                    Expect.equal token (Parser.STRING "") ""
                }
            ]

            testList "AST" [
                test "parse string literal" {
                    let ast = parse "\"hello\""
                    Expect.equal ast (String "hello") ""
                }
                test "parse string concat" {
                    let ast = parse "\"a\" + \"b\""
                    Expect.equal ast (Add(String "a", String "b")) ""
                }
            ]
        ]
    ```

    Update the main entry point to include stringTests:
    ```fsharp
    [<EntryPoint>]
    let main argv =
        runTestsWithCLIArgs [] argv <| testList "FunLang Tests" [
            commentTests
            stringTests      // NEW
            phase2Tests
            // ... rest
        ]
    ```
  </action>
  <verify>
    ```bash
    # Build and run fslit tests
    make -C tests strings
    # Expected: 15 tests pass

    # Run all fslit tests (regression)
    make -C tests
    # Expected: All tests pass (78 existing + 15 new = 93)

    # Run Expecto tests
    dotnet run --project FunLang.Tests
    # Expected: All tests pass (139 existing + ~25 new)

    # Run all tests together
    make -C tests && dotnet run --project FunLang.Tests
    ```
  </verify>
  <done>
    - 15 fslit tests in tests/strings/ covering all requirements
    - tests/Makefile updated with strings target
    - ~25 Expecto tests covering STR-01 through STR-12
    - All tests pass
    - No regressions in existing functionality
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Requirement coverage:**
   - STR-01: String literal `"hello"` -> pass
   - STR-02: Escape `\\` -> pass
   - STR-03: Escape `\"` -> pass
   - STR-04: Escape `\n` -> pass
   - STR-05: Escape `\t` -> pass
   - STR-06: Concatenation `"a" + "b"` -> pass
   - STR-07: Equal `"a" = "a"` -> pass
   - STR-08: Not equal `"a" <> "b"` -> pass
   - STR-09: Empty string `""` -> pass
   - STR-10: Unterminated error -> pass
   - STR-11: Newline in string error -> pass
   - STR-12: Mixed type error -> pass

2. **End-to-end verification:**
   ```bash
   # Success cases
   dotnet run --project FunLang -- --expr '"hello world"'
   # "hello world"

   dotnet run --project FunLang -- --expr '"a" + "b" + "c"'
   # "abc"

   dotnet run --project FunLang -- --expr 'let s = "hi" in s + "!"'
   # "hi!"

   dotnet run --project FunLang -- --expr 'if "x" = "x" then "yes" else "no"'
   # "yes"

   # Error cases
   dotnet run --project FunLang -- --expr '"unclosed'
   # Error: Unterminated string literal (or Newline in string literal)

   dotnet run --project FunLang -- --expr '"text" + 1'
   # Error: Type error
   ```

3. **Regression check:**
   ```bash
   make -C tests && dotnet run --project FunLang.Tests
   # All existing tests still pass
   ```
</verification>

<success_criteria>
- All 12 string requirements (STR-01 to STR-12) implemented and tested
- 93+ fslit tests passing (78 existing + 15 new)
- 165+ Expecto tests passing (139 existing + ~25 new)
- No regressions in existing functionality
- Build succeeds without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-strings/02-01-SUMMARY.md`
</output>
