---
phase: 03-variables-binding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Ast.fs
  - FunLang/Lexer.fsl
  - FunLang/Parser.fsy
  - FunLang/Eval.fs
  - FunLang/Format.fs
  - FunLang/Program.fs
autonomous: true

must_haves:
  truths:
    - "User can bind a value to a variable with let-in syntax"
    - "User can reference a bound variable in an expression"
    - "let-in creates a local scope - inner bindings don't affect outer scope"
    - "Undefined variable produces clear error message"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "Var and Let AST nodes"
      contains: "Var of string"
    - path: "FunLang/Lexer.fsl"
      provides: "LET, IN, EQUALS, IDENT tokens"
      contains: "LET"
    - path: "FunLang/Parser.fsy"
      provides: "let-in grammar rules"
      contains: "LET IDENT EQUALS"
    - path: "FunLang/Eval.fs"
      provides: "Environment-based evaluation"
      contains: "Env = Map<string, int>"
    - path: "FunLang/Format.fs"
      provides: "New token formatting"
      contains: "Parser.IDENT"
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "Let and Var constructors"
      pattern: "Let\\(\\$2"
    - from: "FunLang/Eval.fs"
      to: "Map<string, int>"
      via: "Environment lookup"
      pattern: "Map.tryFind"
---

<objective>
Implement variables and let-in bindings in FunLang.

Purpose: Enable users to bind values to names and reuse them in expressions. This introduces the fundamental concept of scope and environment management.

Output:
- Extended AST with Var and Let nodes
- Lexer with LET, IN, EQUALS, IDENT tokens
- Parser with let-in grammar (lowest precedence)
- Environment-passing evaluator
- Updated token formatting
- CLI wired to new evaluator
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-variables-binding/03-RESEARCH.md

@FunLang/Ast.fs
@FunLang/Lexer.fsl
@FunLang/Parser.fsy
@FunLang/Eval.fs
@FunLang/Format.fs
@FunLang/Program.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AST with Var and Let nodes</name>
  <files>FunLang/Ast.fs</files>
  <action>
Add two new cases to the Expr discriminated union:

```fsharp
| Var of string           // Variable reference
| Let of string * Expr * Expr  // let name = expr1 in expr2
```

Place these after the existing Negate case. Add a comment `// Phase 3: Variables` before the new cases.
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1 | head -20
```
Build should succeed (existing eval will have incomplete pattern match warning, which is expected until Task 4).
  </verify>
  <done>Ast.fs contains Var and Let cases in Expr type</done>
</task>

<task type="auto">
  <name>Task 2: Add tokens to Lexer</name>
  <files>FunLang/Lexer.fsl</files>
  <action>
1. Add character class definitions after existing ones:
```
let letter = ['a'-'z' 'A'-'Z']
let ident_start = letter | '_'
let ident_char = letter | digit | '_'
```

2. Add token rules BEFORE the existing operator rules (order matters - keywords before identifier):
```
    // Keywords MUST come before identifier pattern
    | "let"         { LET }
    | "in"          { IN }
    // Identifier: starts with letter or underscore
    | ident_start ident_char* { IDENT (lexeme lexbuf) }
```

3. Add EQUALS token rule (after existing operators):
```
    | '='           { EQUALS }
```

IMPORTANT: Keywords ("let", "in") must appear BEFORE the general identifier rule, otherwise they get matched as IDENT.
  </action>
  <verify>
After regenerating Lexer.fs (happens automatically on build), check for syntax errors:
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1 | grep -i error | head -10
```
  </verify>
  <done>Lexer.fsl contains LET, IN, EQUALS tokens and IDENT rule with proper ordering</done>
</task>

<task type="auto">
  <name>Task 3: Add Parser grammar for let-in</name>
  <files>FunLang/Parser.fsy</files>
  <action>
1. Add token declarations after existing ones:
```
%token <string> IDENT
%token LET IN EQUALS
```

2. Add grammar rule for let-in at the TOP of Expr production (lowest precedence):
```
Expr:
    // Let expression - lowest precedence
    | LET IDENT EQUALS Expr IN Expr  { Let($2, $4, $6) }
    | Expr PLUS Term     { Add($1, $3) }
    | Expr MINUS Term    { Subtract($1, $3) }
    | Term               { $1 }
```

3. Add IDENT to Factor production (variable reference):
```
Factor:
    | NUMBER             { Number($1) }
    | IDENT              { Var($1) }
    | LPAREN Expr RPAREN { $2 }
    | MINUS Factor       { Negate($2) }
```

IMPORTANT: Let must be the FIRST rule in Expr to have lowest precedence. The rule `LET IDENT EQUALS Expr IN Expr` parses `let x = binding in body` where:
- $2 = identifier string
- $4 = binding expression
- $6 = body expression
  </action>
  <verify>
Rebuild to regenerate Parser.fs:
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1 | grep -E "(error|warning)" | head -10
```
Should show only pattern match warnings from Eval.fs (expected).
  </verify>
  <done>Parser.fsy has IDENT token declaration and let-in grammar with correct precedence</done>
</task>

<task type="auto">
  <name>Task 4: Implement environment-passing evaluator</name>
  <files>FunLang/Eval.fs</files>
  <action>
Replace the entire Eval.fs with environment-based evaluation:

```fsharp
module Eval

open Ast

/// Environment mapping variable names to values
type Env = Map<string, int>

/// Empty environment for top-level evaluation
let emptyEnv : Env = Map.empty

/// Evaluate an expression in an environment
/// Raises exception for undefined variables
let rec eval (env: Env) (expr: Expr) : int =
    match expr with
    | Number n -> n

    | Var name ->
        match Map.tryFind name env with
        | Some value -> value
        | None -> failwithf "Undefined variable: %s" name

    | Let (name, binding, body) ->
        // Evaluate binding in current environment
        let value = eval env binding
        // Extend environment with new binding
        let extendedEnv = Map.add name value env
        // Evaluate body in extended environment
        eval extendedEnv body

    | Add (left, right) ->
        eval env left + eval env right

    | Subtract (left, right) ->
        eval env left - eval env right

    | Multiply (left, right) ->
        eval env left * eval env right

    | Divide (left, right) ->
        eval env left / eval env right

    | Negate e ->
        -(eval env e)

/// Convenience function for top-level evaluation
let evalExpr (expr: Expr) : int =
    eval emptyEnv expr
```

Key points:
- `Env` type alias for `Map<string, int>`
- Every `eval` call passes the `env` parameter
- `Var` looks up in environment, fails with clear message if not found
- `Let` evaluates binding, extends env, evaluates body in extended env
- `evalExpr` is convenience wrapper starting with empty environment
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1
```
Build should succeed with no errors.
  </verify>
  <done>Eval.fs implements environment-passing evaluation with Var lookup and Let scoping</done>
</task>

<task type="auto">
  <name>Task 5: Update Format.fs for new tokens</name>
  <files>FunLang/Format.fs</files>
  <action>
Add formatting cases for new tokens in formatToken function:

```fsharp
| Parser.IDENT s -> sprintf "IDENT(%s)" s
| Parser.LET -> "LET"
| Parser.IN -> "IN"
| Parser.EQUALS -> "EQUALS"
```

Add these cases after the existing ones (before EOF). Order in match doesn't matter functionally, but keep consistent grouping.
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1 | grep -E "(error|warning)"
```
No errors or warnings.
  </verify>
  <done>Format.fs formats IDENT, LET, IN, EQUALS tokens</done>
</task>

<task type="auto">
  <name>Task 6: Update Program.fs to use evalExpr</name>
  <files>FunLang/Program.fs</files>
  <action>
Change all occurrences of `eval` to `evalExpr` in Program.fs.

Find and replace:
- `|> eval` -> `|> evalExpr`
- `expr |> parse |> eval` -> `expr |> parse |> evalExpr`
- `input |> parse |> eval` -> `input |> parse |> evalExpr`

This ensures the evaluator is called with an empty environment at the top level.
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj && dotnet run --project FunLang/FunLang.fsproj -- --expr "2 + 3"
```
Should output `5`.
  </verify>
  <done>Program.fs uses evalExpr for all evaluation calls</done>
</task>

</tasks>

<verification>
Run all verification commands to confirm implementation:

```bash
cd /home/shoh/vibe-coding/LangTutorial

# 1. Build succeeds
dotnet build FunLang/FunLang.fsproj

# 2. Existing arithmetic still works
dotnet run --project FunLang/FunLang.fsproj -- --expr "2 + 3 * 4"
# Expected: 14

# 3. Basic let-in works (VAR-01)
dotnet run --project FunLang/FunLang.fsproj -- --expr "let x = 5 in x"
# Expected: 5

# 4. Let with expression body (VAR-02)
dotnet run --project FunLang/FunLang.fsproj -- --expr "let x = 5 in x + 1"
# Expected: 6

# 5. Variable in arithmetic (VAR-02)
dotnet run --project FunLang/FunLang.fsproj -- --expr "let x = 3 in x * 4"
# Expected: 12

# 6. Nested let-in (VAR-03)
dotnet run --project FunLang/FunLang.fsproj -- --expr "let x = 1 in let y = 2 in x + y"
# Expected: 3

# 7. Shadowing (VAR-03)
dotnet run --project FunLang/FunLang.fsproj -- --expr "let x = 1 in let x = 2 in x"
# Expected: 2

# 8. Undefined variable error
dotnet run --project FunLang/FunLang.fsproj -- --expr "x" 2>&1
# Expected: Error: Undefined variable: x

# 9. Token output for let-in
dotnet run --project FunLang/FunLang.fsproj -- --emit-tokens --expr "let x = 5 in x + 1"
# Expected: LET IDENT(x) EQUALS NUMBER(5) IN IDENT(x) PLUS NUMBER(1) EOF

# 10. AST output for let-in
dotnet run --project FunLang/FunLang.fsproj -- --emit-ast --expr "let x = 5 in x + 1"
# Expected: Let ("x", Number 5, Add (Var "x", Number 1))
```
</verification>

<success_criteria>
- [ ] Build succeeds with no errors
- [ ] Existing arithmetic expressions work unchanged (2 + 3 * 4 = 14)
- [ ] VAR-01: `let x = 5 in x` returns 5
- [ ] VAR-02: `let x = 5 in x + 1` returns 6
- [ ] VAR-03: Nested let creates local scope, shadowing works
- [ ] Undefined variable produces "Undefined variable: x" error message
- [ ] --emit-tokens shows LET, IN, EQUALS, IDENT tokens correctly
- [ ] --emit-ast shows Let and Var nodes correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-variables-binding/03-01-SUMMARY.md`
</output>
