---
phase: 01-foundation-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - FunLang/Parser.fsy
  - FunLang/Lexer.fsl
  - FunLang/FunLang.fsproj
autonomous: true

must_haves:
  truths:
    - "fsyacc generates Parser.fs from Parser.fsy"
    - "fslex generates Lexer.fs from Lexer.fsl"
    - "Build order is correct: Parser.fsy before Lexer.fsl"
  artifacts:
    - path: "FunLang/Parser.fsy"
      provides: "Parser specification with token definitions"
      contains: "%token"
    - path: "FunLang/Lexer.fsl"
      provides: "Lexer specification with token patterns"
      contains: "rule tokenize"
    - path: "FunLang/FunLang.fsproj"
      provides: "Build configuration with FsYacc and FsLex tasks"
      contains: "FsYacc"
  key_links:
    - from: "FunLang/Lexer.fsl"
      to: "FunLang/Parser.fsy"
      via: "open Parser in Lexer header"
      pattern: "open Parser"
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "open Ast in Parser header"
      pattern: "open Ast"
---

<objective>
Create Parser.fsy and Lexer.fsl specifications, configure .fsproj build order.

Purpose: Establish the lexer/parser pipeline. The critical build order (Parser before Lexer) is the core learning of this phase.
Output: Parser.fsy and Lexer.fsl that generate working Parser.fs and Lexer.fs during build.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-pipeline/01-RESEARCH.md
@.planning/phases/01-foundation-pipeline/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Parser.fsy specification</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Create `FunLang/Parser.fsy` with a minimal parser that parses a single number.

```fsharp
%{
open Ast
%}

// Token declarations
%token <int> NUMBER
%token EOF

// Start symbol and its type
%start start
%type <Ast.Expr> start

%%

// Grammar rules
start:
  | NUMBER EOF { Number $1 }
```

Key elements:
- Header opens Ast module to access Expr type
- NUMBER token carries int payload (semantic value)
- EOF token marks end of input
- start is the entry point returning Ast.Expr
- Single grammar rule: parse a number and wrap in Number constructor

This minimal parser proves the pipeline works. Phase 2 will add arithmetic operators.
  </action>
  <verify>File FunLang/Parser.fsy exists with %token NUMBER and start rule.</verify>
  <done>Parser.fsy defines NUMBER token and grammar rule that returns Ast.Expr.</done>
</task>

<task type="auto">
  <name>Task 2: Create Lexer.fsl specification</name>
  <files>FunLang/Lexer.fsl</files>
  <action>
Create `FunLang/Lexer.fsl` with lexer rules matching Parser.fsy tokens.

```fsharp
{
open System
open Parser  // Import token types from generated Parser module

// Helper to get lexeme as string
let lexeme (lexbuf: Microsoft.FSharp.Text.Lexing.LexBuffer<_>) =
    Microsoft.FSharp.Text.Lexing.LexBuffer<_>.LexemeString lexbuf
}

// Character class definitions
let digit = ['0'-'9']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')

// Lexer rules
rule tokenize = parse
  | whitespace+   { tokenize lexbuf }           // Skip whitespace
  | newline       { tokenize lexbuf }           // Skip newlines
  | digit+        { NUMBER (Int32.Parse(lexeme lexbuf)) }  // Integer literal
  | eof           { EOF }                       // End of input
```

Key elements:
- Header opens Parser to access token types (NUMBER, EOF)
- Helper function to extract lexeme string
- whitespace/newline patterns skip without returning tokens
- digit+ matches one or more digits, parses to int, returns NUMBER token
- eof pattern returns EOF token

CRITICAL: Lexer opens Parser module, so Parser.fsy MUST be processed first in build.
  </action>
  <verify>File FunLang/Lexer.fsl exists with "open Parser" and "rule tokenize".</verify>
  <done>Lexer.fsl defines tokenize rule that returns NUMBER and EOF tokens.</done>
</task>

<task type="auto">
  <name>Task 3: Configure .fsproj with correct build order</name>
  <files>FunLang/FunLang.fsproj</files>
  <action>
Update `FunLang/FunLang.fsproj` to configure FsLexYacc build tasks with CORRECT ORDER.

Replace the entire ItemGroup with:

```xml
<ItemGroup>
  <!-- 1. AST definitions (manually written) -->
  <Compile Include="Ast.fs" />

  <!-- 2. Parser generator - MUST come before Lexer -->
  <FsYacc Include="Parser.fsy">
    <OtherFlags>--module Parser</OtherFlags>
  </FsYacc>

  <!-- 3. Lexer generator - depends on Parser tokens -->
  <FsLex Include="Lexer.fsl">
    <OtherFlags>--module Lexer --unicode</OtherFlags>
  </FsLex>

  <!-- 4. Generated parser files -->
  <Compile Include="$(IntermediateOutputPath)Parser.fsi">
    <Link>Parser.fsi</Link>
  </Compile>
  <Compile Include="$(IntermediateOutputPath)Parser.fs">
    <Link>Parser.fs</Link>
  </Compile>

  <!-- 5. Generated lexer file -->
  <Compile Include="$(IntermediateOutputPath)Lexer.fs">
    <Link>Lexer.fs</Link>
  </Compile>

  <!-- 6. Main program (to be implemented in Plan 03) -->
  <Compile Include="Program.fs" />
</ItemGroup>
```

Build order explanation (document this in a comment):
1. Ast.fs compiles first (defines Expr type)
2. FsYacc processes Parser.fsy -> generates Parser.fs, Parser.fsi with token types
3. FsLex processes Lexer.fsl -> generates Lexer.fs (can now access Parser.NUMBER etc.)
4. Parser.fsi, Parser.fs compile (generated files)
5. Lexer.fs compiles (generated file)
6. Program.fs compiles last (uses both Parser and Lexer)

CRITICAL: Parser.fsy BEFORE Lexer.fsl. This is the #1 pitfall in FsLexYacc projects.
  </action>
  <verify>
Run `dotnet build FunLang` - should succeed.
Check obj/Debug/net10.0/ contains Parser.fs, Parser.fsi, and Lexer.fs.
  </verify>
  <done>.fsproj configured with FsYacc before FsLex. Generated files appear in obj/.</done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` succeeds without errors
2. `FunLang/obj/Debug/net10.0/Parser.fs` exists (generated)
3. `FunLang/obj/Debug/net10.0/Lexer.fs` exists (generated)
4. Parser.fs contains `type token = | NUMBER of int | EOF`
5. Lexer.fs contains `let tokenize`
</verification>

<success_criteria>
- Parser.fsy compiles via fsyacc
- Lexer.fsl compiles via fslex
- Generated files appear in $(IntermediateOutputPath)
- Build order is correct (no "Parser module not found" errors)
- F# compilation order is correct (no forward reference errors)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-pipeline/01-02-SUMMARY.md`
</output>
