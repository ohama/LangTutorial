---
phase: 05-functions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Ast.fs
  - FunLang/Lexer.fsl
  - FunLang/Parser.fsy
  - FunLang/Format.fs
autonomous: true

must_haves:
  truths:
    - "Parser accepts 'fun x -> x + 1' syntax"
    - "Parser accepts 'f 5' function application syntax"
    - "Parser accepts 'let rec f x = ...' recursive function syntax"
    - "AST correctly represents function expressions"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "Lambda, App, LetRec in Expr; FunctionValue in Value"
      contains: "FunctionValue"
    - path: "FunLang/Lexer.fsl"
      provides: "FUN, REC, ARROW token recognition"
      contains: "FUN"
    - path: "FunLang/Parser.fsy"
      provides: "Grammar rules for function syntax"
      contains: "Lambda"
    - path: "FunLang/Format.fs"
      provides: "Token formatting for FUN, REC, ARROW"
      contains: "FUN"
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "AST construction in grammar actions"
      pattern: "Lambda\\|App\\|LetRec"
    - from: "FunLang/Lexer.fsl"
      to: "FunLang/Parser.fsy"
      via: "Token types from generated Parser module"
      pattern: "FUN\\|REC\\|ARROW"
---

<objective>
Extend the language syntax to support functions: lambda expressions, function application, and recursive function definitions.

Purpose: Enable function syntax parsing so that Phase 5 can implement function semantics. This establishes the AST structure and lexer/parser rules needed for functions.

Output: AST types and parser grammar that correctly parse function-related syntax, verified by --emit-ast output.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-functions/05-RESEARCH.md

@FunLang/Ast.fs
@FunLang/Lexer.fsl
@FunLang/Parser.fsy
@FunLang/Format.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AST types for functions</name>
  <files>FunLang/Ast.fs</files>
  <action>
Add function-related cases to the Ast.fs file:

1. In the `Value` type, add FunctionValue AFTER BoolValue:
```fsharp
| FunctionValue of param: string * body: Expr * closure: Env
```

2. Since Value now references Env (and Env references Value), we need mutual recursion. Change the type definitions to use `and`:
```fsharp
/// Value type for evaluation results
type Value =
    | IntValue of int
    | BoolValue of bool
    | FunctionValue of param: string * body: Expr * closure: Env

/// Environment mapping variable names to values
and Env = Map<string, Value>
```

3. In the `Expr` type, add three new cases at the end (AFTER Or):
```fsharp
// Phase 5: Functions
| Lambda of param: string * body: Expr      // fun param -> body
| App of func: Expr * arg: Expr             // func arg (function application)
| LetRec of name: string * param: string * body: Expr * inExpr: Expr
// let rec name param = body in inExpr
```

IMPORTANT: The Value and Env types must be mutually recursive because FunctionValue contains Env which is Map<string, Value>. Use `type ... and ...` syntax.

NOTE: Do NOT move Env to Ast.fs. Instead, keep Env in Eval.fs but pass it through Ast.fs indirectly via the closure. Actually, the simpler approach: define Env in Ast.fs since it's now part of the Value type. Remove the duplicate definition from Eval.fs in Plan 02.
  </action>
  <verify>
Run `dotnet build FunLang` - should compile with new types (Eval.fs will have warnings about incomplete pattern matches, which is expected until Plan 02 implements them).
  </verify>
  <done>
Ast.fs contains FunctionValue in Value type and Lambda, App, LetRec in Expr type. Build succeeds (with expected warnings).
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend Lexer and Parser for function syntax</name>
  <files>FunLang/Lexer.fsl, FunLang/Parser.fsy</files>
  <action>
1. In Lexer.fsl, add new keywords and operator (BEFORE the identifier pattern, after "in"):
```fsharp
| "fun"         { FUN }
| "rec"         { REC }
| "->"          { ARROW }
```

IMPORTANT: The "->" rule MUST come before single-char operators since it's multi-char. Place it after "||" and before single-char operators section.

2. In Parser.fsy, add token declarations (after existing tokens, before EOF):
```fsharp
%token FUN REC ARROW
```

3. In Parser.fsy, add grammar rules. Function application has high precedence (like Factor level). Add these rules:

In the Expr section, add BEFORE the arithmetic rules (after If rule):
```fsharp
// Phase 5: Function definitions
| LET REC IDENT IDENT EQUALS Expr IN Expr  { LetRec($3, $4, $6, $8) }
| FUN IDENT ARROW Expr                     { Lambda($2, $4) }
```

For function application, modify Factor to support it. Application is left-associative and high precedence. Add a new non-terminal AppExpr between Term and Factor:

```fsharp
Term:
    | Term STAR AppExpr  { Multiply($1, $3) }
    | Term SLASH AppExpr { Divide($1, $3) }
    | AppExpr            { $1 }

AppExpr:
    | AppExpr Factor     { App($1, $2) }
    | Factor             { $1 }

Factor:
    | NUMBER             { Number($1) }
    | IDENT              { Var($1) }
    | TRUE               { Bool(true) }
    | FALSE              { Bool(false) }
    | LPAREN Expr RPAREN { $2 }
    | MINUS Factor       { Negate($2) }
```

This makes function application left-associative: `f 1 2` parses as `App(App(f, 1), 2)` which enables currying.

NOTE: The `let rec` syntax uses IDENT twice (function name and parameter). Multi-parameter functions will be added later via currying.
  </action>
  <verify>
1. Run `dotnet build FunLang` - regenerates Parser.fs and Lexer.fs
2. Test parsing: `dotnet run --project FunLang -- --emit-ast --expr "fun x -> x + 1"` should output Lambda AST
3. Test application: `dotnet run --project FunLang -- --emit-ast --expr "f 5"` should output App AST
  </verify>
  <done>
Lexer recognizes FUN, REC, ARROW tokens. Parser produces Lambda, App, LetRec AST nodes for function syntax.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend Format.fs for new tokens</name>
  <files>FunLang/Format.fs</files>
  <action>
Add token formatting cases for the new tokens in the formatToken function, after the existing tokens:

```fsharp
// Phase 5: Function tokens
| Parser.FUN -> "FUN"
| Parser.REC -> "REC"
| Parser.ARROW -> "ARROW"
```

Place these before the EOF case for consistency with existing pattern.
  </action>
  <verify>
1. Run `dotnet build FunLang`
2. Test: `dotnet run --project FunLang -- --emit-tokens --expr "fun x -> x + 1"` should output "FUN IDENT(x) ARROW IDENT(x) PLUS NUMBER(1) EOF"
  </verify>
  <done>
Format.fs handles FUN, REC, ARROW tokens in --emit-tokens output.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds: `dotnet build FunLang` (warnings OK for incomplete patterns in Eval.fs)
2. Token output works: `dotnet run --project FunLang -- --emit-tokens --expr "fun x -> x + 1"`
3. AST output works: `dotnet run --project FunLang -- --emit-ast --expr "fun x -> x + 1"`
4. Let rec parsing: `dotnet run --project FunLang -- --emit-ast --expr "let rec f x = x in f 1"`
5. Application parsing: `dotnet run --project FunLang -- --emit-ast --expr "f 1 2"`
</verification>

<success_criteria>
- [x] FunctionValue case added to Value type with param, body, closure
- [x] Lambda, App, LetRec cases added to Expr type
- [x] Env type defined in Ast.fs (mutual recursion with Value)
- [x] FUN, REC, ARROW tokens added to Lexer.fsl
- [x] Grammar rules for function syntax in Parser.fsy
- [x] AppExpr non-terminal enables left-associative application
- [x] Format.fs handles new tokens
- [x] --emit-ast shows correct AST for function expressions
- [x] --emit-tokens shows FUN, REC, ARROW tokens
- [x] Build succeeds (eval warnings expected, fixed in Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/05-functions/05-01-SUMMARY.md`
</output>
