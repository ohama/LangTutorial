---
phase: 05-functions
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - FunLang/Eval.fs
  - tests/functions/01-simple-function.flt
  - tests/functions/02-function-application.flt
  - tests/functions/03-recursion.flt
  - tests/functions/04-closures.flt
autonomous: true

must_haves:
  truths:
    - "User can define a function with 'let f x = x + 1 in f 5' and get 6"
    - "User can define multi-parameter functions via currying 'let add x = fun y -> x + y'"
    - "User can define recursive functions with 'let rec' and call them"
    - "Closures capture definition-time environment correctly"
  artifacts:
    - path: "FunLang/Eval.fs"
      provides: "Lambda, App, LetRec evaluation with closure semantics"
      contains: "FunctionValue"
    - path: "tests/functions/01-simple-function.flt"
      provides: "Basic function definition and call tests"
    - path: "tests/functions/03-recursion.flt"
      provides: "Recursive function tests (factorial, fibonacci)"
    - path: "tests/functions/04-closures.flt"
      provides: "Closure tests (captured variables)"
  key_links:
    - from: "FunLang/Eval.fs Lambda case"
      to: "FunctionValue"
      via: "Captures current env in closure"
      pattern: "FunctionValue.*param.*body.*env"
    - from: "FunLang/Eval.fs App case"
      to: "closureEnv"
      via: "Extends closure env (not call-site env)"
      pattern: "Map\\.add param argValue closureEnv"
    - from: "FunLang/Eval.fs LetRec case"
      to: "mutable ref"
      via: "Forward reference handling"
      pattern: "ref\\|placeholder"
---

<objective>
Implement function evaluation: lambda expressions create closures, function application uses closure environments, and let rec enables recursion.

Purpose: Complete the function feature by adding runtime behavior. This makes FunLang Turing-complete.

Output: Working function evaluation with closures and recursion, verified by fslit tests.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-functions/05-RESEARCH.md
@.planning/phases/05-functions/05-01-SUMMARY.md

@FunLang/Ast.fs
@FunLang/Eval.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement function evaluation in Eval.fs</name>
  <files>FunLang/Eval.fs</files>
  <action>
Modify Eval.fs to implement function semantics:

1. REMOVE the Env type definition from Eval.fs (it's now in Ast.fs):
```fsharp
// DELETE this line:
// type Env = Map<string, Value>
```

2. Update the imports to use Env from Ast:
```fsharp
open Ast
// Env is now defined in Ast.fs alongside Value
```

3. Add evaluation cases for Lambda, App, and LetRec. Add these cases to the `eval` function match statement:

```fsharp
// Phase 5: Functions

// Lambda creates a closure capturing current environment
| Lambda (param, body) ->
    FunctionValue (param, body, env)

// Function application
| App (funcExpr, argExpr) ->
    // First evaluate the function expression
    match eval env funcExpr with
    | FunctionValue (param, body, closureEnv) ->
        // Evaluate argument in current (call-site) environment
        let argValue = eval env argExpr
        // Create new environment extending CLOSURE env (not call-site env!)
        // This is critical for lexical scoping
        let callEnv = Map.add param argValue closureEnv
        // Evaluate body in the call environment
        eval callEnv body
    | _ -> failwith "Type error: attempted to call non-function"

// Let rec - recursive function definition
// Uses mutable reference to handle forward reference
| LetRec (name, param, funcBody, inExpr) ->
    // Create a mutable reference as placeholder
    let placeholder : Value ref = ref (IntValue 0)
    // Extend environment with the placeholder (wrapped in a way we can update)
    // We'll use a special pattern: store the function with a reference that points back
    // Simpler approach: create the function with an environment that includes itself

    // Step 1: Create environment with placeholder function
    let rec recEnv = Map.add name (FunctionValue (param, funcBody, recEnv)) env

    // Note: F# supports recursive value definitions with 'let rec ... and ...'
    // This creates a function value whose closure points to recEnv, which contains itself

    // Step 2: Evaluate the body expression in the recursive environment
    eval recEnv inExpr
```

IMPORTANT: The `let rec` implementation uses F#'s `let rec` for the environment, which creates a recursive binding. This is elegant but works because F# allows recursive value definitions for certain patterns.

Alternative implementation if the above doesn't work (using mutation):
```fsharp
| LetRec (name, param, funcBody, inExpr) ->
    // Create placeholder
    let placeholder = ref (IntValue 0)
    // Create env with placeholder
    let tempEnv = Map.add name !placeholder env
    // Create the actual function with tempEnv (will update)
    let funcValue = FunctionValue (param, funcBody, tempEnv)
    // Update placeholder
    placeholder := funcValue
    // Create final env with actual function
    let recEnv = Map.add name funcValue env
    // But wait - funcValue's closure has tempEnv, not recEnv!
    // We need a different approach...
```

BEST approach - lazy closure lookup:
```fsharp
| LetRec (name, param, funcBody, inExpr) ->
    // Create environment that includes the function binding itself
    // The trick: we build the environment first, then create the function
    // Since F# Map is immutable, we use a ref cell
    let envRef = ref env
    let funcValue = FunctionValue (param, funcBody, Map.add name (FunctionValue (param, funcBody, !envRef)) env)
    // Update the ref to point to env with the function
    envRef := Map.add name funcValue env
    // Actually, this still doesn't work because funcValue's closure is already captured

    // SIMPLEST working approach: inline the recursive binding at lookup time
    // For Phase 5, we'll use a simpler pattern that works:

    // Create recursive environment using F#'s rec binding
    let rec makeRecEnv () =
        let funcValue = FunctionValue (param, funcBody, makeRecEnv())
        Map.add name funcValue env
    let recEnv = makeRecEnv ()
    eval recEnv inExpr
```

Actually, the cleanest implementation:
```fsharp
| LetRec (name, param, funcBody, inExpr) ->
    // For let rec, we need the function to see itself in its closure
    // F# allows recursive value bindings, so:
    let rec recEnv : Env = Map.add name funcVal env
    and funcVal = FunctionValue (param, funcBody, recEnv)
    eval recEnv inExpr
```

Use this last version - it leverages F#'s `let rec ... and ...` for mutual recursion between values.
  </action>
  <verify>
1. Run `dotnet build FunLang` - should compile without warnings
2. Test simple function: `dotnet run --project FunLang -- --expr "let f = fun x -> x + 1 in f 5"` should output 6
3. Test recursion: `dotnet run --project FunLang -- --expr "let rec fact n = if n <= 1 then 1 else n * fact (n - 1) in fact 5"` should output 120
  </verify>
  <done>
Eval.fs implements Lambda (closure creation), App (function application with closure env), and LetRec (recursive functions). All three cases work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update formatValue for FunctionValue</name>
  <files>FunLang/Eval.fs</files>
  <action>
Update the formatValue function to handle FunctionValue:

```fsharp
let formatValue (v: Value) : string =
    match v with
    | IntValue n -> string n
    | BoolValue b -> if b then "true" else "false"
    | FunctionValue _ -> "<function>"
```

Functions are not directly printable as values - we display them as `<function>` similar to how other languages handle first-class functions.
  </action>
  <verify>
Run `dotnet run --project FunLang -- --expr "fun x -> x + 1"` should output `<function>`
  </verify>
  <done>
formatValue handles FunctionValue, displaying it as `<function>`.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create fslit tests for functions</name>
  <files>tests/functions/01-simple-function.flt, tests/functions/02-function-application.flt, tests/functions/03-recursion.flt, tests/functions/04-closures.flt</files>
  <action>
Create the tests/functions/ directory and add fslit test files:

1. tests/functions/01-simple-function.flt:
```
# Simple function definition and application

## Lambda expression
```run
dotnet run --project FunLang -- --expr "fun x -> x"
```
```expected
<function>
```

## Function in let binding
```run
dotnet run --project FunLang -- --expr "let f = fun x -> x + 1 in f 5"
```
```expected
6
```

## Let function syntax (sugar for let + lambda)
```run
dotnet run --project FunLang -- --expr "let f x = x + 1 in f 5"
```
```expected
6
```
```

Wait - the research mentions `let f x = body` syntax which is sugar for `let f = fun x -> body`. We need to check if our parser supports this. Looking at the grammar in Plan 01, we only added:
- `LET REC IDENT IDENT EQUALS Expr IN Expr` for recursive functions
- `FUN IDENT ARROW Expr` for lambdas

We did NOT add `LET IDENT IDENT EQUALS Expr IN Expr` for non-recursive function definitions!

Options:
A) Add the rule to parser (requires updating Plan 01 or adding to this plan)
B) Use only lambda syntax for non-recursive functions: `let f = fun x -> x + 1 in f 5`

For Phase 5, we'll use option B (lambda syntax) for non-recursive functions. This keeps the grammar simpler and is actually more fundamental - the `let f x = body` syntax is just sugar.

Revised tests:

1. tests/functions/01-simple-function.flt:
```
# Simple function definition and application

## Lambda expression returns function
```run
dotnet run --project FunLang -- --expr "fun x -> x"
```
```expected
<function>
```

## Function bound to variable and called
```run
dotnet run --project FunLang -- --expr "let f = fun x -> x + 1 in f 5"
```
```expected
6
```

## Function with arithmetic body
```run
dotnet run --project FunLang -- --expr "let double = fun x -> x * 2 in double 7"
```
```expected
14
```
```

2. tests/functions/02-function-application.flt:
```
# Function application tests

## Curried multi-parameter function
```run
dotnet run --project FunLang -- --expr "let add = fun x -> fun y -> x + y in add 3 4"
```
```expected
7
```

## Partial application
```run
dotnet run --project FunLang -- --expr "let add = fun x -> fun y -> x + y in let add5 = add 5 in add5 10"
```
```expected
15
```

## Nested function calls
```run
dotnet run --project FunLang -- --expr "let f = fun x -> x + 1 in f (f (f 0))"
```
```expected
3
```
```

3. tests/functions/03-recursion.flt:
```
# Recursive function tests

## Factorial
```run
dotnet run --project FunLang -- --expr "let rec fact n = if n <= 1 then 1 else n * fact (n - 1) in fact 5"
```
```expected
120
```

## Fibonacci
```run
dotnet run --project FunLang -- --expr "let rec fib n = if n <= 1 then n else fib (n - 1) + fib (n - 2) in fib 6"
```
```expected
8
```

## Simple recursion countdown
```run
dotnet run --project FunLang -- --expr "let rec count n = if n = 0 then 0 else count (n - 1) in count 10"
```
```expected
0
```
```

4. tests/functions/04-closures.flt:
```
# Closure tests - functions capture definition-time environment

## Basic closure
```run
dotnet run --project FunLang -- --expr "let x = 10 in let f = fun y -> x + y in f 5"
```
```expected
15
```

## Closure in nested let
```run
dotnet run --project FunLang -- --expr "let a = 1 in let b = 2 in let f = fun x -> a + b + x in f 3"
```
```expected
6
```

## makeAdder pattern (classic closure test)
```run
dotnet run --project FunLang -- --expr "let makeAdder = fun x -> fun y -> x + y in let add5 = makeAdder 5 in add5 3"
```
```expected
8
```

## Closure captures value not reference
```run
dotnet run --project FunLang -- --expr "let x = 1 in let f = fun y -> x + y in let x = 100 in f 5"
```
```expected
6
```
```

Create these files in tests/functions/ directory.
  </action>
  <verify>
Run all fslit tests: `dotnet run --project fslit -- tests/`
All tests should pass.
  </verify>
  <done>
fslit tests cover: simple functions, function application, recursion (factorial, fibonacci), and closures. All tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. All existing tests pass: `dotnet run --project fslit -- tests/`
2. Simple function works: `let f = fun x -> x + 1 in f 5` returns 6
3. Curried functions work: `let add = fun x -> fun y -> x + y in add 3 4` returns 7
4. Factorial works: `let rec fact n = if n <= 1 then 1 else n * fact (n - 1) in fact 5` returns 120
5. Fibonacci works: `let rec fib n = if n <= 1 then n else fib (n - 1) + fib (n - 2) in fib 6` returns 8
6. Closures work: `let x = 10 in let f = fun y -> x + y in f 5` returns 15
</verification>

<success_criteria>
- [x] Lambda evaluation creates FunctionValue with current env as closure
- [x] App evaluation uses closure environment (not call-site environment)
- [x] LetRec creates recursive environment where function can see itself
- [x] formatValue displays `<function>` for FunctionValue
- [x] Curried multi-parameter functions work via nested lambdas
- [x] Factorial and Fibonacci recursive functions work correctly
- [x] Closures capture definition-time environment (makeAdder pattern works)
- [x] All fslit tests pass
- [x] No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/05-functions/05-02-SUMMARY.md`
</output>
