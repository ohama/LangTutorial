---
phase: 02-arithmetic-expressions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Ast.fs
  - FunLang/Eval.fs
  - FunLang/FunLang.fsproj
autonomous: true

must_haves:
  truths:
    - "AST can represent all arithmetic operations (Add, Subtract, Multiply, Divide, Negate)"
    - "Evaluator can compute any arithmetic expression to an integer result"
    - "Project builds with Eval.fs in correct compilation order"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "Extended Expr discriminated union"
      contains: "Add of Expr * Expr"
    - path: "FunLang/Eval.fs"
      provides: "Recursive evaluator function"
      exports: ["eval"]
    - path: "FunLang/FunLang.fsproj"
      provides: "Build configuration with Eval.fs"
      contains: "Eval.fs"
  key_links:
    - from: "FunLang/Eval.fs"
      to: "FunLang/Ast.fs"
      via: "open Ast"
      pattern: "open Ast"
    - from: "FunLang/Eval.fs"
      to: "Ast.Expr"
      via: "pattern matching"
      pattern: "match expr with"
---

<objective>
Expand the AST with arithmetic operation cases and create an evaluator.

Purpose: Build the core data types and evaluation logic for arithmetic expressions. This is the computational heart of Phase 2 - the evaluator transforms AST nodes into integer results.

Output: Extended Ast.fs with Add/Subtract/Multiply/Divide/Negate, new Eval.fs with recursive evaluator, updated FunLang.fsproj.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-arithmetic-expressions/02-RESEARCH.md

# Existing source files
@FunLang/Ast.fs
@FunLang/FunLang.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand AST with arithmetic operations</name>
  <files>FunLang/Ast.fs</files>
  <action>
Expand the Expr discriminated union to include all arithmetic operations:

```fsharp
module Ast

/// Expression AST for arithmetic operations
/// Phase 2: Arithmetic expressions with precedence
type Expr =
    | Number of int
    | Add of Expr * Expr
    | Subtract of Expr * Expr
    | Multiply of Expr * Expr
    | Divide of Expr * Expr
    | Negate of Expr  // Unary minus
```

Key points:
- Keep Number case from Phase 1
- Add binary operation cases (Add, Subtract, Multiply, Divide)
- Add Negate for unary minus
- Each case holds Expr * Expr (binary) or Expr (unary) for recursive structure
- Update the comment to reflect Phase 2 purpose
  </action>
  <verify>
Run `dotnet build FunLang/FunLang.fsproj` - should compile (Parser/Lexer still use old AST, but Ast.fs itself should compile)
  </verify>
  <done>
Ast.fs contains all 6 cases (Number, Add, Subtract, Multiply, Divide, Negate) and compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create evaluator with pattern matching</name>
  <files>FunLang/Eval.fs, FunLang/FunLang.fsproj</files>
  <action>
Create a new file FunLang/Eval.fs with a recursive evaluator:

```fsharp
module Eval

open Ast

/// Evaluate an expression to an integer result
/// Division by zero throws DivideByZeroException (to be handled in Phase 6)
let rec eval (expr: Expr) : int =
    match expr with
    | Number n -> n
    | Add (left, right) -> eval left + eval right
    | Subtract (left, right) -> eval left - eval right
    | Multiply (left, right) -> eval left * eval right
    | Divide (left, right) -> eval left / eval right
    | Negate e -> -(eval e)
```

Then update FunLang.fsproj to include Eval.fs in the correct position:
- Eval.fs must come AFTER Ast.fs (uses Ast.Expr)
- Eval.fs must come BEFORE Program.fs (used by main)
- Place it after the generated Lexer.fs and before Program.fs

Update the fsproj compile order:
1. Ast.fs
2. Parser.fsi
3. Parser.fs
4. Lexer.fs
5. Eval.fs  <-- NEW
6. Program.fs

Also update the BUILD ORDER comment in fsproj to reflect this addition.
  </action>
  <verify>
Run `dotnet build FunLang/FunLang.fsproj` - should compile successfully.

Then verify evaluator works by temporarily testing in FSI or adding a quick test in Program.fs:
```fsharp
// Quick test: eval (Add(Number 2, Number 3)) should return 5
let testExpr = Add(Number 2, Number 3)
let result = Eval.eval testExpr
printfn "2 + 3 = %d" result  // Should print 5
```
  </verify>
  <done>
- Eval.fs exists with eval function that handles all 6 AST cases
- FunLang.fsproj includes Eval.fs in correct compilation order
- `dotnet build` succeeds
- Evaluator correctly computes: Add(Number 2, Number 3) = 5
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. AST verification:
   - Ast.fs contains all 6 cases: Number, Add, Subtract, Multiply, Divide, Negate
   - Each case has correct type signature

2. Evaluator verification:
   - Eval.fs exists with `eval` function
   - Pattern match is exhaustive (compiler would warn otherwise)
   - Basic arithmetic works: `eval (Multiply(Number 3, Number 4)) = 12`

3. Build verification:
   - `dotnet build FunLang/FunLang.fsproj` succeeds
   - No compiler warnings about incomplete pattern matches
</verification>

<success_criteria>
- [ ] Ast.fs expanded with Add, Subtract, Multiply, Divide, Negate cases
- [ ] Eval.fs created with recursive eval function
- [ ] FunLang.fsproj updated with Eval.fs in correct position
- [ ] `dotnet build` succeeds without errors or warnings
- [ ] Evaluator can compute basic expressions (verified manually or with test code)
</success_criteria>

<output>
After completion, create `.planning/phases/02-arithmetic-expressions/02-01-SUMMARY.md`
</output>
