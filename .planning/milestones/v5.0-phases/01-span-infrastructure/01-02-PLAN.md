---
phase: 01-span-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - FunLang/Ast.fs
  - FunLang/Parser.fsy
  - FunLang/Eval.fs
  - FunLang/Infer.fs
  - FunLang/Format.fs
  - FunLang/TypeCheck.fs
  - FunLang/Prelude.fs
  - FunLang/Program.fs
  - FunLang/Repl.fs
autonomous: true

must_haves:
  truths:
    - "Every Expr variant carries span as last parameter"
    - "Parser produces AST nodes with correct spans"
    - "All existing tests pass after updates"
    - "REPL and CLI still work correctly"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "Expr type with span fields on every variant"
      contains: "span: Span"
    - path: "FunLang/Parser.fsy"
      provides: "Span propagation in all parser rules"
      contains: "mkSpan"
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "Uses Span type and mkSpan"
      pattern: "mkSpan.*parseState"
    - from: "FunLang/Eval.fs"
      to: "FunLang/Ast.fs"
      via: "Pattern matches ignore span"
      pattern: "Number\\(.*,\\s*_\\)"
---

<objective>
Add span field to every Expr variant and update all code that constructs or pattern-matches Expr.

Purpose: Enable precise source location tracking in every AST node for error diagnostics.
Output: Span-aware AST, updated parser, updated evaluator and type checker.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-span-infrastructure/01-RESEARCH.md
@.planning/phases/01-span-infrastructure/01-01-SUMMARY.md

@FunLang/Ast.fs
@FunLang/Parser.fsy
@FunLang/Eval.fs
@FunLang/Infer.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add span to Expr type and Pattern type</name>
  <files>FunLang/Ast.fs</files>
  <action>
Modify every Expr variant to include `span: Span` as the LAST parameter.

Update the Expr type definition:

```fsharp
type Expr =
    | Number of int * span: Span
    | Add of Expr * Expr * span: Span
    | Subtract of Expr * Expr * span: Span
    | Multiply of Expr * Expr * span: Span
    | Divide of Expr * Expr * span: Span
    | Negate of Expr * span: Span
    | Var of string * span: Span
    | Let of string * Expr * Expr * span: Span
    | Bool of bool * span: Span
    | If of Expr * Expr * Expr * span: Span
    | String of string * span: Span
    | Equal of Expr * Expr * span: Span
    | NotEqual of Expr * Expr * span: Span
    | LessThan of Expr * Expr * span: Span
    | GreaterThan of Expr * Expr * span: Span
    | LessEqual of Expr * Expr * span: Span
    | GreaterEqual of Expr * Expr * span: Span
    | And of Expr * Expr * span: Span
    | Or of Expr * Expr * span: Span
    | Lambda of param: string * body: Expr * span: Span
    | App of func: Expr * arg: Expr * span: Span
    | LetRec of name: string * param: string * body: Expr * inExpr: Expr * span: Span
    | Tuple of Expr list * span: Span
    | LetPat of Pattern * Expr * Expr * span: Span
    | EmptyList of span: Span
    | List of Expr list * span: Span
    | Cons of Expr * Expr * span: Span
    | Match of scrutinee: Expr * clauses: MatchClause list * span: Span
```

Note: EmptyList changes from a constant to a case with just span.

Also add span to Pattern type for consistency:

```fsharp
and Pattern =
    | VarPat of string * span: Span
    | TuplePat of Pattern list * span: Span
    | WildcardPat of span: Span
    | ConsPat of Pattern * Pattern * span: Span
    | EmptyListPat of span: Span
    | ConstPat of Constant * span: Span
```

And update MatchClause to include pattern span:
```fsharp
and MatchClause = Pattern * Expr
```
(MatchClause stays the same - span is in the Pattern)

Add helper function to extract span from Expr:

```fsharp
/// Extract span from any Expr
let spanOf (expr: Expr) : Span =
    match expr with
    | Number(_, s) | Bool(_, s) | String(_, s) | Var(_, s) -> s
    | Add(_, _, s) | Subtract(_, _, s) | Multiply(_, _, s) | Divide(_, _, s) -> s
    | Negate(_, s) -> s
    | Let(_, _, _, s) | LetPat(_, _, _, s) | LetRec(_, _, _, _, s) -> s
    | If(_, _, _, s) -> s
    | Equal(_, _, s) | NotEqual(_, _, s) -> s
    | LessThan(_, _, s) | GreaterThan(_, _, s) | LessEqual(_, _, s) | GreaterEqual(_, _, s) -> s
    | And(_, _, s) | Or(_, _, s) -> s
    | Lambda(_, _, s) | App(_, _, s) -> s
    | Tuple(_, s) | EmptyList s | List(_, s) | Cons(_, _, s) -> s
    | Match(_, _, s) -> s
```
  </action>
  <verify>
File saves correctly, types are syntactically valid.
  </verify>
  <done>Every Expr and Pattern variant has span as last parameter, spanOf helper function exists.</done>
</task>

<task type="auto">
  <name>Task 2: Update Parser to propagate spans</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Update Parser.fsy to construct AST nodes with spans.

1. Add helper functions in the header block (between %{ and %}):

```fsharp
%{
open Ast
open FSharp.Text.Lexing

/// Get span covering entire rule (from first to last symbol)
let ruleSpan (parseState: IParseState) : Span =
    let startPos = parseState.InputStartPosition 1
    let endPos = parseState.InputEndPosition (parseState.InputRange |> snd |> _.Column |> fun _ -> parseState.RuleStartPosition.Length)
    // Actually simpler: use ResultRange
    let (startPos, endPos) = parseState.ResultRange
    mkSpan startPos endPos

/// Get span of specific symbol (1-based index)
let symSpan (parseState: IParseState) (n: int) : Span =
    mkSpan (parseState.InputStartPosition n) (parseState.InputEndPosition n)
%}
```

Wait - that's complex. Let me simplify. The correct approach:

```fsharp
%{
open Ast
open FSharp.Text.Lexing

/// Create span from first symbol's start to last symbol's end
let ruleSpan (parseState: IParseState) (firstSym: int) (lastSym: int) : Span =
    mkSpan (parseState.InputStartPosition firstSym) (parseState.InputEndPosition lastSym)

/// Get span of a single symbol
let symSpan (parseState: IParseState) (n: int) : Span =
    mkSpan (parseState.InputStartPosition n) (parseState.InputEndPosition n)
%}
```

2. Update EVERY grammar rule to include spans. Key examples:

For Atom rules (single token):
```
| NUMBER             { Number($1, symSpan parseState 1) }
| IDENT              { Var($1, symSpan parseState 1) }
| TRUE               { Bool(true, symSpan parseState 1) }
| FALSE              { Bool(false, symSpan parseState 1) }
| STRING             { String($1, symSpan parseState 1) }
| LPAREN Expr RPAREN { $2 }  // Use inner expr's span
```

For Expr rules (multiple symbols):
```
| LET IDENT EQUALS Expr IN Expr  { Let($2, $4, $6, ruleSpan parseState 1 6) }
| IF Expr THEN Expr ELSE Expr    { If($2, $4, $6, ruleSpan parseState 1 6) }
| Expr PLUS Term                 { Add($1, $3, ruleSpan parseState 1 3) }
| Expr MINUS Term                { Subtract($1, $3, ruleSpan parseState 1 3) }
| Expr OR Expr                   { Or($1, $3, ruleSpan parseState 1 3) }
| Expr AND Expr                  { And($1, $3, ruleSpan parseState 1 3) }
| Expr EQUALS Expr               { Equal($1, $3, ruleSpan parseState 1 3) }
| MINUS Factor                   { Negate($2, ruleSpan parseState 1 2) }
```

For Term/Factor pass-through, preserve the inner expression span:
```
| Term                           { $1 }
| Factor                         { $1 }
| AppExpr                        { $1 }
| Atom                           { $1 }
```

For tuples and lists:
```
| LPAREN Expr COMMA ExprList RPAREN  { Tuple($2 :: $4, ruleSpan parseState 1 5) }
| LBRACKET RBRACKET                  { EmptyList(ruleSpan parseState 1 2) }
| LBRACKET Expr RBRACKET             { List([$2], ruleSpan parseState 1 3) }
| Expr CONS Expr                     { Cons($1, $3, ruleSpan parseState 1 3) }
```

For functions:
```
| FUN IDENT ARROW Expr           { Lambda($2, $4, ruleSpan parseState 1 4) }
| AppExpr Atom                   { App($1, $2, ruleSpan parseState 1 2) }
| LET REC IDENT IDENT EQUALS Expr IN Expr  { LetRec($3, $4, $6, $8, ruleSpan parseState 1 8) }
```

For match:
```
| MATCH Expr WITH MatchClauses   { Match($2, $4, ruleSpan parseState 1 4) }
```

For patterns (update Pattern rules):
```
| IDENT                       { VarPat($1, symSpan parseState 1) }
| UNDERSCORE                  { WildcardPat(symSpan parseState 1) }
| NUMBER                      { ConstPat(IntConst($1), symSpan parseState 1) }
| TRUE                        { ConstPat(BoolConst(true), symSpan parseState 1) }
| FALSE                       { ConstPat(BoolConst(false), symSpan parseState 1) }
| LBRACKET RBRACKET           { EmptyListPat(ruleSpan parseState 1 2) }
| Pattern CONS Pattern        { ConsPat($1, $3, ruleSpan parseState 1 3) }
| LPAREN PatternList RPAREN   { TuplePat($2, ruleSpan parseState 1 3) }
```

Update TuplePattern rule:
```
TuplePattern:
    | LPAREN PatternList RPAREN   { TuplePat($2, ruleSpan parseState 1 3) }
```

Update LetPat rule:
```
| LET TuplePattern EQUALS Expr IN Expr  { LetPat($2, $4, $6, ruleSpan parseState 1 6) }
```

Note: For MatchClauses, the pattern already carries its span.
  </action>
  <verify>
Run `dotnet build FunLang` - compiles without errors.
  </verify>
  <done>All parser rules construct AST nodes with correct spans using parseState position helpers.</done>
</task>

<task type="auto">
  <name>Task 3: Update all consuming code (Eval, Infer, Format, etc.)</name>
  <files>FunLang/Eval.fs, FunLang/Infer.fs, FunLang/Format.fs, FunLang/TypeCheck.fs, FunLang/Prelude.fs, FunLang/Program.fs, FunLang/Repl.fs</files>
  <action>
Update all files that pattern-match on Expr or construct Expr nodes.

**Strategy**: Use wildcard `_` for span in pattern matches since these modules don't need span yet.

1. **Eval.fs**: Update pattern matches to ignore span:
   - Change `Number(n)` to `Number(n, _)`
   - Change `Add(e1, e2)` to `Add(e1, e2, _)`
   - Change `Var(name)` to `Var(name, _)`
   - Change `Let(name, e1, e2)` to `Let(name, e1, e2, _)`
   - Change `Bool(b)` to `Bool(b, _)`
   - Change `If(cond, thenExpr, elseExpr)` to `If(cond, thenExpr, elseExpr, _)`
   - Change `String(s)` to `String(s, _)`
   - And so on for ALL variants...
   - For EmptyList: change `EmptyList` to `EmptyList _`
   - Pattern matches: `VarPat(name)` to `VarPat(name, _)`, etc.

2. **Infer.fs**: Same pattern - add `_` for span in all matches:
   - Update all pattern matches in `infer` function
   - Update pattern matches in any helper functions

3. **Format.fs**: Update format functions:
   - Add `_` for span in all Expr pattern matches

4. **TypeCheck.fs**: Update if it pattern matches on Expr

5. **Prelude.fs**: This may construct Expr nodes. Use `unknownSpan` for any constructed nodes.
   - Example: If prelude builds AST nodes, use `Number(42, unknownSpan)`

6. **Program.fs** and **Repl.fs**:
   - Check if they construct Expr nodes (likely not, just call parser)
   - Update parse function calls to use setInitialPos:
   ```fsharp
   let lexbuf = LexBuffer<char>.FromString input
   Lexer.setInitialPos lexbuf filename
   Parser.start Lexer.tokenize lexbuf
   ```

   For REPL, use "<repl>" as filename.
   For file input, use actual filename.

Common substitution patterns (regex-style):
- `Number(\$1)` -> `Number($1, _)` in matches
- `EmptyList` -> `EmptyList _` (was a constant, now has span)
  </action>
  <verify>
Run `dotnet build FunLang` - compiles without errors.
Run `make -C tests` - all fslit tests pass.
Run `dotnet run --project FunLang.Tests` - all Expecto tests pass.
  </verify>
  <done>All files updated to handle new Expr signature. Pattern matches use `_` for span. Constructors use `unknownSpan`. Parse calls use setInitialPos.</done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` - project compiles cleanly
2. `make -C tests` - all 66 fslit tests pass
3. `dotnet run --project FunLang.Tests` - all Expecto tests pass
4. `echo "1 + 2" | dotnet run --project FunLang` - outputs 3 (CLI works)
5. Test multi-line input to verify position tracking:
   ```bash
   echo -e "let x = 1 in\nlet y = 2 in\nx + y" | dotnet run --project FunLang
   ```
   Should output 3.
</verification>

<success_criteria>
- Every Expr variant has span as last parameter
- Every Pattern variant has span as last parameter
- Parser constructs nodes with spans from parseState
- Eval.fs compiles with wildcard spans in pattern matches
- Infer.fs compiles with wildcard spans in pattern matches
- All existing tests pass without modification (spans are transparent)
- CLI and REPL work correctly
- setInitialPos is called before parsing with appropriate filename
</success_criteria>

<output>
After completion, create `.planning/phases/01-span-infrastructure/01-02-SUMMARY.md`
</output>
