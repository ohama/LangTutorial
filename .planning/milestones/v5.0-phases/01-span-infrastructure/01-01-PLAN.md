---
phase: 01-span-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Ast.fs
  - FunLang/Lexer.fsl
autonomous: true

must_haves:
  truths:
    - "Span type exists with file, startLine, startColumn, endLine, endColumn"
    - "unknownSpan constant available for built-in/synthetic locations"
    - "Lexer initializes position tracking with filename"
    - "Lexer updates position on newlines"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "Span type, mkSpan function, unknownSpan constant"
      contains: "type Span"
    - path: "FunLang/Lexer.fsl"
      provides: "Position initialization and newline tracking"
      contains: "setInitialPos"
  key_links:
    - from: "FunLang/Ast.fs"
      to: "FSharp.Text.Lexing.Position"
      via: "mkSpan uses Position record"
      pattern: "Position"
    - from: "FunLang/Lexer.fsl"
      to: "lexbuf.EndPos"
      via: "AsNewLinePos() on newlines"
      pattern: "AsNewLinePos"
---

<objective>
Create Span type for source location tracking and enable lexer position tracking.

Purpose: Foundation for precise error diagnostics - every AST node will eventually carry span information for error messages.
Output: Span type in Ast.fs, position-aware lexer ready for parser integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-span-infrastructure/01-RESEARCH.md

@FunLang/Ast.fs
@FunLang/Lexer.fsl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Span type in Ast.fs</name>
  <files>FunLang/Ast.fs</files>
  <action>
Add Span type definition at the TOP of Ast.fs module, BEFORE Expr type.

Add these definitions:

```fsharp
open FSharp.Text.Lexing

/// Source location span for error messages
type Span = {
    FileName: string
    StartLine: int
    StartColumn: int
    EndLine: int
    EndColumn: int
}

/// Create span from FsLexYacc Position records
let mkSpan (startPos: Position) (endPos: Position) : Span =
    {
        FileName = startPos.FileName
        StartLine = startPos.Line
        StartColumn = startPos.Column
        EndLine = endPos.Line
        EndColumn = endPos.Column
    }

/// Sentinel span for built-in/synthetic definitions (like F# compiler's range0)
let unknownSpan : Span =
    {
        FileName = "<unknown>"
        StartLine = 0
        StartColumn = 0
        EndLine = 0
        EndColumn = 0
    }

/// Format span for error messages
let formatSpan (span: Span) : string =
    if span = unknownSpan then
        "<unknown location>"
    elif span.StartLine = span.EndLine then
        sprintf "%s:%d:%d-%d" span.FileName span.StartLine span.StartColumn span.EndColumn
    else
        sprintf "%s:%d:%d-%d:%d" span.FileName span.StartLine span.StartColumn span.EndLine span.EndColumn
```

Use 1-based line and column numbers (matches FsLexYacc's Position.Line and Position.Column).
  </action>
  <verify>
Run `dotnet build FunLang` - compiles without errors.
  </verify>
  <done>Span type, mkSpan, unknownSpan, formatSpan exist in Ast.fs and project compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Enable lexer position tracking</name>
  <files>FunLang/Lexer.fsl</files>
  <action>
Modify Lexer.fsl to track source positions:

1. Add setInitialPos function in the header block (between { and }):

```fsharp
/// Initialize position tracking for the lexbuf
let setInitialPos (lexbuf: LexBuffer<_>) (filename: string) =
    lexbuf.EndPos <- {
        pos_fname = filename
        pos_lnum = 1
        pos_bol = 0
        pos_cnum = 0
    }
```

2. Update the newline rule to call AsNewLinePos():

Change from:
```
| newline       { tokenize lexbuf }           // Skip newlines
```

To:
```
| newline       { lexbuf.EndPos <- lexbuf.EndPos.AsNewLinePos()
                  tokenize lexbuf }
```

3. Also update position in block_comment newline handling:

Change from:
```
| newline { block_comment depth lexbuf }           // Continue on newline
```

To:
```
| newline { lexbuf.EndPos <- lexbuf.EndPos.AsNewLinePos()
            block_comment depth lexbuf }
```

4. Update single-line comment rule to handle trailing newline:

Change from:
```
| "//" [^ '\n' '\r']*  { tokenize lexbuf }   // Skip single-line comment
```

To:
```
| "//" [^ '\n' '\r']* newline  { lexbuf.EndPos <- lexbuf.EndPos.AsNewLinePos()
                                  tokenize lexbuf }
| "//" [^ '\n' '\r']*          { tokenize lexbuf }   // Comment at EOF
```

This ensures ALL newlines update position, including those at end of comments.
  </action>
  <verify>
Run `make -C tests` - all fslit tests still pass (66 tests).
Run `dotnet run --project FunLang.Tests` - all Expecto tests pass.
  </verify>
  <done>Lexer has setInitialPos function and updates EndPos on all newlines (main rule, block comments, line comments).</done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` - project compiles
2. `make -C tests` - fslit tests pass (66 tests)
3. `dotnet run --project FunLang.Tests` - Expecto tests pass
4. Grep for Span type: `grep -n "type Span" FunLang/Ast.fs`
5. Grep for position init: `grep -n "setInitialPos" FunLang/Lexer.fsl`
6. Grep for newline updates: `grep -n "AsNewLinePos" FunLang/Lexer.fsl` (should find 3 occurrences)
</verification>

<success_criteria>
- Span type defined with all 5 fields (FileName, StartLine, StartColumn, EndLine, EndColumn)
- mkSpan creates Span from Position records
- unknownSpan is available as sentinel value
- formatSpan produces readable location strings
- setInitialPos initializes lexbuf with filename
- All newline occurrences update position via AsNewLinePos()
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/01-span-infrastructure/01-01-SUMMARY.md`
</output>
