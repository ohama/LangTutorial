---
phase: 02-error-representation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Diagnostic.fs
  - FunLang/FunLang.fsproj
autonomous: true

must_haves:
  truths:
    - "Diagnostic type captures code, message, spans, notes, hint"
    - "TypeError captures kind, span, term, context stack, trace"
    - "TypeErrorKind distinguishes UnifyMismatch, OccursCheck, UnboundVar, NotAFunction"
    - "InferContext tracks inference path with span"
    - "UnifyPath tracks structural failure location"
    - "TypeException exception wraps TypeError"
  artifacts:
    - path: "FunLang/Diagnostic.fs"
      provides: "Error representation types"
      min_lines: 80
      exports: ["Diagnostic", "TypeError", "TypeErrorKind", "InferContext", "UnifyPath", "TypeException", "typeErrorToDiagnostic"]
  key_links:
    - from: "FunLang/Diagnostic.fs"
      to: "FunLang/Type.fs"
      via: "open Type"
      pattern: "open Type"
    - from: "FunLang/Diagnostic.fs"
      to: "FunLang/Ast.fs"
      via: "open Ast"
      pattern: "open Ast"
  notes:
    - "SecondarySpans starts empty - Phase 3 (Blame Assignment) will populate it with related expression locations per ROADMAP requirement 'Secondary spans highlight related expressions contributing to the error'"
---

<objective>
Define rich diagnostic types for type error representation.

Purpose: Create the data structures needed to capture detailed error information including what went wrong, where in the code, what inference context, and what structural path in unification.
Output: New Diagnostic.fs module with Diagnostic, TypeError, TypeErrorKind, InferContext, UnifyPath types and TypeException exception.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-representation/02-RESEARCH.md
@FunLang/Type.fs
@FunLang/Ast.fs
@FunLang/FunLang.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Diagnostic.fs with error types</name>
  <files>FunLang/Diagnostic.fs</files>
  <action>
Create a new F# module `Diagnostic.fs` with the following types:

1. **Diagnostic** record - general error representation:
   ```fsharp
   type Diagnostic = {
       Code: string option           // e.g., Some "E0301"
       Message: string               // Primary error message
       PrimarySpan: Span             // Main error location
       SecondarySpans: (Span * string) list  // Related locations with labels
       Notes: string list            // Additional context
       Hint: string option           // Suggested fix
   }
   ```
   NOTE: SecondarySpans is initialized as empty list `[]` by typeErrorToDiagnostic in this phase.
   Phase 3 (Blame Assignment) will populate SecondarySpans with related expression locations
   per ROADMAP Phase 3 Success Criteria #2: "Secondary spans highlight related expressions contributing to the error"

2. **TypeErrorKind** DU - what went wrong:
   ```fsharp
   type TypeErrorKind =
       | UnifyMismatch of expected: Type * actual: Type
       | OccursCheck of var: int * ty: Type
       | UnboundVar of name: string
       | NotAFunction of ty: Type
   ```

3. **InferContext** DU - inference path with spans:
   ```fsharp
   type InferContext =
       | InIfCond of Span
       | InIfThen of Span
       | InIfElse of Span
       | InAppFun of Span
       | InAppArg of Span
       | InLetRhs of name: string * Span
       | InLetBody of name: string * Span
       | InLetRecBody of name: string * Span
       | InMatch of Span
       | InMatchClause of index: int * Span
       | InTupleElement of index: int * Span
       | InListElement of index: int * Span
       | InConsHead of Span
       | InConsTail of Span
   ```

4. **UnifyPath** DU - structural failure location:
   ```fsharp
   type UnifyPath =
       | AtFunctionParam of Type
       | AtFunctionReturn of Type
       | AtTupleIndex of index: int * Type
       | AtListElement of Type
   ```

5. **TypeError** record - rich type error:
   ```fsharp
   type TypeError = {
       Kind: TypeErrorKind
       Span: Span
       Term: Expr option
       ContextStack: InferContext list
       Trace: UnifyPath list
   }
   ```

6. **TypeException** exception:
   ```fsharp
   exception TypeException of TypeError
   ```

7. **typeErrorToDiagnostic** conversion function:
   - Map each TypeErrorKind to appropriate error code (E0301 for UnifyMismatch, E0302 for OccursCheck, E0303 for UnboundVar, E0304 for NotAFunction)
   - Use `formatType` from Type.fs for type display
   - Build message from kind
   - PrimarySpan from TypeError.Span
   - SecondarySpans: empty list `[]` (Phase 3 Blame Assignment will populate this)
   - Notes: format context stack (outer-to-inner, reversed then mapped)
   - Hint: basic hints based on kind

8. **Helper functions**:
   - `formatContextStack`: Format InferContext list to string list
   - `formatTrace`: Format UnifyPath list to string list
   - Both reverse the list before formatting (stored inner-first, display outer-first)

Module must:
- `open Ast` (for Span, Expr)
- `open Type` (for Type, formatType)
- Export all types and functions
  </action>
  <verify>
Run `dotnet build FunLang` - should fail with errors about Diagnostic.fs not in project file (expected at this point).
Check that the file exists and has the correct structure:
```bash
grep -c "type Diagnostic" FunLang/Diagnostic.fs  # Should be 1
grep -c "type TypeErrorKind" FunLang/Diagnostic.fs  # Should be 1
grep -c "type InferContext" FunLang/Diagnostic.fs  # Should be 1
grep -c "type UnifyPath" FunLang/Diagnostic.fs  # Should be 1
grep -c "type TypeError" FunLang/Diagnostic.fs  # Should be 1
grep -c "exception TypeException" FunLang/Diagnostic.fs  # Should be 1
grep -c "let typeErrorToDiagnostic" FunLang/Diagnostic.fs  # Should be 1
```
  </verify>
  <done>
Diagnostic.fs exists with all 6 types (Diagnostic, TypeErrorKind, InferContext, UnifyPath, TypeError, TypeException) and conversion function typeErrorToDiagnostic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Diagnostic.fs to project build order</name>
  <files>FunLang/FunLang.fsproj</files>
  <action>
Add `Diagnostic.fs` to FunLang.fsproj in the correct position.

**Critical:** Diagnostic.fs must come AFTER Type.fs (uses Type) and BEFORE Unify.fs (Unify will use TypeException).

Update the Compile ItemGroup:
```xml
<!-- 2. Type system definitions (manually written) -->
<Compile Include="Type.fs" />

<!-- 3. Diagnostic types (manually written, depends on Type.fs and Ast.fs) -->
<Compile Include="Diagnostic.fs" />

<!-- 4. Unification module (manually written, depends on Type.fs, Diagnostic.fs) -->
<Compile Include="Unify.fs" />
```

Also update the comment numbering for subsequent items (Unify.fs becomes 4, Infer.fs becomes 5, etc.)

Note: The header comment describes build order - also update that to mention Diagnostic.fs.
  </action>
  <verify>
Run `dotnet build FunLang` - should compile successfully with no errors.
```bash
dotnet build FunLang
echo $?  # Should be 0
```
  </verify>
  <done>
FunLang builds successfully with Diagnostic.fs in the correct position after Type.fs and before Unify.fs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify types are usable from other modules</name>
  <files></files>
  <action>
Verify the types are accessible from the modules that will use them in Plan 02.

Create a temporary test in Infer.fs to verify imports work (will be removed in Plan 02):
- Add `open Diagnostic` at the top of Infer.fs
- Add a simple test comment that shows the types are accessible

Then remove the test (we just want to verify the build order is correct).

Run full test suite to ensure no regressions:
```bash
dotnet run --project FunLang.Tests
make -C tests
```
  </action>
  <verify>
All tests pass:
- Expecto tests: 362 tests passed
- fslit tests: Same pass rate as before (168/190 - pre-existing failures)
  </verify>
  <done>
Diagnostic module types are accessible from Unify.fs and Infer.fs. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` compiles without errors
2. Diagnostic.fs contains all required types
3. Build order in .fsproj is correct (Type.fs -> Diagnostic.fs -> Unify.fs)
4. All existing tests pass (no regressions)
</verification>

<success_criteria>
- Diagnostic.fs exists with Diagnostic, TypeError, TypeErrorKind, InferContext, UnifyPath, TypeException
- TypeException is an F# exception type (not a class)
- typeErrorToDiagnostic converts TypeError to Diagnostic
- Project builds successfully
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-representation/02-01-SUMMARY.md`
</output>
