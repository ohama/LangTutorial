---
phase: 04-output-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Type.fs
  - FunLang/Diagnostic.fs
  - FunLang.Tests/TypeTests.fs
autonomous: true

must_haves:
  truths:
    - "Type variables display as 'a, 'b, 'c in error messages"
    - "Error messages show location, expected/actual types, context, and hints"
    - "Diagnostic format follows Rust-inspired multi-line structure"
  artifacts:
    - path: "FunLang/Type.fs"
      provides: "formatTypeNormalized function"
      contains: "let formatTypeNormalized"
    - path: "FunLang/Diagnostic.fs"
      provides: "formatDiagnostic function"
      contains: "let formatDiagnostic"
    - path: "FunLang.Tests/TypeTests.fs"
      provides: "Unit tests for formatting functions"
      contains: "formatTypeNormalized"
  key_links:
    - from: "FunLang/Diagnostic.fs"
      to: "Type.formatTypeNormalized"
      via: "open Type, calls formatTypeNormalized"
      pattern: "formatTypeNormalized"
---

<objective>
Implement formatting functions for user-friendly diagnostic output

Purpose: Create the core formatting layer that transforms internal types and diagnostics into readable, normalized output. This is the foundation for the new error message format.

Output:
- formatTypeNormalized in Type.fs (normalizes TVar 1000+ to 'a, 'b, 'c)
- formatDiagnostic in Diagnostic.fs (Rust-style multi-line format)
- Unit tests verifying formatting behavior
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-output-testing/04-RESEARCH.md
@FunLang/Type.fs
@FunLang/Diagnostic.fs
@FunLang.Tests/TypeTests.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add formatTypeNormalized to Type.fs</name>
  <files>FunLang/Type.fs</files>
  <action>
Add a new function `formatTypeNormalized` after the existing `formatType` function in Type.fs.

The function must:
1. Collect all type variables in the type in order of first appearance (depth-first traversal)
2. Map each variable to a normalized index (0='a, 1='b, 2='c, etc.)
3. Format the type using these normalized names

Implementation pattern from research:
```fsharp
/// Format type with normalized type variables ('a, 'b, 'c instead of raw indices)
let formatTypeNormalized (ty: Type) : string =
    // Collect all type variables in order of first appearance
    let rec collectVars acc = function
        | TVar n -> if List.contains n acc then acc else acc @ [n]
        | TArrow(t1, t2) -> collectVars (collectVars acc t1) t2
        | TTuple ts -> List.fold collectVars acc ts
        | TList t -> collectVars acc t
        | TInt | TBool | TString -> acc

    let vars = collectVars [] ty
    let varMap = vars |> List.mapi (fun i v -> (v, i)) |> Map.ofList

    let rec format = function
        | TInt -> "int"
        | TBool -> "bool"
        | TString -> "string"
        | TVar n ->
            match Map.tryFind n varMap with
            | Some idx -> sprintf "'%c" (char (97 + idx % 26))
            | None -> sprintf "'%c" (char (97 + n % 26))
        | TArrow(t1, t2) ->
            let left = match t1 with TArrow _ -> sprintf "(%s)" (format t1) | _ -> format t1
            sprintf "%s -> %s" left (format t2)
        | TTuple ts -> ts |> List.map format |> String.concat " * "
        | TList t -> sprintf "%s list" (format t)

    format ty
```

Important: Place this function right after the existing `formatType` function (around line 34).
  </action>
  <verify>
Run `dotnet build FunLang` - should compile without errors.
  </verify>
  <done>
formatTypeNormalized function exists in Type.fs and compiles. TVar 1000, TVar 1001 would format as 'a, 'b.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add formatDiagnostic to Diagnostic.fs</name>
  <files>FunLang/Diagnostic.fs</files>
  <action>
Add a new function `formatDiagnostic` at the end of Diagnostic.fs (after typeErrorToDiagnostic).

The function must render diagnostics in Rust-inspired multi-line format:
```
error[E0301]: Type mismatch: expected int but got bool
 --> test.fun:3:10-14
   = in if condition: test.fun:3:4-20
   = note: in if then-branch at test.fun:3:4
   = hint: Check that all branches of your expression return the same type
```

Implementation:
```fsharp
/// Format diagnostic for display (Rust-inspired multi-line format)
let formatDiagnostic (diag: Diagnostic) : string =
    let sb = System.Text.StringBuilder()

    // Error header: error[E0301]: Type mismatch
    match diag.Code with
    | Some code -> sb.AppendLine(sprintf "error[%s]: %s" code diag.Message) |> ignore
    | None -> sb.AppendLine(sprintf "error: %s" diag.Message) |> ignore

    // Primary location: --> file.fun:2:5
    sb.AppendLine(sprintf " --> %s" (formatSpan diag.PrimarySpan)) |> ignore

    // Secondary spans (related locations)
    for (span, label) in diag.SecondarySpans do
        sb.AppendLine(sprintf "   = %s: %s" label (formatSpan span)) |> ignore

    // Notes (context stack, trace)
    for note in diag.Notes do
        sb.AppendLine(sprintf "   = note: %s" note) |> ignore

    // Hint
    match diag.Hint with
    | Some hint -> sb.AppendLine(sprintf "   = hint: %s" hint) |> ignore
    | None -> ()

    sb.ToString().TrimEnd()
```

Add `open System.Text` at the top of the file if not already present.
  </action>
  <verify>
Run `dotnet build FunLang` - should compile without errors.
  </verify>
  <done>
formatDiagnostic function exists in Diagnostic.fs and compiles. Output follows multi-line format with error code, location, secondary spans, notes, and hint.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for formatting functions</name>
  <files>FunLang.Tests/TypeTests.fs</files>
  <action>
Add tests for formatTypeNormalized and formatDiagnostic to TypeTests.fs.

Add a new test list at the end of the file:

```fsharp
    testList "formatTypeNormalized (OUT-03)" [
        test "normalizes TVar 1000 to 'a" {
            let ty = TVar 1000
            let result = formatTypeNormalized ty
            Expect.equal result "'a" "TVar 1000 should format as 'a"
        }

        test "normalizes two variables to 'a -> 'b" {
            let ty = TArrow(TVar 1000, TVar 1001)
            let result = formatTypeNormalized ty
            Expect.equal result "'a -> 'b" "should use sequential variable names"
        }

        test "reuses same variable name for same var" {
            let ty = TArrow(TVar 1000, TArrow(TVar 1001, TVar 1000))
            let result = formatTypeNormalized ty
            Expect.equal result "'a -> 'b -> 'a" "same var should have same name"
        }

        test "normalizes complex polymorphic type" {
            // ('a -> 'b) -> 'a list -> 'b list (map signature)
            let ty = TArrow(TArrow(TVar 1000, TVar 1001), TArrow(TList(TVar 1000), TList(TVar 1001)))
            let result = formatTypeNormalized ty
            Expect.equal result "('a -> 'b) -> 'a list -> 'b list" "map type should be readable"
        }

        test "handles tuple types" {
            let ty = TTuple [TVar 1000; TVar 1001; TVar 1000]
            let result = formatTypeNormalized ty
            Expect.equal result "'a * 'b * 'a" "tuple vars should be normalized"
        }

        test "handles concrete types unchanged" {
            let ty = TArrow(TInt, TBool)
            let result = formatTypeNormalized ty
            Expect.equal result "int -> bool" "concrete types need no normalization"
        }
    ]
```

Also add tests for formatDiagnostic in a separate test list:

```fsharp
    testList "formatDiagnostic (OUT-01, OUT-02)" [
        test "formats diagnostic with all fields" {
            let diag = {
                Code = Some "E0301"
                Message = "Type mismatch: expected int but got bool"
                PrimarySpan = { FileName = "test.fun"; StartLine = 1; StartColumn = 5; EndLine = 1; EndColumn = 9 }
                SecondarySpans = [
                    ({ FileName = "test.fun"; StartLine = 1; StartColumn = 1; EndLine = 1; EndColumn = 20 }, "in if condition")
                ]
                Notes = ["in if condition at test.fun:1:1-20"]
                Hint = Some "Check that all branches return the same type"
            }
            let result = Diagnostic.formatDiagnostic diag
            Expect.stringContains result "error[E0301]" "should include error code"
            Expect.stringContains result "Type mismatch" "should include message"
            Expect.stringContains result " --> test.fun:1:5-9" "should include primary span"
            Expect.stringContains result "= in if condition:" "should include secondary span"
            Expect.stringContains result "= note:" "should include notes"
            Expect.stringContains result "= hint:" "should include hint"
        }

        test "formats diagnostic without code" {
            let diag = {
                Code = None
                Message = "Unknown error"
                PrimarySpan = Ast.unknownSpan
                SecondarySpans = []
                Notes = []
                Hint = None
            }
            let result = Diagnostic.formatDiagnostic diag
            Expect.stringContains result "error:" "should have error prefix without code"
            Expect.isFalse (result.Contains "[") "should not have brackets without code"
        }

        test "formats diagnostic with multiple notes" {
            let diag = {
                Code = Some "E0301"
                Message = "Type mismatch"
                PrimarySpan = { FileName = "test.fun"; StartLine = 2; StartColumn = 1; EndLine = 2; EndColumn = 5 }
                SecondarySpans = []
                Notes = ["in function position"; "in let binding"]
                Hint = None
            }
            let result = Diagnostic.formatDiagnostic diag
            let noteCount = result.Split("= note:").Length - 1
            Expect.equal noteCount 2 "should have two note lines"
        }
    ]
```

Make sure to add `open Diagnostic` at the top of TypeTests.fs if not present.
  </action>
  <verify>
Run `dotnet run --project FunLang.Tests` - all tests should pass including new formatting tests.
  </verify>
  <done>
Unit tests exist for formatTypeNormalized (6 tests) and formatDiagnostic (3 tests). All tests pass.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `dotnet build FunLang` compiles without errors
2. `dotnet run --project FunLang.Tests` passes all tests including new formatting tests
3. formatTypeNormalized normalizes TVar 1000+ to 'a, 'b, 'c
4. formatDiagnostic produces multi-line Rust-style output
</verification>

<success_criteria>
- [ ] formatTypeNormalized exists in Type.fs
- [ ] formatDiagnostic exists in Diagnostic.fs
- [ ] TVar 1000, TVar 1001 normalize to 'a, 'b
- [ ] Diagnostic output includes: error code, message, primary span, secondary spans, notes, hint
- [ ] 9 new unit tests pass (6 for type normalization, 3 for diagnostic formatting)
</success_criteria>

<output>
After completion, create `.planning/phases/04-output-testing/04-01-SUMMARY.md`
</output>
