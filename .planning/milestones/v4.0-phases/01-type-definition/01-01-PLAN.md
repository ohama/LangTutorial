---
phase: 01-type-definition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Type.fs
  - FunLang/FunLang.fsproj
autonomous: true

must_haves:
  truths:
    - "Type AST represents all FunLang types (int, bool, string, arrow, tuple, list, type variables)"
    - "Scheme type supports polymorphism with forall quantification"
    - "TypeEnv maps variable names to type schemes"
    - "formatType displays types in readable notation ('a -> 'b, int list)"
  artifacts:
    - path: "FunLang/Type.fs"
      provides: "Type AST, Scheme, TypeEnv, Subst definitions and formatType function"
      exports: ["Type", "Scheme", "TypeEnv", "Subst", "formatType"]
      contains: "type Type ="
    - path: "FunLang/FunLang.fsproj"
      provides: "Build order with Type.fs after Ast.fs"
      contains: "Type.fs"
  key_links:
    - from: "FunLang/Type.fs"
      to: "FunLang/Ast.fs"
      via: "Build order dependency"
      pattern: "Compile Include=\"Type.fs\""
---

<objective>
Create the Type.fs module with Type AST, Scheme, TypeEnv, and formatType function

Purpose: Establish the type system foundation for Hindley-Milner type inference in FunLang
Output: Type.fs module with all type definitions and formatting, integrated into build order
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-type-definition/01-RESEARCH.md
@docs/todo.md

# Codebase patterns
@FunLang/Ast.fs
@FunLang/FunLang.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Type.fs with type definitions</name>
  <files>FunLang/Type.fs</files>
  <action>
Create FunLang/Type.fs with the following structure:

1. Module declaration: `module Type`

2. Type discriminated union with 7 cases:
   - TInt (int)
   - TBool (bool)
   - TString (string)
   - TVar of int (type variables 'a, 'b using int for simplicity)
   - TArrow of Type * Type (function types 'a -> 'b)
   - TTuple of Type list (tuple types 'a * 'b)
   - TList of Type (list types 'a list)

3. Scheme type for polymorphism:
   - `Scheme of vars: int list * ty: Type`
   - Represents forall quantification (e.g., forall 'a. 'a -> 'a)

4. Type aliases:
   - `type TypeEnv = Map<string, Scheme>` (variable name -> type scheme)
   - `type Subst = Map<int, Type>` (type variable -> type)

5. formatType function with pattern matching:
   - TInt -> "int"
   - TBool -> "bool"
   - TString -> "string"
   - TVar n -> sprintf "'%c" (char (97 + n % 26)) for 'a, 'b, etc.
   - TArrow: parenthesize left operand if it's also TArrow (right-associative)
   - TTuple: join with " * "
   - TList: append " list"

Follow the reference implementation in docs/todo.md exactly. Use F# idioms consistent with Ast.fs.
  </action>
  <verify>
```bash
# File exists and has correct structure
test -f FunLang/Type.fs && echo "Type.fs exists"
grep -q "type Type =" FunLang/Type.fs && echo "Type union defined"
grep -q "type Scheme =" FunLang/Type.fs && echo "Scheme defined"
grep -q "type TypeEnv =" FunLang/Type.fs && echo "TypeEnv defined"
grep -q "let rec formatType" FunLang/Type.fs && echo "formatType defined"
```
  </verify>
  <done>
Type.fs contains:
- Type discriminated union with all 7 cases
- Scheme type with vars and ty
- TypeEnv type alias
- Subst type alias
- formatType function
  </done>
</task>

<task type="auto">
  <name>Task 2: Update FunLang.fsproj build order</name>
  <files>FunLang/FunLang.fsproj</files>
  <action>
Update FunLang/FunLang.fsproj to include Type.fs in the correct position:

1. Add Type.fs immediately AFTER Ast.fs (line ~35)
2. Add comment explaining it's for type system

Insert this block after `<Compile Include="Ast.fs" />`:
```xml
    <!-- 2. Type system definitions (manually written) -->
    <Compile Include="Type.fs" />
```

**Why after Ast.fs:**
- Type.fs depends on nothing (standalone types)
- Later phases (Subst, Unify, Infer) will need Type.fs
- Must come before Parser.fsy in build order

**Verify the insertion point is correct:**
- Look for `<Compile Include="Ast.fs" />`
- Insert new line immediately after
- Ensure no duplicate entries
  </action>
  <verify>
```bash
# Build succeeds
dotnet build FunLang/FunLang.fsproj --verbosity quiet && echo "Build successful"

# Type.fs in correct position (after Ast.fs, before Parser)
grep -n "Compile Include" FunLang/FunLang.fsproj | head -5
```
  </verify>
  <done>
- FunLang.fsproj includes Type.fs in correct build position
- `dotnet build` succeeds without errors
- Build order is: Ast.fs -> Type.fs -> Parser.fsy -> ...
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build verification:
```bash
dotnet build FunLang/FunLang.fsproj
```
Expected: Build succeeds

2. Type module structure:
```bash
# Count Type union cases (should be 7)
grep -E "^\s+\| T" FunLang/Type.fs | wc -l
```
Expected: 7 cases

3. formatType coverage (manual check):
- All Type cases have matching pattern in formatType
- Arrow parenthesization handles nested arrows
- TVar uses modulo 26 for letter cycling
</verification>

<success_criteria>
Phase 1 is complete when:
- [ ] Type.fs exists with Type, Scheme, TypeEnv, Subst definitions
- [ ] formatType correctly formats all type cases
- [ ] FunLang.fsproj builds successfully with Type.fs
- [ ] Build order is correct (Type.fs after Ast.fs)
</success_criteria>

<output>
After completion, create `.planning/phases/01-type-definition/01-01-SUMMARY.md`
</output>
