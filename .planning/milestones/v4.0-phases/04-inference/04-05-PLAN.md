---
phase: 04-inference
plan: 05
type: execute
wave: 4
depends_on: [04-03, 04-04]
files_modified: [FunLang/Infer.fs]
autonomous: true

must_haves:
  truths:
    - "inferPattern returns environment bindings and pattern type"
    - "Match unifies scrutinee with all pattern types"
    - "Match unifies all branch result types"
    - "LetPat generalizes pattern bindings like Let"
  artifacts:
    - path: "FunLang/Infer.fs"
      provides: "inferPattern and infer cases for Match, LetPat"
      exports: ["inferPattern"]
  key_links:
    - from: "infer Match"
      to: "inferPattern"
      via: "pattern type extraction"
      pattern: "inferPattern pat"
    - from: "infer LetPat"
      to: "generalize"
      via: "polymorphic pattern bindings"
      pattern: "generalize"
---

<objective>
Implement inferPattern function and infer cases for Match and LetPat expressions.

Purpose: Pattern matching requires inferring pattern types and extracting bindings. Match must unify scrutinee with patterns and all branch results. LetPat extends let-polymorphism to pattern bindings. This covers INFER-13, INFER-14, INFER-15.
Output: Complete pattern matching type inference.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-inference/04-RESEARCH.md
@.planning/phases/04-inference/04-03-SUMMARY.md
@.planning/phases/04-inference/04-04-SUMMARY.md
@FunLang/Type.fs
@FunLang/Unify.fs
@FunLang/Ast.fs
@FunLang/Infer.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add inferPattern function</name>
  <files>FunLang/Infer.fs</files>
  <action>
Add inferPattern function BEFORE the infer function (it will be called by infer):

```fsharp
/// Infer pattern type and extract bindings (INFER-15)
/// Returns (environment with bindings, pattern type)
let rec inferPattern (pat: Pattern): TypeEnv * Type =
    match pat with
    | VarPat name ->
        let ty = freshVar()
        (Map.ofList [(name, Scheme ([], ty))], ty)

    | WildcardPat ->
        (Map.empty, freshVar())

    | TuplePat pats ->
        let envTys = List.map inferPattern pats
        let env = envTys
                  |> List.map fst
                  |> List.fold (fun acc m -> Map.fold (fun a k v -> Map.add k v a) acc m) Map.empty
        let tys = envTys |> List.map snd
        (env, TTuple tys)

    | EmptyListPat ->
        (Map.empty, TList (freshVar()))

    | ConsPat (headPat, tailPat) ->
        let headEnv, headTy = inferPattern headPat
        let tailEnv, tailTy = inferPattern tailPat
        // Note: tailTy should be TList headTy, but actual unification happens in Match
        // We return TList headTy as the pattern type
        let env = Map.fold (fun acc k v -> Map.add k v acc) headEnv tailEnv
        (env, TList headTy)

    | ConstPat (IntConst _) ->
        (Map.empty, TInt)

    | ConstPat (BoolConst _) ->
        (Map.empty, TBool)
```

Key patterns:
- VarPat: fresh type variable, binding in environment
- WildcardPat: fresh type, no binding
- TuplePat: merge environments, tuple of pattern types
- ConsPat: merge environments, TList of head type
- ConstPat: no binding, concrete type
  </action>
  <verify>
```bash
dotnet fsi --exec <<'EOF'
#r "FunLang/bin/Debug/net8.0/FunLang.dll"
open Type
open Ast
open Infer

// VarPat
let env1, ty1 = inferPattern (VarPat "x")
printfn "VarPat x: env=%A, ty=%s" (Map.toList env1) (formatType ty1)

// TuplePat (a, b)
let env2, ty2 = inferPattern (TuplePat [VarPat "a"; VarPat "b"])
printfn "TuplePat (a, b): env=%A, ty=%s" (Map.toList env2) (formatType ty2)

// ConsPat h :: t
let env3, ty3 = inferPattern (ConsPat (VarPat "h", VarPat "t"))
printfn "ConsPat h :: t: env=%A, ty=%s" (Map.toList env3) (formatType ty3)

// ConstPat 42
let env4, ty4 = inferPattern (ConstPat (IntConst 42))
printfn "ConstPat 42: env=%A, ty=%s" (Map.toList env4) (formatType ty4)
EOF
```
  </verify>
  <done>
- VarPat returns singleton env with fresh type
- TuplePat merges envs and returns TTuple
- ConsPat merges envs and returns TList
- ConstPat returns empty env and concrete type
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Match and LetPat inference</name>
  <files>FunLang/Infer.fs</files>
  <action>
Add Match and LetPat cases to the infer match expression (replace the failwith placeholder):

```fsharp
    // === Match expression (INFER-13) ===
    | Match (scrutinee, clauses) ->
        let s1, scrutTy = infer env scrutinee
        let resultTy = freshVar()
        let folder s (pat, expr) =
            let patEnv, patTy = inferPattern pat
            // Unify scrutinee with pattern type
            let s' = unify (apply s scrutTy) patTy
            // Merge pattern env with current env (after applying substitution)
            let clauseEnv = Map.fold (fun acc k v -> Map.add k v acc)
                                     (applyEnv s' (applyEnv s env)) patEnv
            // Infer clause body
            let s'', exprTy = infer clauseEnv expr
            // Unify with result type
            let s''' = unify (apply s'' resultTy) exprTy
            compose s''' (compose s'' (compose s' s))
        let finalS = List.fold folder s1 clauses
        (finalS, apply finalS resultTy)

    // === LetPat (INFER-14) ===
    | LetPat (pat, value, body) ->
        // Infer value type
        let s1, valueTy = infer env value
        // Get pattern bindings and type
        let patEnv, patTy = inferPattern pat
        // Unify value type with pattern type
        let s2 = unify (apply s1 valueTy) patTy
        let s = compose s2 s1
        // Apply substitution and generalize each binding
        let env' = applyEnv s env
        let generalizedPatEnv =
            patEnv
            |> Map.map (fun _ (Scheme (_, ty)) ->
                let ty' = apply s ty
                generalize env' ty')
        // Merge into environment
        let bodyEnv = Map.fold (fun acc k v -> Map.add k v acc) env' generalizedPatEnv
        let s3, bodyTy = infer bodyEnv body
        (compose s3 s, bodyTy)
```

Key patterns:
- Match: fold over clauses accumulating substitution
- Match: unify scrutinee with each pattern type
- Match: unify all clause results with fresh result type
- LetPat: infer value, unify with pattern, generalize bindings
  </action>
  <verify>
```bash
dotnet fsi --exec <<'EOF'
#r "FunLang/bin/Debug/net8.0/FunLang.dll"
open Type
open Ast
open Infer

let env: TypeEnv = Map.empty

// match x with y -> y (identity via match)
let _, t1 = infer env (Lambda ("x",
    Match (Var "x", [(VarPat "y", Var "y")])))
printfn "fun x -> match x with y -> y: %s (expect 'a -> 'a)" (formatType t1)

// match (1, 2) with (a, b) -> a + b
let _, t2 = infer env (Match (Tuple [Number 1; Number 2],
    [(TuplePat [VarPat "a"; VarPat "b"], Add (Var "a", Var "b"))]))
printfn "match (1, 2) with (a, b) -> a + b: %s (expect int)" (formatType t2)

// match [1, 2] with [] -> 0 | h :: t -> h
let _, t3 = infer env (Match (List [Number 1; Number 2],
    [(EmptyListPat, Number 0);
     (ConsPat (VarPat "h", VarPat "t"), Var "h")]))
printfn "match [1, 2] with [] -> 0 | h :: t -> h: %s (expect int)" (formatType t3)

// let (a, b) = (1, true) in a
let _, t4 = infer env (LetPat (TuplePat [VarPat "a"; VarPat "b"],
    Tuple [Number 1; Bool true], Var "a"))
printfn "let (a, b) = (1, true) in a: %s (expect int)" (formatType t4)

// let (a, b) = (1, true) in b
let _, t5 = infer env (LetPat (TuplePat [VarPat "a"; VarPat "b"],
    Tuple [Number 1; Bool true], Var "b"))
printfn "let (a, b) = (1, true) in b: %s (expect bool)" (formatType t5)

// LetPat polymorphism: let (f, g) = (fun x -> x, fun y -> y) in (f 1, g true)
let _, t6 = infer env (LetPat (
    TuplePat [VarPat "f"; VarPat "g"],
    Tuple [Lambda ("x", Var "x"); Lambda ("y", Var "y")],
    Tuple [App (Var "f", Number 1); App (Var "g", Bool true)]))
printfn "let (f, g) = (id, id) in (f 1, g true): %s (expect int * bool)" (formatType t6)
EOF
```
  </verify>
  <done>
- Match unifies scrutinee with pattern types
- Match unifies all branch results
- Pattern bindings available in clause bodies
- LetPat generalizes pattern bindings
- LetPat supports polymorphic pattern bindings
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` succeeds
2. inferPattern handles all pattern types
3. Match correctly unifies scrutinee with patterns
4. Match correctly unifies all branch results
5. LetPat generalizes bindings for polymorphism
</verification>

<success_criteria>
- inferPattern returns correct type and bindings for all patterns
- Match unifies scrutinee type with all pattern types
- Match unifies all clause body types to single result type
- LetPat behaves like Let with pattern destructuring
- LetPat supports polymorphic bindings
- All 15 INFER requirements completed
</success_criteria>

<output>
After completion, create `.planning/phases/04-inference/04-05-SUMMARY.md`
</output>
