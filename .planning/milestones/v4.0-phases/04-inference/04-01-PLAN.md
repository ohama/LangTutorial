---
phase: 04-inference
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [FunLang/Infer.fs, FunLang/FunLang.fsproj]
autonomous: true

must_haves:
  truths:
    - "freshVar generates unique type variables on each call"
    - "instantiate replaces bound vars with fresh type variables"
    - "generalize abstracts over free vars not in environment"
  artifacts:
    - path: "FunLang/Infer.fs"
      provides: "Core inference functions"
      exports: ["freshVar", "instantiate", "generalize"]
    - path: "FunLang/FunLang.fsproj"
      provides: "Build order with Infer.fs"
      contains: "Infer.fs"
  key_links:
    - from: "FunLang/Infer.fs"
      to: "FunLang/Type.fs"
      via: "open Type"
      pattern: "open Type"
    - from: "instantiate"
      to: "freshVar"
      via: "generates fresh vars for bound vars"
      pattern: "freshVar\\(\\)"
    - from: "generalize"
      to: "freeVarsEnv"
      via: "computes env free vars"
      pattern: "freeVarsEnv"
---

<objective>
Create Infer.fs module with core Algorithm W helper functions: freshVar, instantiate, and generalize.

Purpose: These three functions are the foundation for all type inference. freshVar generates unique type variables, instantiate enables polymorphic reuse, and generalize creates polymorphic types at let boundaries.
Output: FunLang/Infer.fs with core functions ready for infer implementation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-inference/04-RESEARCH.md
@FunLang/Type.fs
@FunLang/Unify.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Infer.fs with freshVar, instantiate, generalize</name>
  <files>FunLang/Infer.fs</files>
  <action>
Create FunLang/Infer.fs with module header and core functions:

```fsharp
module Infer

open Type
open Unify

/// Generate fresh type variable (unique ID via mutable counter)
let freshVar =
    let counter = ref 0
    fun () ->
        let n = !counter
        counter := n + 1
        TVar n

/// Instantiate scheme: replace bound vars with fresh type variables
/// Example: forall 'a. 'a -> 'a becomes 'c -> 'c (with fresh 'c)
let instantiate (Scheme (vars, ty)): Type =
    match vars with
    | [] -> ty  // Monomorphic - no substitution needed
    | _ ->
        let freshVars = List.map (fun _ -> freshVar()) vars
        let subst = List.zip vars freshVars |> Map.ofList
        apply subst ty

/// Generalize type: abstract over free vars not in environment
/// Creates polymorphic scheme at let boundaries
let generalize (env: TypeEnv) (ty: Type): Scheme =
    let envFree = freeVarsEnv env
    let tyFree = freeVars ty
    let vars = Set.difference tyFree envFree |> Set.toList
    Scheme (vars, ty)
```

Key patterns:
- freshVar uses ref cell for stateful counter
- instantiate short-circuits for monomorphic schemes
- generalize uses set difference for correct polymorphism
  </action>
  <verify>
Create quick test script:
```bash
dotnet fsi --exec <<'EOF'
#r "FunLang/bin/Debug/net8.0/FunLang.dll"
open Type
open Infer

// Test freshVar uniqueness
let v1 = freshVar()
let v2 = freshVar()
printfn "freshVar: %s, %s (should be different)" (formatType v1) (formatType v2)

// Test instantiate
let scheme = Scheme ([0; 1], TArrow (TVar 0, TVar 1))
let inst = instantiate scheme
printfn "instantiate: %s (should use 'c, 'd)" (formatType inst)

// Test generalize
let env: TypeEnv = Map.ofList [("x", Scheme ([], TInt))]
let ty = TArrow (TVar 5, TInt)
let gen = generalize env ty
match gen with
| Scheme (vars, _) -> printfn "generalize: vars=%A (should contain 5)" vars
EOF
```
  </verify>
  <done>
- freshVar generates TVar 0, TVar 1, TVar 2, ... on successive calls
- instantiate replaces bound vars with fresh vars (not the original indices)
- generalize includes only type vars not free in environment
  </done>
</task>

<task type="auto">
  <name>Task 2: Update FunLang.fsproj build order</name>
  <files>FunLang/FunLang.fsproj</files>
  <action>
Add Infer.fs to FunLang.fsproj after Unify.fs:

The build order should be:
1. Ast.fs
2. Type.fs
3. Unify.fs
4. Infer.fs (NEW)
5. ... rest of files

Add `<Compile Include="Infer.fs" />` after the Unify.fs entry.
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang
```
Build should succeed with no errors.
  </verify>
  <done>
- Infer.fs compiles successfully
- Build order places Infer.fs after Unify.fs
- No build errors or warnings
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` completes without errors
2. FSI test confirms freshVar generates unique values
3. FSI test confirms instantiate creates fresh type variables
4. FSI test confirms generalize respects environment free vars
</verification>

<success_criteria>
- Infer.fs exists with freshVar, instantiate, generalize
- All three functions match Algorithm W semantics
- Module compiles and integrates with existing Type.fs and Unify.fs
- Ready for infer function implementation in 04-02
</success_criteria>

<output>
After completion, create `.planning/phases/04-inference/04-01-SUMMARY.md`
</output>
