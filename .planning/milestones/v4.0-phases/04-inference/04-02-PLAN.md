---
phase: 04-inference
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified: [FunLang/Infer.fs]
autonomous: true

must_haves:
  truths:
    - "Number literals infer to TInt"
    - "Bool literals infer to TBool"
    - "String literals infer to TString"
    - "Arithmetic operators require int operands and return int"
    - "Comparison operators return bool"
    - "Logical operators require bool operands and return bool"
    - "Variable lookup instantiates polymorphic schemes from environment"
    - "Unbound variable raises TypeError"
  artifacts:
    - path: "FunLang/Infer.fs"
      provides: "infer function with literal/operator/variable cases"
      exports: ["infer"]
  key_links:
    - from: "infer Var case"
      to: "instantiate"
      via: "polymorphic variable lookup"
      pattern: "instantiate scheme"
    - from: "infer operator cases"
      to: "unify"
      via: "type constraint enforcement"
      pattern: "unify.*TInt"
---

<objective>
Implement infer function for literals (Number, Bool, String), operators (arithmetic, comparison, logical), and variable references.

Purpose: Build the foundation of the infer function handling simple expression types. This covers INFER-04, INFER-05, INFER-06.
Output: infer function handling 3 literal types, 10 operator types, and variable lookup with polymorphic instantiation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-inference/04-RESEARCH.md
@.planning/phases/04-inference/04-01-SUMMARY.md
@FunLang/Type.fs
@FunLang/Unify.fs
@FunLang/Ast.fs
@FunLang/Infer.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add infer function with literals, operators, and variables</name>
  <files>FunLang/Infer.fs</files>
  <action>
Add to Infer.fs after generalize function:

```fsharp
open Ast

/// Infer type for expression (Algorithm W)
/// Returns (substitution, inferred type)
let rec infer (env: TypeEnv) (expr: Expr): Subst * Type =
    match expr with
    // === Literals (INFER-04) ===
    | Number _ -> (empty, TInt)
    | Bool _ -> (empty, TBool)
    | String _ -> (empty, TString)

    // === Variable reference (INFER-06) ===
    | Var name ->
        match Map.tryFind name env with
        | Some scheme -> (empty, instantiate scheme)
        | None -> raise (TypeError (sprintf "Unbound variable: %s" name))

    // === Arithmetic operators (INFER-05) ===
    // All arithmetic: int -> int -> int
    | Add (e1, e2) | Subtract (e1, e2) | Multiply (e1, e2) | Divide (e1, e2) ->
        inferBinaryOp env e1 e2 TInt TInt TInt

    // Unary minus: int -> int
    | Negate e ->
        let s, t = infer env e
        let s' = unify (apply s t) TInt
        (compose s' s, TInt)

    // === Comparison operators (INFER-05) ===
    // Comparison: int -> int -> bool
    | Equal (e1, e2) | NotEqual (e1, e2)
    | LessThan (e1, e2) | GreaterThan (e1, e2)
    | LessEqual (e1, e2) | GreaterEqual (e1, e2) ->
        inferBinaryOp env e1 e2 TInt TInt TBool

    // === Logical operators (INFER-05) ===
    // Logical: bool -> bool -> bool
    | And (e1, e2) | Or (e1, e2) ->
        inferBinaryOp env e1 e2 TBool TBool TBool

    // Placeholder for remaining cases (will be implemented in later plans)
    | _ -> failwith "Not yet implemented"

/// Helper: infer binary operator with expected operand and result types
and inferBinaryOp env e1 e2 leftTy rightTy resultTy =
    let s1, t1 = infer env e1
    let s2, t2 = infer (applyEnv s1 env) e2
    let s3 = unify (apply s2 t1) leftTy
    let s4 = unify (apply s3 t2) rightTy
    (compose s4 (compose s3 (compose s2 s1)), resultTy)
```

Key patterns:
- Literals return empty substitution (no constraints)
- Var instantiates scheme for polymorphic reuse
- inferBinaryOp helper threads substitution correctly
- Substitution threading: applyEnv s1 env before second operand
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang
```
Then test with FSI:
```bash
dotnet fsi --exec <<'EOF'
#r "FunLang/bin/Debug/net8.0/FunLang.dll"
open Type
open Ast
open Infer

let env: TypeEnv = Map.ofList [
    ("x", Scheme ([], TInt))
    ("id", Scheme ([0], TArrow (TVar 0, TVar 0)))  // polymorphic id
]

// Test literals
let _, t1 = infer env (Number 42)
printfn "Number 42: %s (expect int)" (formatType t1)

let _, t2 = infer env (Bool true)
printfn "Bool true: %s (expect bool)" (formatType t2)

// Test arithmetic
let _, t3 = infer env (Add (Number 1, Number 2))
printfn "1 + 2: %s (expect int)" (formatType t3)

// Test comparison
let _, t4 = infer env (LessThan (Number 1, Number 2))
printfn "1 < 2: %s (expect bool)" (formatType t4)

// Test variable (monomorphic)
let _, t5 = infer env (Var "x")
printfn "x: %s (expect int)" (formatType t5)

// Test variable (polymorphic - instantiates fresh)
let _, t6 = infer env (Var "id")
printfn "id: %s (expect 'a -> 'a with fresh var)" (formatType t6)

// Test unbound variable error
try
    let _ = infer env (Var "unknown")
    printfn "ERROR: should have raised TypeError"
with
| Unify.TypeError msg -> printfn "Unbound var error: %s (expected)" msg
EOF
```
  </verify>
  <done>
- Literals infer correct primitive types (TInt, TBool, TString)
- Arithmetic operators unify operands with TInt, return TInt
- Comparison operators unify operands with TInt, return TBool
- Logical operators unify operands with TBool, return TBool
- Var instantiates polymorphic schemes from environment
- Unbound variable raises TypeError with clear message
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` succeeds
2. `infer env (Number 42)` returns (empty, TInt)
3. `infer env (Add (Number 1, Var "x"))` returns (empty, TInt) with int x
4. `infer env (Var "id")` instantiates polymorphic scheme with fresh vars
5. `infer env (Var "unknown")` raises TypeError
</verification>

<success_criteria>
- infer handles Number, Bool, String literals
- infer handles all 6 arithmetic/comparison operators + Negate
- infer handles And, Or logical operators
- infer handles Var with polymorphic instantiation
- inferBinaryOp correctly threads substitutions
- Unbound variable produces clear error message
</success_criteria>

<output>
After completion, create `.planning/phases/04-inference/04-02-SUMMARY.md`
</output>
