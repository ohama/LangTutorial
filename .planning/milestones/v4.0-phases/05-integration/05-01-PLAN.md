---
phase: 05-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [FunLang/TypeCheck.fs, FunLang/FunLang.fsproj, FunLang/Program.fs, FunLang/Cli.fs]
autonomous: true

must_haves:
  truths:
    - "initialTypeEnv contains polymorphic types for all 11 Prelude functions"
    - "--emit-type displays inferred type for valid expressions"
    - "Type errors exit with code 1 and clear message"
    - "Type checking runs before evaluation by default"
  artifacts:
    - path: "FunLang/TypeCheck.fs"
      provides: "Type environment and typecheck function"
      exports: ["initialTypeEnv", "typecheck"]
    - path: "FunLang/Program.fs"
      provides: "CLI integration for type checking"
      contains: "TypeCheck"
  key_links:
    - from: "FunLang/Program.fs"
      to: "FunLang/TypeCheck.fs"
      via: "open TypeCheck"
      pattern: "TypeCheck\\.typecheck"
    - from: "FunLang/TypeCheck.fs"
      to: "FunLang/Infer.fs"
      via: "Infer.infer"
      pattern: "Infer\\.infer"
---

<objective>
Integrate type inference system with CLI and define initial type environment for Prelude functions.

Purpose: Enable type checking of FunLang programs through CLI (--emit-type) and provide polymorphic type schemes for standard library functions.
Output: Working TypeCheck.fs module and CLI integration for type inference.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-integration/05-RESEARCH.md

# Existing type system modules
@FunLang/Type.fs
@FunLang/Unify.fs
@FunLang/Infer.fs

# Files to modify
@FunLang/Program.fs
@FunLang/Cli.fs
@FunLang/FunLang.fsproj

# Reference for Prelude functions
@Prelude.fun
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeCheck.fs with initialTypeEnv and typecheck</name>
  <files>FunLang/TypeCheck.fs, FunLang/FunLang.fsproj</files>
  <action>
Create FunLang/TypeCheck.fs module with:

1. **initialTypeEnv** - Map of Prelude function names to polymorphic type schemes:
   - map: `('a -> 'b) -> 'a list -> 'b list` (Scheme([0;1], TArrow(TArrow(TVar 0, TVar 1), TArrow(TList(TVar 0), TList(TVar 1)))))
   - filter: `('a -> bool) -> 'a list -> 'a list` (Scheme([0], TArrow(TArrow(TVar 0, TBool), TArrow(TList(TVar 0), TList(TVar 0)))))
   - fold: `('b -> 'a -> 'b) -> 'b -> 'a list -> 'b` (Scheme([0;1], TArrow(TArrow(TVar 1, TArrow(TVar 0, TVar 1)), TArrow(TVar 1, TArrow(TList(TVar 0), TVar 1)))))
   - length: `'a list -> int` (Scheme([0], TArrow(TList(TVar 0), TInt)))
   - reverse: `'a list -> 'a list` (Scheme([0], TArrow(TList(TVar 0), TList(TVar 0))))
   - append: `'a list -> 'a list -> 'a list` (Scheme([0], TArrow(TList(TVar 0), TArrow(TList(TVar 0), TList(TVar 0)))))
   - id: `'a -> 'a` (Scheme([0], TArrow(TVar 0, TVar 0)))
   - const: `'a -> 'b -> 'a` (Scheme([0;1], TArrow(TVar 0, TArrow(TVar 1, TVar 0))))
   - compose: `('b -> 'c) -> ('a -> 'b) -> 'a -> 'c` (Scheme([0;1;2], TArrow(TArrow(TVar 1, TVar 2), TArrow(TArrow(TVar 0, TVar 1), TArrow(TVar 0, TVar 2)))))
   - hd: `'a list -> 'a` (Scheme([0], TArrow(TList(TVar 0), TVar 0)))
   - tl: `'a list -> 'a list` (Scheme([0], TArrow(TList(TVar 0), TList(TVar 0))))

2. **typecheck** - Function signature: `Expr -> Result<Type, string>`
   - Calls Infer.infer with initialTypeEnv
   - Returns Ok(apply subst ty) on success
   - Catches TypeError exception, returns Error(message)

Add TypeCheck.fs to FunLang.fsproj AFTER Infer.fs and BEFORE Parser.fsy:
```xml
<Compile Include="TypeCheck.fs" />
```

Use type variable indices 0-9 for scheme bound variables (no collision with freshVar starting at 1000).
  </action>
  <verify>
dotnet build FunLang
  </verify>
  <done>
TypeCheck.fs compiles with 11 Prelude type schemes and typecheck function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate typecheck with CLI (--emit-type and type errors)</name>
  <files>FunLang/Program.fs, FunLang/Cli.fs</files>
  <action>
1. Update FunLang/Cli.fs:
   - Change Emit_Type usage from "show inferred types (reserved)" to "show inferred type"

2. Update FunLang/Program.fs:
   - Add `open TypeCheck` at imports
   - Replace reserved --emit-type stub with working implementation:
     - For --emit-type with --expr: parse, typecheck, format result
     - For --emit-type with file: read file, parse, typecheck, format result
     - On Ok(ty): `printfn "%s" (Type.formatType ty)` and return 0
     - On Error(msg): `eprintfn "TypeError: %s" msg` and return 1

3. Normal evaluation modes (--expr without --emit-type, file without --emit-type):
   - Run typecheck BEFORE eval
   - On type error: print error and exit 1
   - On success: continue to eval as normal

IMPORTANT: Do NOT modify evaluation flow for --emit-ast, --emit-tokens, or --repl modes (these don't need type checking).
  </action>
  <verify>
# Type inference works
dotnet run --project FunLang -- --emit-type -e "fun x -> x"
# Expected: 'a -> 'a

# Type error exits 1
dotnet run --project FunLang -- --emit-type -e "1 + true"; echo "Exit: $?"
# Expected: TypeError: ... Exit: 1

# Normal eval with type checking
dotnet run --project FunLang -- -e "map (fun x -> x + 1) [1, 2, 3]"
# Expected: [2, 3, 4]
  </verify>
  <done>
--emit-type displays inferred types, type errors exit with code 1, normal eval runs type check first.
  </done>
</task>

</tasks>

<verification>
# All Prelude functions should typecheck
dotnet run --project FunLang -- --emit-type -e "map"
# Expected: ('a -> 'b) -> 'a list -> 'b list

dotnet run --project FunLang -- --emit-type -e "filter"
# Expected: ('a -> bool) -> 'a list -> 'a list

dotnet run --project FunLang -- --emit-type -e "fold"
# Expected: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a

dotnet run --project FunLang -- --emit-type -e "id"
# Expected: 'a -> 'a

# Type error handling
dotnet run --project FunLang -- --emit-type -e "1 + true"; echo "Exit code: $?"
# Expected: TypeError, Exit code: 1

# File type checking
echo "1 + 2" > /tmp/test.fun
dotnet run --project FunLang -- --emit-type /tmp/test.fun
# Expected: int
</verification>

<success_criteria>
- [ ] TypeCheck.fs exists with initialTypeEnv (11 functions) and typecheck
- [ ] FunLang.fsproj includes TypeCheck.fs in correct position
- [ ] --emit-type -e "fun x -> x" outputs "'a -> 'a" (or similar polymorphic type)
- [ ] --emit-type -e "map" outputs polymorphic list function type
- [ ] Type errors produce TypeError message and exit code 1
- [ ] Normal evaluation runs type check before eval
- [ ] dotnet build FunLang succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration/05-01-SUMMARY.md`
</output>
