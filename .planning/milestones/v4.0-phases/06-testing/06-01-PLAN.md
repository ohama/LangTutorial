---
phase: 06-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang.Tests/TypeTests.fs
  - FunLang.Tests/UnifyTests.fs
  - FunLang.Tests/Program.fs
autonomous: true

must_haves:
  truths:
    - "Type module formatType displays all types correctly"
    - "Substitution operations apply and compose correctly"
    - "Free variable operations work for types, schemes, and environments"
    - "Occurs check detects infinite types"
    - "Unification finds MGU for compatible types"
    - "Unification raises TypeError for incompatible types"
  artifacts:
    - path: "FunLang.Tests/TypeTests.fs"
      provides: "Type module unit tests (formatType, apply, compose, freeVars)"
      exports: ["typeTests"]
    - path: "FunLang.Tests/UnifyTests.fs"
      provides: "Unify module unit tests (occurs, unify)"
      exports: ["unifyTests"]
  key_links:
    - from: "FunLang.Tests/TypeTests.fs"
      to: "FunLang/Type.fs"
      via: "open Type"
      pattern: "open Type"
    - from: "FunLang.Tests/UnifyTests.fs"
      to: "FunLang/Unify.fs"
      via: "open Unify"
      pattern: "open Unify"
    - from: "FunLang.Tests/Program.fs"
      to: "FunLang.Tests/TypeTests.fs"
      via: "test list registration"
      pattern: "TypeTests\\.typeTests"
---

<objective>
Create comprehensive Expecto unit tests for Type.fs and Unify.fs modules (TEST-01, TEST-02, TEST-03).

Purpose: Verify type system foundation - type formatting, substitution operations, free variable tracking, occurs check, and unification algorithm.

Output: TypeTests.fs and UnifyTests.fs with ~40 tests covering all Type and Unify module functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-testing/06-RESEARCH.md
@FunLang/Type.fs
@FunLang/Unify.fs
@FunLang.Tests/Program.fs
@TESTING.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeTests.fs for Type module</name>
  <files>FunLang.Tests/TypeTests.fs</files>
  <action>
Create FunLang.Tests/TypeTests.fs with comprehensive tests for Type.fs module:

**Module structure:**
```fsharp
module TypeTests

open Expecto
open Type

[<Tests>]
let typeTests = testList "Type Module" [...]
```

**Test groups to include:**

1. **formatType tests** (~10 tests):
   - Primitive types: TInt -> "int", TBool -> "bool", TString -> "string"
   - Type variables: TVar 0 -> "'a", TVar 1 -> "'b", TVar 25 -> "'z", TVar 26 -> "'a" (cycles)
   - Arrow types: TArrow(TInt, TBool) -> "int -> bool"
   - Arrow parenthesization: TArrow(TArrow(TInt, TBool), TString) -> "(int -> bool) -> string"
   - Right-associative arrows: TArrow(TInt, TArrow(TBool, TString)) -> "int -> bool -> string" (no parens)
   - Tuple types: TTuple [TInt; TBool] -> "int * bool"
   - List types: TList TInt -> "int list", TList (TVar 0) -> "'a list"
   - Complex: TArrow(TArrow(TVar 0, TVar 1), TArrow(TList(TVar 0), TList(TVar 1))) -> "('a -> 'b) -> 'a list -> 'b list" (map type)

2. **Substitution apply tests** (~8 tests):
   - Empty substitution: apply empty TInt = TInt
   - Simple substitution: apply [(0, TInt)] (TVar 0) = TInt
   - Transitive chain: apply [(0, TVar 1); (1, TInt)] (TVar 0) = TInt
   - Unbound variable: apply [(0, TInt)] (TVar 1) = TVar 1
   - Apply to arrow: apply [(0, TInt)] (TArrow(TVar 0, TVar 1)) = TArrow(TInt, TVar 1)
   - Apply to tuple: apply [(0, TInt)] (TTuple [TVar 0; TVar 1]) = TTuple [TInt; TVar 1]
   - Apply to list: apply [(0, TInt)] (TList (TVar 0)) = TList TInt

3. **Substitution compose tests** (~5 tests):
   - Compose with empty: compose empty s = s, compose s empty = s (conceptually)
   - Basic compose: compose [(1, TInt)] [(0, TVar 1)] applied to TVar 0 = TInt
   - Order matters: s2 after s1 semantics
   - Merge s2 bindings: compose adds s2 entries not in s1

4. **applyScheme tests** (~3 tests):
   - Respects bound variables: applyScheme [(0, TInt)] (Scheme([0], TVar 0)) = Scheme([0], TVar 0)
   - Substitutes free variables: applyScheme [(1, TInt)] (Scheme([0], TArrow(TVar 0, TVar 1))) = Scheme([0], TArrow(TVar 0, TInt))

5. **freeVars tests** (~6 tests):
   - Primitive has no free vars: freeVars TInt = Set.empty
   - Type variable: freeVars (TVar 0) = Set.singleton 0
   - Arrow: freeVars (TArrow(TVar 0, TVar 1)) = Set.ofList [0; 1]
   - Tuple: freeVars (TTuple [TVar 0; TVar 1; TVar 2]) = Set.ofList [0; 1; 2]
   - List: freeVars (TList (TVar 0)) = Set.singleton 0

6. **freeVarsScheme tests** (~3 tests):
   - Bound var excluded: freeVarsScheme (Scheme([0], TVar 0)) = Set.empty
   - Free var included: freeVarsScheme (Scheme([0], TArrow(TVar 0, TVar 1))) = Set.singleton 1

7. **freeVarsEnv tests** (~2 tests):
   - Empty env: freeVarsEnv Map.empty = Set.empty
   - Env with schemes: union of all free vars in schemes
  </action>
  <verify>
```bash
dotnet run --project FunLang.Tests -- --filter "Type Module"
```
All Type Module tests pass.
  </verify>
  <done>TypeTests.fs exists with ~35 tests covering formatType, apply, compose, applyScheme, freeVars, freeVarsScheme, freeVarsEnv</done>
</task>

<task type="auto">
  <name>Task 2: Create UnifyTests.fs for Unify module</name>
  <files>FunLang.Tests/UnifyTests.fs</files>
  <action>
Create FunLang.Tests/UnifyTests.fs with comprehensive tests for Unify.fs module:

**Module structure:**
```fsharp
module UnifyTests

open Expecto
open Type
open Unify

[<Tests>]
let unifyTests = testList "Unification" [...]
```

**Test groups to include:**

1. **Occurs check tests** (~5 tests):
   - Simple infinite type: unify (TVar 0) (TArrow(TVar 0, TInt)) raises TypeError
   - Infinite list: unify (TVar 0) (TList (TVar 0)) raises TypeError
   - Nested infinite: unify (TVar 0) (TArrow(TArrow(TVar 0, TInt), TBool)) raises TypeError
   - Non-infinite is OK: occurs 0 (TArrow(TInt, TVar 1)) = false
   - Same variable is OK: unify (TVar 0) (TVar 0) = empty

2. **Primitive unification tests** (~4 tests):
   - int = int: unify TInt TInt = empty
   - bool = bool: unify TBool TBool = empty
   - string = string: unify TString TString = empty
   - int <> bool: unify TInt TBool raises TypeError "Cannot unify int with bool"

3. **Type variable unification tests** (~5 tests):
   - Var = concrete: unify (TVar 0) TInt gives [(0, TInt)]
   - Concrete = var: unify TInt (TVar 0) gives [(0, TInt)] (symmetric)
   - Var = var: unify (TVar 0) (TVar 1) gives [(0, TVar 1)]
   - Same var = same var: unify (TVar 0) (TVar 0) = empty

4. **Arrow unification tests** (~6 tests):
   - Compatible arrows: unify (TArrow(TVar 0, TInt)) (TArrow(TBool, TVar 1)) gives [(0, TBool); (1, TInt)]
   - Arrow domain mismatch: unify (TArrow(TInt, TVar 0)) (TArrow(TBool, TVar 0)) raises TypeError
   - Arrow range mismatch: unify (TArrow(TVar 0, TInt)) (TArrow(TVar 0, TBool)) raises TypeError
   - Nested arrows: unify (TArrow(TVar 0, TArrow(TVar 0, TVar 1))) (TArrow(TInt, TArrow(TInt, TBool))) works

5. **Tuple unification tests** (~4 tests):
   - Same length: unify (TTuple [TVar 0; TVar 1]) (TTuple [TInt; TBool]) gives [(0, TInt); (1, TBool)]
   - Different length: unify (TTuple [TInt]) (TTuple [TInt; TBool]) raises TypeError
   - Element mismatch: unify (TTuple [TInt; TBool]) (TTuple [TBool; TInt]) raises TypeError

6. **List unification tests** (~3 tests):
   - unify (TList (TVar 0)) (TList TInt) gives [(0, TInt)]
   - unify (TList TInt) (TList TBool) raises TypeError
   - Nested list: unify (TList (TList (TVar 0))) (TList (TList TInt)) gives [(0, TInt)]

7. **Cross-type unification errors** (~3 tests):
   - Arrow vs tuple: unify (TArrow(TInt, TBool)) (TTuple [TInt; TBool]) raises TypeError
   - List vs arrow: unify (TList TInt) (TArrow(TInt, TInt)) raises TypeError
   - Tuple vs primitive: unify (TTuple [TInt]) TInt raises TypeError
  </action>
  <verify>
```bash
dotnet run --project FunLang.Tests -- --filter "Unification"
```
All Unification tests pass.
  </verify>
  <done>UnifyTests.fs exists with ~30 tests covering occurs, unify for all type constructors and error cases</done>
</task>

<task type="auto">
  <name>Task 3: Update Program.fs to include new test modules</name>
  <files>FunLang.Tests/Program.fs, FunLang.Tests/FunLang.Tests.fsproj</files>
  <action>
1. Update FunLang.Tests/FunLang.Tests.fsproj to include new test files in correct order:
   - Add TypeTests.fs before Program.fs
   - Add UnifyTests.fs after TypeTests.fs, before Program.fs

   Order should be:
   ```xml
   <Compile Include="ReplTests.fs" />
   <Compile Include="TypeTests.fs" />
   <Compile Include="UnifyTests.fs" />
   <Compile Include="Program.fs" />
   ```

2. Update FunLang.Tests/Program.fs main function to include new test lists:
   - Add TypeTests.typeTests to the test list
   - Add UnifyTests.unifyTests to the test list

   ```fsharp
   runTestsWithCLIArgs [] argv <| testList "FunLang Tests" [
       ReplTests.replEvalTests
       ReplTests.cliTests
       TypeTests.typeTests      // Add
       UnifyTests.unifyTests    // Add
       commentTests
       stringTests
       ...
   ]
   ```
  </action>
  <verify>
```bash
dotnet run --project FunLang.Tests
```
All tests pass (existing + new Type and Unify tests).
  </verify>
  <done>Program.fs registers TypeTests and UnifyTests, fsproj includes new files, all tests pass</done>
</task>

</tasks>

<verification>
```bash
# Run all tests
dotnet run --project FunLang.Tests

# Run Type module tests specifically
dotnet run --project FunLang.Tests -- --filter "Type Module"

# Run Unification tests specifically
dotnet run --project FunLang.Tests -- --filter "Unification"
```

Expected: All tests pass, no regressions in existing tests.
</verification>

<success_criteria>
1. TypeTests.fs exists with ~35 tests for Type module
2. UnifyTests.fs exists with ~30 tests for Unify module
3. FunLang.Tests.fsproj includes both new files
4. Program.fs registers both test modules
5. All tests pass: `dotnet run --project FunLang.Tests` reports ~195 tests passed
6. TEST-01 (Type module tests), TEST-02 (Subst tests), TEST-03 (Unify tests) requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing/06-01-SUMMARY.md`
</output>
