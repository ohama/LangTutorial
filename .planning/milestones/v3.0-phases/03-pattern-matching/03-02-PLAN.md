---
phase: 03-pattern-matching
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - FunLang/Eval.fs
  - tests/pattern-matching/*.flt
  - tests/Makefile
autonomous: true

must_haves:
  truths:
    - "match expression evaluates and returns first matching branch"
    - "Constant patterns match on value equality"
    - "Cons pattern h :: t binds head and tail variables"
    - "Empty list pattern [] matches empty lists"
    - "Non-exhaustive match raises runtime error"
    - "Variable and tuple patterns work in match expressions"
  artifacts:
    - path: "FunLang/Eval.fs"
      provides: "Match expression evaluation and extended pattern matching"
      contains: ["Match (scrutinee, clauses)", "evalMatchClauses", "ConstPat", "ConsPat", "EmptyListPat"]
    - path: "tests/pattern-matching/"
      provides: "Comprehensive integration tests for pattern matching"
      min_files: 10
  key_links:
    - from: "FunLang/Eval.fs"
      to: "matchPattern function"
      via: "Extended pattern cases"
      pattern: "ConstPat.*->|ConsPat.*->|EmptyListPat.*->"
    - from: "FunLang/Eval.fs"
      to: "eval function"
      via: "Match case handler"
      pattern: "Match \\(scrutinee, clauses\\)"
---

<objective>
Implement match expression evaluation and extend pattern matching for FunLang.

Purpose: Enable runtime evaluation of match expressions with sequential pattern matching semantics. Extends the existing matchPattern function to handle constant, cons, and empty list patterns. Provides comprehensive test coverage.

Output: Working match expressions with all pattern types; 12+ integration tests; all success criteria met.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-pattern-matching/03-RESEARCH.md
@.planning/phases/03-pattern-matching/03-01-SUMMARY.md

# Implementation reference
@FunLang/Eval.fs
@FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend matchPattern with new pattern types</name>
  <files>FunLang/Eval.fs</files>
  <action>
Extend the existing matchPattern function in Eval.fs to handle new pattern types:

Add cases AFTER existing WildcardPat, VarPat, TuplePat cases:

```fsharp
// Constant patterns
| ConstPat (IntConst n), IntValue m ->
    if n = m then Some [] else None
| ConstPat (BoolConst b1), BoolValue b2 ->
    if b1 = b2 then Some [] else None

// Empty list pattern
| EmptyListPat, ListValue [] -> Some []

// Cons pattern - matches non-empty list
| ConsPat (headPat, tailPat), ListValue (h :: t) ->
    match matchPattern headPat h with
    | Some headBindings ->
        match matchPattern tailPat (ListValue t) with
        | Some tailBindings -> Some (headBindings @ tailBindings)
        | None -> None
    | None -> None
```

IMPORTANT:
- Cons pattern wraps tail as ListValue before recursive call (tail is `Value list`, not `Value`)
- Order matters: specific patterns before wildcards
- The final `| _ -> None` catch-all handles all type mismatches
  </action>
  <verify>
Run `dotnet build FunLang` - should compile without errors. The matchPattern function now handles 6 pattern types: VarPat, WildcardPat, TuplePat, ConstPat, EmptyListPat, ConsPat.
  </verify>
  <done>
matchPattern handles all pattern types. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Match expression evaluation</name>
  <files>FunLang/Eval.fs</files>
  <action>
Add Match expression evaluation to Eval.fs:

1. Add helper function `evalMatchClauses` (can be placed near matchPattern):

```fsharp
/// Evaluate match clauses sequentially, returning first match
and evalMatchClauses (env: Env) (scrutinee: Value) (clauses: MatchClause list) : Value =
    match clauses with
    | [] -> failwith "Match failure: no pattern matched"
    | (pattern, resultExpr) :: rest ->
        match matchPattern pattern scrutinee with
        | Some bindings ->
            let extendedEnv = List.fold (fun e (n, v) -> Map.add n v e) env bindings
            eval extendedEnv resultExpr
        | None ->
            evalMatchClauses env scrutinee rest
```

2. Add Match case to the main eval function (after LetPat case):

```fsharp
| Match (scrutinee, clauses) ->
    let value = eval env scrutinee
    evalMatchClauses env value clauses
```

IMPORTANT:
- evalMatchClauses must use `and` keyword for mutual recursion with eval
- First-match semantics: try patterns in order, return first success
- "Match failure" error for non-exhaustive matches (runtime error, not compile-time warning)
  </action>
  <verify>
Run quick tests:
```bash
dotnet run --project FunLang -- -e "match 1 with | 1 -> 100 | _ -> 0"
# Expected: 100

dotnet run --project FunLang -- -e "match 2 with | 1 -> 100 | _ -> 0"
# Expected: 0

dotnet run --project FunLang -- -e "match [1, 2] with | [] -> 0 | h :: t -> h"
# Expected: 1
```
  </verify>
  <done>
Match expressions evaluate correctly. Sequential matching works. Non-exhaustive matches raise runtime errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive integration tests</name>
  <files>tests/pattern-matching/*.flt, tests/Makefile</files>
  <action>
Create `tests/pattern-matching/` directory with 12 fslit integration tests:

1. **01-match-constant-int.flt** - Match integer constants
   ```
   // --- Command: dotnet run --project FunLang -- %input
   // --- Input:
   match 1 with
   | 1 -> "one"
   | 2 -> "two"
   | _ -> "other"
   // --- Output:
   "one"
   ```

2. **02-match-constant-bool.flt** - Match boolean constants
   ```
   // --- Command: dotnet run --project FunLang -- %input
   // --- Input:
   match true with
   | true -> 1
   | false -> 0
   // --- Output:
   1
   ```

3. **03-match-wildcard.flt** - Wildcard pattern as default
   ```
   // --- Command: dotnet run --project FunLang -- %input
   // --- Input:
   match 42 with
   | 1 -> "one"
   | _ -> "other"
   // --- Output:
   "other"
   ```

4. **04-match-variable.flt** - Variable pattern captures value
   ```
   // --- Command: dotnet run --project FunLang -- %input
   // --- Input:
   match 5 with
   | x -> x * 2
   // --- Output:
   10
   ```

5. **05-match-empty-list.flt** - Empty list pattern
   ```
   // --- Command: dotnet run --project FunLang -- %input
   // --- Input:
   match [] with
   | [] -> "empty"
   | _ -> "not empty"
   // --- Output:
   "empty"
   ```

6. **06-match-cons.flt** - Cons pattern h :: t
   ```
   // --- Command: dotnet run --project FunLang -- %input
   // --- Input:
   match [1, 2, 3] with
   | [] -> 0
   | h :: t -> h
   // --- Output:
   1
   ```

7. **07-match-cons-tail.flt** - Cons pattern with tail usage
   ```
   // --- Command: dotnet run --project FunLang -- %input
   // --- Input:
   match [1, 2, 3] with
   | h :: t -> t
   // --- Output:
   [2, 3]
   ```

8. **08-match-tuple.flt** - Tuple pattern in match
   ```
   // --- Command: dotnet run --project FunLang -- %input
   // --- Input:
   match (1, 2) with
   | (x, y) -> x + y
   // --- Output:
   3
   ```

9. **09-match-nested-tuple.flt** - Nested tuple pattern
   ```
   // --- Command: dotnet run --project FunLang -- %input
   // --- Input:
   match ((1, 2), 3) with
   | ((a, b), c) -> a + b + c
   // --- Output:
   6
   ```

10. **10-match-first-wins.flt** - First matching pattern wins
    ```
    // --- Command: dotnet run --project FunLang -- %input
    // --- Input:
    match 1 with
    | x -> "first"
    | 1 -> "second"
    // --- Output:
    "first"
    ```

11. **11-match-failure.flt** - Non-exhaustive match error
    ```
    // --- Command: dotnet run --project FunLang -- %input
    // --- Input:
    match 5 with
    | 1 -> "one"
    | 2 -> "two"
    // --- Expected-Error:
    Match failure
    ```

12. **12-match-recursive.flt** - Match in recursive function (sum list)
    ```
    // --- Command: dotnet run --project FunLang -- %input
    // --- Input:
    let rec sum xs =
        match xs with
        | [] -> 0
        | h :: t -> h + sum t
    in sum [1, 2, 3, 4, 5]
    // --- Output:
    15
    ```

Update tests/Makefile to add `pattern-matching` target:
```makefile
pattern-matching:
	python3 fslit.py pattern-matching/*.flt
```

And add to `all` target.
  </action>
  <verify>
Run pattern matching tests:
```bash
make -C tests pattern-matching
```
All 12 tests should pass.

Run full test suite:
```bash
make -C tests
dotnet run --project FunLang.Tests
```
All tests should pass.
  </verify>
  <done>
12 pattern matching tests created and passing. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   dotnet build FunLang
   ```

2. **Success criteria tests:**
   ```bash
   # SC1: Constant pattern matching
   dotnet run --project FunLang -- -e 'match 1 with | 1 -> "one" | _ -> "other"'
   # Expected: "one"

   # SC2: List cons pattern
   dotnet run --project FunLang -- -e 'match [1, 2] with | [] -> 0 | h :: t -> h'
   # Expected: 1

   # SC3: Tuple pattern
   dotnet run --project FunLang -- -e 'match (1, 2) with | (x, y) -> x + y'
   # Expected: 3

   # SC4: Match failure
   dotnet run --project FunLang -- -e 'match 5 with | 1 -> 1'
   # Expected: Error containing "Match failure"
   ```

3. **Full test suite:**
   ```bash
   make -C tests
   dotnet run --project FunLang.Tests
   ```
   All tests pass.
</verification>

<success_criteria>
From ROADMAP.md Phase 3 success criteria:

1. `match 1 with | 1 -> "one" | _ -> "other"` returns `"one"`
2. `match [1, 2] with | [] -> 0 | h :: t -> h` returns 1
3. `match (1, 2) with | (x, y) -> x + y` returns 3
4. Non-exhaustive match raises runtime error ("Match failure")
5. (SC5 deferred - exhaustiveness warnings are post-v3.0)

Additional verification:
- All 8 PAT requirements covered (PAT-01 through PAT-08, with PAT-08 as runtime-only)
- 12+ new integration tests
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-pattern-matching/03-02-SUMMARY.md`
</output>
