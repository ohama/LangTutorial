---
phase: 02-lists
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Ast.fs
  - FunLang/Lexer.fsl
  - FunLang/Parser.fsy
autonomous: true

must_haves:
  truths:
    - "Empty list [] can be parsed and evaluated"
    - "List literal [1, 2, 3] can be parsed"
    - "Cons operator :: can be parsed"
    - "Cons is right-associative (1 :: 2 :: [] groups as 1 :: (2 :: []))"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "List AST types (EmptyList, List, Cons, ListValue)"
      contains: "| ListValue of Value list"
    - path: "FunLang/Lexer.fsl"
      provides: "List tokens (LBRACKET, RBRACKET, CONS)"
      contains: "LBRACKET"
    - path: "FunLang/Parser.fsy"
      provides: "List grammar rules"
      contains: "%right CONS"
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "List grammar rules produce List/EmptyList/Cons AST nodes"
      pattern: "LBRACKET.*EmptyList|List|Cons"
    - from: "FunLang/Parser.fsy"
      to: "%right CONS"
      via: "Cons operator right-associativity"
      pattern: "%right CONS"
---

<objective>
Add list infrastructure to AST, Lexer, and Parser to support empty lists, list literals, and cons operator syntax.

Purpose: Establish the foundation for list data structures in FunLang, following the same pattern as Phase 1 (Tuples).
Output: AST types, lexer tokens, and parser grammar for list construction expressions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-lists/02-RESEARCH.md
@FunLang/Ast.fs
@FunLang/Lexer.fsl
@FunLang/Parser.fsy
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AST with List types</name>
  <files>FunLang/Ast.fs</files>
  <action>
Add list expression and value types to Ast.fs following the research recommendations and existing Tuple pattern.

Add to Expr type (after Tuple/LetPat):
- `EmptyList` - Empty list literal: []
- `List of Expr list` - List literal (syntactic sugar): [e1, e2, e3]
- `Cons of Expr * Expr` - Cons operator: head :: tail

Add to Value type (after TupleValue):
- `ListValue of Value list` - Runtime list representation

Follow the same comment style as Phase 1 (v3.0): Tuples:
```fsharp
// Phase 2 (v3.0): Lists
| EmptyList                    // Empty list: []
| List of Expr list            // List literal: [e1, e2, ...]
| Cons of Expr * Expr          // Cons operator: h :: t
```

And for Value:
```fsharp
| ListValue of Value list  // v3.0: List values
```

Do NOT modify Pattern type - list patterns are Phase 3 (Pattern Matching).
  </action>
  <verify>Build succeeds: dotnet build FunLang/FunLang.fsproj</verify>
  <done>Ast.fs contains EmptyList, List, Cons expressions and ListValue type with proper comments</done>
</task>

<task type="auto">
  <name>Task 2: Add list tokens to Lexer</name>
  <files>FunLang/Lexer.fsl</files>
  <action>
Add tokens for list syntax to Lexer.fsl.

In the rules section (after existing tokens like COMMA, UNDERSCORE):
- `'['` → `LBRACKET` token
- `']'` → `RBRACKET` token
- `"::"` → `CONS` token (cons operator, two colons)

Use the same pattern as existing single-character tokens:
```fsharp
| '['           { LBRACKET }
| ']'           { RBRACKET }
```

For cons operator (two characters), use the same pattern as existing multi-char operators (<=, >=, <>, etc.):
```fsharp
| "::"          { CONS }
```

Place these rules in logical order with existing operators. Bracket tokens should be near parentheses, cons operator near other operators.
  </action>
  <verify>Build succeeds: dotnet build FunLang/FunLang.fsproj</verify>
  <done>Lexer.fsl recognizes [, ], and :: tokens. Build produces updated Lexer.fs without errors</done>
</task>

<task type="auto">
  <name>Task 3: Add list grammar to Parser</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Add list grammar rules to Parser.fsy following research recommendations.

1. Add token declarations (after COMMA, UNDERSCORE):
```fsharp
%token LBRACKET RBRACKET CONS
```

2. Add precedence declaration for cons operator (CRITICAL - right-associative):
Place AFTER comparison operators (%nonassoc EQUALS LT GT LE GE NE) and BEFORE start symbol declaration:
```fsharp
%right CONS    // Right-associative: 1 :: 2 :: [] = 1 :: (2 :: [])
```

3. Add cons operator to Expr level (after comparison operators, BEFORE arithmetic):
```fsharp
| Expr CONS Expr                 { Cons($1, $3) }
```
This gives cons lower precedence than arithmetic, matching F# behavior (prevents 1 + 2 :: xs ambiguity).

4. Add list literals to Atom (after tuple rule):
```fsharp
// Phase 2 (v3.0): List literals
| LBRACKET RBRACKET                      { EmptyList }
| LBRACKET Expr COMMA ExprList RBRACKET  { List($2 :: $4) }
```

The ExprList rule already exists from Phase 1 (tuples), so reuse it. This allows comma-separated expressions inside brackets.

Note: Empty list [] and single-element list [x] are different productions. [x] requires at least one comma to be a list, otherwise it would be ambiguous with future array indexing. Actually, single element should work - let me check the grammar. The pattern `LBRACKET Expr COMMA ExprList RBRACKET` requires at least 2 elements. We need to add:
```fsharp
| LBRACKET Expr RBRACKET                 { List([$2]) }
```
to support single-element lists [1]. Place this BEFORE the multi-element rule.

So the complete list literal rules are:
```fsharp
// Phase 2 (v3.0): List literals
| LBRACKET RBRACKET                      { EmptyList }
| LBRACKET Expr RBRACKET                 { List([$2]) }  // Single element
| LBRACKET Expr COMMA ExprList RBRACKET  { List($2 :: $4) }  // Multiple elements
```

Follow existing comment style and placement patterns.
  </action>
  <verify>Build succeeds without parser conflicts: dotnet build FunLang/FunLang.fsproj. Check build output for "0 shift/reduce conflicts"</verify>
  <done>Parser.fsy contains list grammar rules, %right CONS precedence, no parser conflicts, Lexer.fs and Parser.fs generated successfully</done>
</task>

</tasks>

<verification>
1. Build completes without errors: `dotnet build`
2. No parser shift/reduce conflicts in build output
3. Ast.fs contains EmptyList, List, Cons, ListValue types
4. Lexer.fsl generates LBRACKET, RBRACKET, CONS tokens
5. Parser.fsy has %right CONS and list grammar rules
6. All existing tests still pass: `make -C tests && dotnet run --project FunLang.Tests`
</verification>

<success_criteria>
1. Empty list syntax [] is recognized by parser
2. List literal syntax [1, 2, 3] is recognized by parser
3. Cons operator syntax 1 :: xs is recognized by parser
4. Right-associativity: 1 :: 2 :: [] parses as Cons(1, Cons(2, EmptyList))
5. No parser conflicts introduced
6. All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-lists/02-01-SUMMARY.md`
</output>
