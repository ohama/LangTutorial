---
phase: 01-tuples
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Ast.fs
  - FunLang/Lexer.fsl
  - FunLang/Parser.fsy
autonomous: true

must_haves:
  truths:
    - "Tuple literal syntax (1, 2) parses without error"
    - "Tuple pattern syntax let (x, y) = e parses without error"
    - "Nested tuples ((1, 2), 3) parse correctly"
    - "Existing tests still pass (no parser regressions)"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "Tuple, TupleValue, Pattern, LetPat types"
      contains: "| Tuple of Expr list"
    - path: "FunLang/Lexer.fsl"
      provides: "COMMA token"
      contains: "| ','"
    - path: "FunLang/Parser.fsy"
      provides: "Tuple grammar rules"
      contains: "%token COMMA"
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "Tuple, LetPat constructors"
      pattern: "Tuple\\(\\$"
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Lexer.fsl"
      via: "COMMA token"
      pattern: "COMMA"
---

<objective>
Implement tuple syntax infrastructure: AST types, lexer token, and parser grammar.

Purpose: Enable parsing of tuple literals `(1, 2)` and tuple patterns `let (x, y) = e`. This is the foundation for Phase 1 tuples - evaluation comes in Plan 02.

Output: Modified Ast.fs, Lexer.fsl, Parser.fsy that parse tuple syntax into AST nodes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-tuples/01-RESEARCH.md
@FunLang/Ast.fs
@FunLang/Lexer.fsl
@FunLang/Parser.fsy
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AST with Tuple and Pattern types</name>
  <files>FunLang/Ast.fs</files>
  <action>
Add the following to Ast.fs:

1. Add to `Expr` discriminated union:
   - `| Tuple of Expr list` - Tuple expression (e.g., `(1, 2, 3)`)
   - `| LetPat of Pattern * Expr * Expr` - Let with pattern binding

2. Add new `Pattern` discriminated union (after Expr definition, before Value):
   ```fsharp
   /// Pattern for destructuring bindings
   /// Phase 1: Tuple patterns
   and Pattern =
       | VarPat of string           // Variable pattern: x
       | TuplePat of Pattern list   // Tuple pattern: (p1, p2, ...)
       | WildcardPat                // Wildcard pattern: _
   ```

3. Add to `Value` discriminated union:
   - `| TupleValue of Value list` - Runtime tuple value

The `Pattern` type must use `and` because it references `Expr` (through LetPat) and `Value` (through evaluation). Place it between Expr and Value definitions with mutual recursion.
  </action>
  <verify>
Run `dotnet build FunLang/FunLang.fsproj` - should compile successfully (Parser/Eval may have warnings about incomplete matches, that's expected).
  </verify>
  <done>
Ast.fs contains Tuple, LetPat, Pattern (VarPat, TuplePat, WildcardPat), and TupleValue types. Project builds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add COMMA token to Lexer</name>
  <files>FunLang/Lexer.fsl</files>
  <action>
Add comma token to lexer:

1. In the main `tokenize` rule, add after the existing single-char operators (before `eof`):
   ```
   | ','           { COMMA }
   ```

Place it with other single-char operators (after RPAREN, before EQUALS or eof).

This is the only lexer change needed - the COMMA token declaration in Parser.fsy (Task 3) will make it available.
  </action>
  <verify>
Run `dotnet build FunLang/FunLang.fsproj` - should compile. The Parser.fsy must also declare COMMA for this to work, so this may fail until Task 3 is complete.
  </verify>
  <done>
Lexer.fsl contains `| ','  { COMMA }` rule that produces COMMA token.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend Parser with Tuple grammar</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Extend parser for tuple expressions and tuple patterns. This is the most complex task - follow the grammar design from RESEARCH.md carefully.

1. Add token declaration (after existing tokens, before precedence):
   ```
   %token COMMA
   ```

2. Modify the `Expr` rule to support `LetPat`:
   Add after the existing `LET IDENT EQUALS Expr IN Expr` rule:
   ```
   | LET TuplePattern EQUALS Expr IN Expr  { LetPat($2, $4, $6) }
   ```

3. Add `TuplePattern` rule (before or after Expr rule):
   ```
   TuplePattern:
       | LPAREN PatternList RPAREN  { TuplePat($2) }
       | IDENT                       { VarPat($1) }
       | '_'                         { WildcardPat }

   PatternList:
       | Pattern COMMA Pattern       { [$1; $3] }
       | Pattern COMMA PatternList   { $1 :: $3 }

   Pattern:
       | LPAREN PatternList RPAREN  { TuplePat($2) }
       | IDENT                       { VarPat($1) }
       | '_'                         { WildcardPat }
   ```

4. Modify the `Atom` rule to support tuple expressions.
   The key insight from RESEARCH.md: use lookahead to distinguish `(expr)` from `(expr, expr)`.

   Replace the existing `LPAREN Expr RPAREN` rule in Atom with:
   ```
   | LPAREN Expr RPAREN             { $2 }
   | LPAREN Expr COMMA ExprList RPAREN  { Tuple($2 :: $4) }
   ```

   Add `ExprList` rule:
   ```
   ExprList:
       | Expr                        { [$1] }
       | Expr COMMA ExprList         { $1 :: $3 }
   ```

5. Handle underscore for wildcard pattern:
   The lexer already handles `_` as part of identifiers (ident_start includes `_`).
   This should work as-is since `_` will be lexed as IDENT.

   ALTERNATIVE: If this causes issues, add explicit underscore token:
   - In Parser.fsy: `%token UNDERSCORE`
   - In Lexer.fsl: `| '_' { UNDERSCORE }` (before ident_start rule)
   - In Parser: `| UNDERSCORE { WildcardPat }`

   Try without explicit underscore first - if `_` as IDENT works, keep it simple.

CRITICAL: The grammar must avoid shift/reduce conflicts with parentheses. The pattern `LPAREN Expr COMMA ...` distinguishes tuples from grouped expressions. Test that `(1)` still parses as grouped expression, not 1-tuple.
  </action>
  <verify>
1. `dotnet build FunLang/FunLang.fsproj` - should compile (warnings about incomplete pattern matches in Eval.fs are expected)
2. Check for parser conflicts in build output - there should be 0 shift/reduce conflicts
3. Run existing tests: `make -C tests` - ALL existing tests must pass (no regressions)
  </verify>
  <done>
Parser.fsy contains COMMA token, Tuple and LetPat grammar rules, TuplePattern/Pattern rules. Project builds without parser conflicts. All 66 existing fslit tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build succeeds:**
   ```bash
   dotnet build FunLang/FunLang.fsproj
   ```

2. **No parser conflicts:** Check build output for "shift/reduce" or "reduce/reduce" - should be 0.

3. **Existing tests pass (CRITICAL):**
   ```bash
   make -C tests
   ```
   All 66 tests must pass. Any failures indicate grammar regression.

4. **Tuple syntax parses (smoke test):**
   ```bash
   echo '(1, 2)' | dotnet run --project FunLang -- -
   ```
   This may error in evaluation (not implemented yet), but should NOT error in parsing.

   ```bash
   echo 'let (x, y) = (1, 2) in x' | dotnet run --project FunLang -- -
   ```
   Same - parsing should work, evaluation error expected.
</verification>

<success_criteria>
1. AST types added: Tuple, TupleValue, Pattern (VarPat, TuplePat, WildcardPat), LetPat
2. Lexer produces COMMA token for `,`
3. Parser accepts tuple expressions: `(1, 2)`, `(1, 2, 3)`, `((1, 2), 3)`
4. Parser accepts tuple patterns: `let (x, y) = e in body`
5. No parser conflicts (shift/reduce or reduce/reduce)
6. All 66 existing tests pass (no regressions)
7. Project compiles (Eval.fs warnings about incomplete matches are OK)
</success_criteria>

<output>
After completion, create `.planning/phases/01-tuples/01-01-SUMMARY.md`
</output>
