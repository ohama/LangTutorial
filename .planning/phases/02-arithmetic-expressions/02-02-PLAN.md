---
phase: 02-arithmetic-expressions
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - FunLang/Parser.fsy
  - FunLang/Lexer.fsl
  - FunLang/Program.fs
autonomous: true

must_haves:
  truths:
    - "Parser correctly handles operator precedence (* / before + -)"
    - "Parser correctly handles parentheses for precedence override"
    - "Parser correctly handles unary minus"
    - "Parser correctly handles left associativity (2-3-4 = -5, not 3)"
    - "Full pipeline produces correct results for all success criteria"
  artifacts:
    - path: "FunLang/Parser.fsy"
      provides: "Expr/Term/Factor grammar with operator precedence"
      contains: "Expr PLUS Term"
    - path: "FunLang/Lexer.fsl"
      provides: "Operator and parenthesis tokens"
      contains: "PLUS"
    - path: "FunLang/Program.fs"
      provides: "Test runner with all Phase 2 test cases"
      contains: "2 + 3 * 4"
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "semantic actions"
      pattern: "Add\\(\\$1, \\$3\\)"
    - from: "FunLang/Lexer.fsl"
      to: "FunLang/Parser.fsy"
      via: "token types"
      pattern: "PLUS|MINUS|STAR|SLASH"
    - from: "FunLang/Program.fs"
      to: "FunLang/Eval.fs"
      via: "eval function call"
      pattern: "Eval\\.eval"
---

<objective>
Implement the parser grammar and lexer tokens for arithmetic expressions, then wire everything together in Program.fs.

Purpose: Complete the Phase 2 feature by connecting the AST and evaluator to the parsing pipeline. Uses the Expr/Term/Factor grammar pattern (from research) to encode operator precedence directly in the grammar structure, avoiding FsYacc's known bugs with %left/%right declarations.

Output: Updated Parser.fsy with full arithmetic grammar, updated Lexer.fsl with operator tokens, updated Program.fs with test cases demonstrating all success criteria.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-arithmetic-expressions/02-RESEARCH.md

# Existing source files
@FunLang/Parser.fsy
@FunLang/Lexer.fsl
@FunLang/Program.fs

# From Plan 01 (will exist when this runs)
# Ast.fs with Add, Subtract, Multiply, Divide, Negate
# Eval.fs with eval function
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand parser with Expr/Term/Factor grammar</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Rewrite Parser.fsy with the Expr/Term/Factor grammar pattern for operator precedence:

```fsharp
%{
open Ast
%}

// Token declarations
%token <int> NUMBER
%token PLUS MINUS STAR SLASH
%token LPAREN RPAREN
%token EOF

// Start symbol and its type
%start start
%type <Ast.Expr> start

%%

// Grammar rules using Expr/Term/Factor pattern for precedence
// Lower precedence (+ -) at higher grammar level
// Higher precedence (* /) at lower grammar level

start:
    | Expr EOF           { $1 }

Expr:
    | Expr PLUS Term     { Add($1, $3) }
    | Expr MINUS Term    { Subtract($1, $3) }
    | Term               { $1 }

Term:
    | Term STAR Factor   { Multiply($1, $3) }
    | Term SLASH Factor  { Divide($1, $3) }
    | Factor             { $1 }

Factor:
    | NUMBER             { Number($1) }
    | LPAREN Expr RPAREN { $2 }
    | MINUS Factor       { Negate($2) }
```

Key design decisions (from RESEARCH.md):
- Use Expr/Term/Factor stratification, NOT %left/%right (FsYacc bugs)
- Left recursion is correct for LALR parsers (left associativity)
- Unary minus in Factor gives it highest precedence
- LPAREN Expr RPAREN allows parentheses to override precedence
  </action>
  <verify>
Run `dotnet build FunLang/FunLang.fsproj` - should regenerate Parser.fs and Parser.fsi without errors.
Check that no shift-reduce or reduce-reduce conflicts are reported.
  </verify>
  <done>
- Parser.fsy contains Expr/Term/Factor grammar
- All 6 tokens declared (NUMBER, PLUS, MINUS, STAR, SLASH, LPAREN, RPAREN, EOF)
- Build succeeds with no grammar conflicts
  </done>
</task>

<task type="auto">
  <name>Task 2: Expand lexer with operator tokens</name>
  <files>FunLang/Lexer.fsl</files>
  <action>
Update Lexer.fsl to recognize the new operator and parenthesis tokens:

```fsharp
{
open System
open FSharp.Text.Lexing
open Parser  // Import token types from generated Parser module

// Helper to get lexeme as string
let lexeme (lexbuf: LexBuffer<_>) =
    LexBuffer<_>.LexemeString lexbuf
}

// Character class definitions
let digit = ['0'-'9']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')

// Lexer rules
rule tokenize = parse
    | whitespace+   { tokenize lexbuf }           // Skip whitespace
    | newline       { tokenize lexbuf }           // Skip newlines
    | digit+        { NUMBER (Int32.Parse(lexeme lexbuf)) }  // Integer literal
    | '+'           { PLUS }
    | '-'           { MINUS }
    | '*'           { STAR }
    | '/'           { SLASH }
    | '('           { LPAREN }
    | ')'           { RPAREN }
    | eof           { EOF }                       // End of input
```

Key points:
- All operators are single characters (simple patterns)
- MINUS is used for both binary subtraction and unary negation (grammar disambiguates)
- Whitespace continues to be skipped
- Order doesn't matter for single-character tokens
  </action>
  <verify>
Run `dotnet build FunLang/FunLang.fsproj` - should regenerate Lexer.fs without errors.
  </verify>
  <done>
- Lexer.fsl recognizes: +, -, *, /, (, )
- Build succeeds
- Lexer generates correct tokens for each operator
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire everything in Program.fs with test cases</name>
  <files>FunLang/Program.fs</files>
  <action>
Update Program.fs to:
1. Import Eval module
2. Add evaluator to the pipeline
3. Run all Phase 2 success criteria as test cases

```fsharp
open System
open FSharp.Text.Lexing
open Ast
open Eval

/// Parse a string input and return the AST
let parse (input: string) : Expr =
    let lexbuf = LexBuffer<char>.FromString input
    Parser.start Lexer.tokenize lexbuf

[<EntryPoint>]
let main argv =
    // Phase 2 success criteria test cases
    let testCases = [
        ("42", 42)                    // Number (Phase 1 regression)
        ("2 + 3", 5)                  // Simple addition
        ("2 + 3 * 4", 14)             // Precedence: * before +
        ("(2 + 3) * 4", 20)           // Parentheses override
        ("10 / 2 - 3", 2)             // Left associativity
        ("-5 + 3", -2)                // Unary minus
        ("2 - 3 - 4", -5)             // Left associativity for -
        ("--5", 5)                    // Double negation
        ("-(2 + 3)", -5)              // Negate expression
    ]

    printfn "FunLang Interpreter - Phase 2: Arithmetic Expressions"
    printfn "======================================================"
    printfn ""

    let mutable allPassed = true
    for (input, expected) in testCases do
        try
            let ast = parse input
            let result = eval ast
            let status = if result = expected then "PASS" else "FAIL"
            if result <> expected then allPassed <- false
            printfn "[%s] \"%s\" = %d (expected %d)" status input result expected
        with
        | ex ->
            allPassed <- false
            printfn "[FAIL] \"%s\" threw exception: %s" input ex.Message

    printfn ""
    if allPassed then
        printfn "All tests passed!"
        0
    else
        printfn "Some tests failed."
        1
```

The test cases verify:
- Basic numbers (Phase 1 regression)
- Simple operations
- Operator precedence (* / before + -)
- Parentheses override
- Left associativity
- Unary minus (single, double, with expressions)
  </action>
  <verify>
Run `dotnet run --project FunLang/FunLang.fsproj` and verify all tests pass:
- Expected output shows [PASS] for all 9 test cases
- Exit code is 0
  </verify>
  <done>
- Program.fs imports and uses Eval.eval
- All 9 test cases pass
- Output shows "All tests passed!"
- Exit code is 0
  </done>
</task>

</tasks>

<verification>
After all tasks complete, run the full verification:

```bash
# Clean build to regenerate Parser.fs and Lexer.fs
dotnet clean FunLang/FunLang.fsproj
dotnet build FunLang/FunLang.fsproj

# Run and verify all tests pass
dotnet run --project FunLang/FunLang.fsproj
```

Expected output:
```
FunLang Interpreter - Phase 2: Arithmetic Expressions
======================================================

[PASS] "42" = 42 (expected 42)
[PASS] "2 + 3" = 5 (expected 5)
[PASS] "2 + 3 * 4" = 14 (expected 14)
[PASS] "(2 + 3) * 4" = 20 (expected 20)
[PASS] "10 / 2 - 3" = 2 (expected 2)
[PASS] "-5 + 3" = -2 (expected -2)
[PASS] "2 - 3 - 4" = -5 (expected -5)
[PASS] "--5" = 5 (expected 5)
[PASS] "-(2 + 3)" = -5 (expected -5)

All tests passed!
```

Phase 2 Requirements Verification:
- EXPR-01 (사칙연산): Verified by test cases with +, -, *, /
- EXPR-02 (연산자 우선순위): "2 + 3 * 4" = 14 proves * before +
- EXPR-03 (괄호 우선순위): "(2 + 3) * 4" = 20 proves parentheses work
- EXPR-04 (단항 마이너스): "-5 + 3" = -2 proves unary minus works
</verification>

<success_criteria>
- [ ] Parser.fsy updated with Expr/Term/Factor grammar
- [ ] No shift-reduce or reduce-reduce conflicts
- [ ] Lexer.fsl updated with operator tokens (+, -, *, /, (, ))
- [ ] Program.fs wires parse -> eval pipeline
- [ ] All 9 test cases pass
- [ ] Requirements EXPR-01, EXPR-02, EXPR-03, EXPR-04 verified
- [ ] `dotnet run` exits with code 0
</success_criteria>

<output>
After completion, create `.planning/phases/02-arithmetic-expressions/02-02-SUMMARY.md`
</output>
