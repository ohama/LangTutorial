---
phase: 01-foundation-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - FunLang/Program.fs
autonomous: true

must_haves:
  truths:
    - "Program.fs wires lexer and parser together"
    - "Running the program with input '42' outputs the parsed AST"
    - "The complete pipeline (lex -> parse -> AST) works end-to-end"
  artifacts:
    - path: "FunLang/Program.fs"
      provides: "Main entry point that runs parser pipeline"
      contains: "Parser.start"
      min_lines: 15
  key_links:
    - from: "FunLang/Program.fs"
      to: "Parser module"
      via: "Parser.start call"
      pattern: "Parser\\.start"
    - from: "FunLang/Program.fs"
      to: "Lexer module"
      via: "Lexer.tokenize call"
      pattern: "Lexer\\.tokenize"
    - from: "FunLang/Program.fs"
      to: "LexBuffer"
      via: "LexBuffer.FromString"
      pattern: "LexBuffer.*FromString"
---

<objective>
Wire lexer and parser together in Program.fs and verify the complete pipeline.

Purpose: Prove the entire foundation works end-to-end. This is the capstone of Phase 1 - a working compilation pipeline.
Output: Running `dotnet run` parses input and displays the AST.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-pipeline/01-RESEARCH.md
@.planning/phases/01-foundation-pipeline/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Program.fs with parser pipeline</name>
  <files>FunLang/Program.fs</files>
  <action>
Replace the content of `FunLang/Program.fs` with:

```fsharp
open System
open Microsoft.FSharp.Text.Lexing
open Ast

/// Parse a string input and return the AST
let parse (input: string) : Expr =
    let lexbuf = LexBuffer<char>.FromString input
    Parser.start Lexer.tokenize lexbuf

[<EntryPoint>]
let main argv =
    // Test input - just a number for Phase 1
    let testInput = "42"

    printfn "FunLang Interpreter - Phase 1: Foundation"
    printfn "========================================="
    printfn ""
    printfn "Input: %s" testInput

    try
        let ast = parse testInput
        printfn "AST: %A" ast
        printfn ""
        printfn "Pipeline successful!"
        0  // Success exit code
    with
    | ex ->
        printfn "Error: %s" ex.Message
        1  // Error exit code
```

Key elements:
- Opens LexBuffer from Microsoft.FSharp.Text.Lexing (FsLexYacc.Runtime)
- parse function: creates LexBuffer from string, calls Parser.start with Lexer.tokenize
- Main function: tests with "42", prints parsed AST
- Error handling: catches exceptions and prints error message

The parse function shows the canonical pattern:
1. Create LexBuffer from input string
2. Call parser's start symbol with lexer's tokenize function
3. Parser returns AST (Expr in our case)

This wiring pattern is reused in every phase.
  </action>
  <verify>
Run `dotnet build FunLang` - should succeed.
Run `dotnet run --project FunLang` - should output "AST: Number 42".
  </verify>
  <done>Program.fs wires lexer and parser, running produces "AST: Number 42".</done>
</task>

<task type="auto">
  <name>Task 2: Verify complete pipeline and document build order</name>
  <files>FunLang/FunLang.fsproj</files>
  <action>
Add a comment block at the top of `FunLang.fsproj` (after the Project element) documenting the build order:

```xml
<!--
  FunLang - F# Language Implementation Tutorial

  BUILD ORDER (CRITICAL):
  =======================
  1. Ast.fs       - AST type definitions (Discriminated Unions)
  2. Parser.fsy   - fsyacc specification (generates Parser.fs, Parser.fsi)
  3. Lexer.fsl    - fslex specification (generates Lexer.fs)
  4. Parser.fsi   - Generated parser signature
  5. Parser.fs    - Generated parser implementation
  6. Lexer.fs     - Generated lexer implementation
  7. Program.fs   - Main entry point

  WHY THIS ORDER:
  - Lexer.fsl opens Parser to access token types (NUMBER, EOF, etc.)
  - Parser must be generated BEFORE Lexer can compile
  - F# requires files to be ordered by dependency (no forward references)

  COMMON PITFALL:
  If you get "Parser module not found" or "NUMBER is not defined",
  check that FsYacc comes BEFORE FsLex in the ItemGroup below.
-->
```

Then run the full verification suite:

1. Clean and rebuild: `dotnet clean FunLang && dotnet build FunLang`
2. Run the program: `dotnet run --project FunLang`
3. Verify output shows "AST: Number 42"

This proves:
- FOUND-01: .NET 10 + FsLexYacc project configured correctly
- FOUND-02: fslex generates Lexer.fs from Lexer.fsl
- FOUND-03: fsyacc generates Parser.fs from Parser.fsy
- FOUND-04: Discriminated Union Expr type works with parser output
  </action>
  <verify>
1. `dotnet clean FunLang && dotnet build FunLang` succeeds
2. `dotnet run --project FunLang` outputs "AST: Number 42"
3. FunLang.fsproj contains build order documentation comment
  </verify>
  <done>Complete pipeline verified. Build order documented in .fsproj.</done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` succeeds
2. `dotnet run --project FunLang` produces:
   ```
   FunLang Interpreter - Phase 1: Foundation
   =========================================

   Input: 42
   AST: Number 42

   Pipeline successful!
   ```
3. Build order comment exists in FunLang.fsproj
4. All Phase 1 requirements verified:
   - FOUND-01: Project setup complete
   - FOUND-02: fslex working
   - FOUND-03: fsyacc working
   - FOUND-04: AST types working
</verification>

<success_criteria>
- Program.fs compiles and runs
- Parser pipeline works end-to-end
- "42" input produces "Number 42" AST output
- Build order documented in .fsproj
- All 4 Phase 1 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-pipeline/01-03-SUMMARY.md`
</output>
