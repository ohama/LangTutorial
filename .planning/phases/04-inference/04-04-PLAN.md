---
phase: 04-inference
plan: 04
type: execute
wave: 3
depends_on: [04-02]
files_modified: [FunLang/Infer.fs]
autonomous: true

must_haves:
  truths:
    - "If condition must be bool, branches must have same type"
    - "Tuple infers product type from element types"
    - "EmptyList infers polymorphic list type with fresh element"
    - "List literals unify all elements to same type"
    - "Cons unifies head with list element type"
  artifacts:
    - path: "FunLang/Infer.fs"
      provides: "infer cases for If, Tuple, EmptyList, List, Cons"
      contains: "If|Tuple|EmptyList|List|Cons"
  key_links:
    - from: "infer If"
      to: "unify"
      via: "branch type unification"
      pattern: "unify.*thenTy.*elseTy"
    - from: "infer List"
      to: "unify"
      via: "element type unification"
      pattern: "unify.*elemTy"
---

<objective>
Implement infer cases for If, Tuple, EmptyList, List, and Cons expressions.

Purpose: These handle control flow and data structures. If requires branch unification, Tuple builds product types, and List/EmptyList/Cons handle parametric list types. This covers INFER-10, INFER-11, INFER-12.
Output: Complete data structure type inference.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-inference/04-RESEARCH.md
@.planning/phases/04-inference/04-02-SUMMARY.md
@FunLang/Type.fs
@FunLang/Unify.fs
@FunLang/Ast.fs
@FunLang/Infer.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add If expression inference</name>
  <files>FunLang/Infer.fs</files>
  <action>
Add If case to the infer match expression:

```fsharp
    // === If expression (INFER-10) ===
    | If (cond, thenExpr, elseExpr) ->
        let s1, condTy = infer env cond
        let s2, thenTy = infer (applyEnv s1 env) thenExpr
        let s3, elseTy = infer (applyEnv (compose s2 s1) env) elseExpr
        // Condition must be bool
        let s4 = unify (apply (compose s3 (compose s2 s1)) condTy) TBool
        // Branches must have same type
        let s5 = unify (apply s4 thenTy) (apply s4 elseTy)
        let finalSubst = compose s5 (compose s4 (compose s3 (compose s2 s1)))
        (finalSubst, apply s5 thenTy)
```

Key pattern: Thread substitution through all three subexpressions, then unify condition with bool and branches with each other.
  </action>
  <verify>
```bash
dotnet fsi --exec <<'EOF'
#r "FunLang/bin/Debug/net8.0/FunLang.dll"
open Type
open Ast
open Infer

let env: TypeEnv = Map.empty

// if true then 1 else 2
let _, t1 = infer env (If (Bool true, Number 1, Number 2))
printfn "if true then 1 else 2: %s (expect int)" (formatType t1)

// if x < 0 then -x else x (via lambda to bind x)
let _, t2 = infer env (Lambda ("x",
    If (LessThan (Var "x", Number 0), Negate (Var "x"), Var "x")))
printfn "fun x -> if x < 0 then -x else x: %s (expect int -> int)" (formatType t2)

// Type error: if 1 then ... (condition not bool)
try
    let _ = infer env (If (Number 1, Number 2, Number 3))
    printfn "ERROR: should have raised TypeError"
with
| Unify.TypeError msg -> printfn "Non-bool condition error: %s (expected)" msg
EOF
```
  </verify>
  <done>
- If condition unifies with TBool
- If branches unify to same type
- Result type is branch type after unification
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Tuple, EmptyList, List, Cons inference</name>
  <files>FunLang/Infer.fs</files>
  <action>
Add Tuple, EmptyList, List, Cons cases to the infer match expression:

```fsharp
    // === Tuple (INFER-11) ===
    | Tuple exprs ->
        let folder (s, tys) e =
            let s', ty = infer (applyEnv s env) e
            (compose s' s, ty :: tys)
        let finalS, revTys = List.fold folder (empty, []) exprs
        (finalS, TTuple (List.rev revTys))

    // === EmptyList (INFER-12) ===
    | EmptyList ->
        let elemTy = freshVar()
        (empty, TList elemTy)

    // === List literal (INFER-12) ===
    | List exprs ->
        match exprs with
        | [] ->
            let elemTy = freshVar()
            (empty, TList elemTy)
        | first :: rest ->
            let s1, elemTy = infer env first
            let folder (s, ty) e =
                let s', eTy = infer (applyEnv s env) e
                let s'' = unify (apply s' ty) eTy
                (compose s'' (compose s' s), apply s'' eTy)
            let finalS, elemTy' = List.fold folder (s1, elemTy) rest
            (finalS, TList elemTy')

    // === Cons (INFER-12) ===
    | Cons (head, tail) ->
        let s1, headTy = infer env head
        let s2, tailTy = infer (applyEnv s1 env) tail
        let s3 = unify tailTy (TList (apply s2 headTy))
        (compose s3 (compose s2 s1), apply s3 tailTy)
```

Key patterns:
- Tuple: fold accumulates substitution and collects types (reversed)
- EmptyList: fresh element type for polymorphism
- List: unify all elements to same type
- Cons: unify tail with TList of head type
  </action>
  <verify>
```bash
dotnet fsi --exec <<'EOF'
#r "FunLang/bin/Debug/net8.0/FunLang.dll"
open Type
open Ast
open Infer

let env: TypeEnv = Map.empty

// (1, true, "hi")
let _, t1 = infer env (Tuple [Number 1; Bool true; String "hi"])
printfn "(1, true, \"hi\"): %s (expect int * bool * string)" (formatType t1)

// []
let _, t2 = infer env EmptyList
printfn "[]: %s (expect 'a list)" (formatType t2)

// [1, 2, 3]
let _, t3 = infer env (List [Number 1; Number 2; Number 3])
printfn "[1, 2, 3]: %s (expect int list)" (formatType t3)

// 1 :: []
let _, t4 = infer env (Cons (Number 1, EmptyList))
printfn "1 :: []: %s (expect int list)" (formatType t4)

// 1 :: 2 :: []
let _, t5 = infer env (Cons (Number 1, Cons (Number 2, EmptyList)))
printfn "1 :: 2 :: []: %s (expect int list)" (formatType t5)

// Type error: 1 :: true :: []
try
    let _ = infer env (Cons (Number 1, Cons (Bool true, EmptyList)))
    printfn "ERROR: should have raised TypeError"
with
| Unify.TypeError msg -> printfn "Heterogeneous list error: %s (expected)" msg
EOF
```
  </verify>
  <done>
- Tuple infers TTuple with element types in order
- EmptyList infers TList with fresh element type
- List unifies all elements to same type
- Cons unifies head with list element type
- Type errors for heterogeneous lists
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` succeeds
2. If requires bool condition, unifies branch types
3. Tuple infers correct product type
4. EmptyList has polymorphic element type
5. List/Cons enforce homogeneous element types
</verification>

<success_criteria>
- If infers with bool condition constraint and branch unification
- Tuple infers TTuple with correct element order
- EmptyList uses fresh type variable (polymorphic)
- List literal unifies all elements
- Cons unifies head with TList element
- Heterogeneous lists rejected with TypeError
</success_criteria>

<output>
After completion, create `.planning/phases/04-inference/04-04-SUMMARY.md`
</output>
