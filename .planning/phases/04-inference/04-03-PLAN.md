---
phase: 04-inference
plan: 03
type: execute
wave: 3
depends_on: [04-02]
files_modified: [FunLang/Infer.fs]
autonomous: true

must_haves:
  truths:
    - "Lambda creates function type with fresh parameter type"
    - "App unifies function type with argument type"
    - "Let bindings support let-polymorphism (generalize then instantiate)"
    - "LetRec pre-binds function name for recursive calls"
  artifacts:
    - path: "FunLang/Infer.fs"
      provides: "infer cases for Lambda, App, Let, LetRec"
      contains: "Lambda|App|Let|LetRec"
  key_links:
    - from: "infer Let"
      to: "generalize"
      via: "polymorphic binding"
      pattern: "generalize env'"
    - from: "infer LetRec"
      to: "freshVar"
      via: "pre-bind function type"
      pattern: "freshVar\\(\\)"
---

<objective>
Implement infer cases for Lambda, App, Let, and LetRec expressions.

Purpose: These are the core binding forms in FunLang. Let and LetRec implement let-polymorphism (the key innovation of Hindley-Milner). Lambda and App handle function types. This covers INFER-07, INFER-08, INFER-09.
Output: Complete function type inference with let-polymorphism.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-inference/04-RESEARCH.md
@.planning/phases/04-inference/04-02-SUMMARY.md
@FunLang/Type.fs
@FunLang/Unify.fs
@FunLang/Ast.fs
@FunLang/Infer.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Lambda and App inference</name>
  <files>FunLang/Infer.fs</files>
  <action>
Add Lambda and App cases to the infer match expression (replace failwith placeholder with these cases):

```fsharp
    // === Lambda (INFER-08) ===
    | Lambda (param, body) ->
        let paramTy = freshVar()
        let bodyEnv = Map.add param (Scheme ([], paramTy)) env
        let s, bodyTy = infer bodyEnv body
        (s, TArrow (apply s paramTy, bodyTy))

    // === Application (INFER-08) ===
    | App (func, arg) ->
        let s1, funcTy = infer env func
        let s2, argTy = infer (applyEnv s1 env) arg
        let resultTy = freshVar()
        let s3 = unify (apply s2 funcTy) (TArrow (argTy, resultTy))
        (compose s3 (compose s2 s1), apply s3 resultTy)
```

Key patterns:
- Lambda: fresh var for param, monomorphic in body (no polymorphism for lambda params)
- Lambda: apply substitution to paramTy for final arrow type
- App: fresh result type, unify function with arg->result arrow
  </action>
  <verify>
```bash
dotnet fsi --exec <<'EOF'
#r "FunLang/bin/Debug/net8.0/FunLang.dll"
open Type
open Ast
open Infer

let env: TypeEnv = Map.empty

// fun x -> x (identity function)
let _, t1 = infer env (Lambda ("x", Var "x"))
printfn "fun x -> x: %s (expect 'a -> 'a)" (formatType t1)

// fun x -> x + 1
let _, t2 = infer env (Lambda ("x", Add (Var "x", Number 1)))
printfn "fun x -> x + 1: %s (expect int -> int)" (formatType t2)

// (fun x -> x) 42
let _, t3 = infer env (App (Lambda ("x", Var "x"), Number 42))
printfn "(fun x -> x) 42: %s (expect int)" (formatType t3)
EOF
```
  </verify>
  <done>
- Lambda infers TArrow with fresh parameter type
- App correctly unifies function and argument types
- Substitution threaded correctly through both forms
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Let and LetRec inference</name>
  <files>FunLang/Infer.fs</files>
  <action>
Add Let and LetRec cases to the infer match expression:

```fsharp
    // === Let with polymorphism (INFER-07) ===
    | Let (name, value, body) ->
        let s1, valueTy = infer env value
        let env' = applyEnv s1 env
        let scheme = generalize env' (apply s1 valueTy)
        let bodyEnv = Map.add name scheme env'
        let s2, bodyTy = infer bodyEnv body
        (compose s2 s1, bodyTy)

    // === LetRec (INFER-09) ===
    | LetRec (name, param, body, expr) ->
        // Pre-bind function with fresh type for recursive calls
        let funcTy = freshVar()
        let paramTy = freshVar()
        let recEnv = Map.add name (Scheme ([], funcTy)) env
        let bodyEnv = Map.add param (Scheme ([], paramTy)) recEnv
        // Infer body type
        let s1, bodyTy = infer bodyEnv body
        // Unify function type with inferred arrow
        let s2 = unify (apply s1 funcTy) (TArrow (apply s1 paramTy, bodyTy))
        let s = compose s2 s1
        // Generalize and add to env for expression
        let env' = applyEnv s env
        let scheme = generalize env' (apply s funcTy)
        let exprEnv = Map.add name scheme env'
        let s3, exprTy = infer exprEnv expr
        (compose s3 s, exprTy)
```

Key patterns:
- Let: generalize AFTER inferring value, enabling polymorphism
- Let: apply substitution to env before generalize (correct free var calculation)
- LetRec: pre-bind function name with fresh type (enables recursion)
- LetRec: unify fresh funcTy with actual inferred arrow type
  </action>
  <verify>
```bash
dotnet fsi --exec <<'EOF'
#r "FunLang/bin/Debug/net8.0/FunLang.dll"
open Type
open Ast
open Infer

let env: TypeEnv = Map.empty

// let x = 1 in x + 1
let _, t1 = infer env (Let ("x", Number 1, Add (Var "x", Number 1)))
printfn "let x = 1 in x + 1: %s (expect int)" (formatType t1)

// let id = fun x -> x in (id 1, id true) - polymorphism test
// This tests let-polymorphism: id is used at both int and bool
let _, t2 = infer env (Let ("id", Lambda ("x", Var "x"),
    Tuple [App (Var "id", Number 1); App (Var "id", Bool true)]))
printfn "let id = fun x -> x in (id 1, id true): %s (expect int * bool)" (formatType t2)

// let rec fact n = if n = 0 then 1 else n * fact (n - 1) in fact 5
let _, t3 = infer env (LetRec ("fact", "n",
    If (Equal (Var "n", Number 0),
        Number 1,
        Multiply (Var "n", App (Var "fact", Subtract (Var "n", Number 1)))),
    App (Var "fact", Number 5)))
printfn "let rec fact n = ... in fact 5: %s (expect int)" (formatType t3)

// let rec id x = x in (id 1, id true) - polymorphic recursion
let _, t4 = infer env (LetRec ("id", "x", Var "x",
    Tuple [App (Var "id", Number 1); App (Var "id", Bool true)]))
printfn "let rec id x = x in (id 1, id true): %s (expect int * bool)" (formatType t4)
EOF
```
  </verify>
  <done>
- Let generalizes value type, enabling polymorphic reuse
- Let-polymorphism: same binding used at different types
- LetRec pre-binds function name for recursive body
- LetRec generalizes for polymorphic recursion
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` succeeds
2. Lambda creates arrow types with fresh parameter types
3. App correctly unifies and returns result type
4. Let-polymorphism works: `let id = fun x -> x in (id 1, id true)` typechecks
5. LetRec handles recursive calls: factorial function typechecks
</verification>

<success_criteria>
- Lambda infers TArrow with substitution applied to parameter
- App unifies function with TArrow, returns fresh result type
- Let supports let-polymorphism (generalize-instantiate pattern)
- LetRec pre-binds function type for recursive calls
- Both Let and LetRec generalize for polymorphic reuse
</success_criteria>

<output>
After completion, create `.planning/phases/04-inference/04-03-SUMMARY.md`
</output>
