---
phase: 04-output-testing
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - FunLang/Program.fs
  - tests/type-errors/01-infinite-type.flt
  - tests/type-errors/02-unbound-var.flt
  - tests/type-errors/03-type-mismatch.flt
  - tests/type-errors/04-mismatch-reverse.flt
  - tests/type-errors/05-list-mismatch.flt
  - tests/type-errors/06-cons-not-list.flt
  - tests/type-errors/07-branch-mismatch.flt
  - tests/type-errors/08-condition-not-bool.flt
  - tests/type-errors/09-comparison-type.flt
  - tests/type-errors/10-logical-type.flt
  - tests/type-errors/11-not-a-function.flt
  - tests/type-errors/12-let-rhs-error.flt
autonomous: true

must_haves:
  truths:
    - "CLI displays new error format when type checking fails"
    - "Error output includes error code, location, and context"
    - "Existing type error tests pass with updated expected output"
    - "Non-function call errors (E0304) have dedicated test coverage"
    - "Let binding RHS type errors have dedicated test coverage"
  artifacts:
    - path: "FunLang/Program.fs"
      provides: "CLI integration with typecheckWithDiagnostic"
      contains: "formatDiagnostic"
    - path: "tests/type-errors/01-infinite-type.flt"
      provides: "Golden test for occurs check error"
      contains: "error[E0302]"
    - path: "tests/type-errors/11-not-a-function.flt"
      provides: "Golden test for non-function call error (TEST-02)"
      contains: "error[E0304]"
    - path: "tests/type-errors/12-let-rhs-error.flt"
      provides: "Golden test for let RHS type error (TEST-04)"
      contains: "error[E0301]"
  key_links:
    - from: "FunLang/Program.fs"
      to: "TypeCheck.typecheckWithDiagnostic"
      via: "match typecheckWithDiagnostic"
      pattern: "typecheckWithDiagnostic"
    - from: "FunLang/Program.fs"
      to: "Diagnostic.formatDiagnostic"
      via: "eprintfn call"
      pattern: "formatDiagnostic"
---

<objective>
Integrate new diagnostic format into CLI and update golden tests

Purpose: Connect the formatting infrastructure (Plan 01) to actual CLI output and validate the complete diagnostic pipeline through golden tests.

Output:
- Program.fs uses typecheckWithDiagnostic + formatDiagnostic
- All 10 existing type error tests updated with new output format
- 2 new type error tests for TEST-02 (E0304) and TEST-04 (let RHS)
- fslit golden tests validate diagnostic format
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-output-testing/04-RESEARCH.md
@.planning/phases/04-output-testing/04-01-SUMMARY.md
@FunLang/Program.fs
@FunLang/TypeCheck.fs
@FunLang/Diagnostic.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Program.fs to use new diagnostic format</name>
  <files>FunLang/Program.fs</files>
  <action>
Update all locations in Program.fs where typecheck errors are displayed to use the new diagnostic format.

1. Add `open Diagnostic` at the top with other opens (around line 8)

2. Replace all instances of the old error handling pattern:
   ```fsharp
   match typecheck ast with
   | Ok ty -> ...
   | Error msg ->
       eprintfn "TypeError: %s" msg
       1
   ```

   With the new diagnostic format:
   ```fsharp
   match typecheckWithDiagnostic ast with
   | Ok ty -> ...
   | Error diag ->
       eprintfn "%s" (formatDiagnostic diag)
       1
   ```

3. Also update the type output for --emit-type to use formatTypeNormalized:
   ```fsharp
   | Ok ty ->
       printfn "%s" (Type.formatTypeNormalized ty)
       0
   ```

There are 4 locations to update in Program.fs:
- Line ~63-69: --emit-type with --expr
- Line ~75-86: --emit-type with file
- Line ~129-133: --expr only (typecheck before eval)
- Line ~149-153: file only (typecheck before eval)

Make sure to change both:
- `typecheck` -> `typecheckWithDiagnostic`
- `Error msg` -> `Error diag`
- `eprintfn "TypeError: %s" msg` -> `eprintfn "%s" (formatDiagnostic diag)`
- `Type.formatType ty` -> `Type.formatTypeNormalized ty` (for --emit-type output)
  </action>
  <verify>
Run `dotnet build FunLang` - should compile without errors.
Test manually: `dotnet run --project FunLang -- --emit-type "1 + true" 2>&1` should show multi-line error format.
  </verify>
  <done>
Program.fs uses typecheckWithDiagnostic and formatDiagnostic. Type errors display in new multi-line format with error code, location, and hints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update existing and create new type error golden tests</name>
  <files>
    tests/type-errors/01-infinite-type.flt
    tests/type-errors/02-unbound-var.flt
    tests/type-errors/03-type-mismatch.flt
    tests/type-errors/04-mismatch-reverse.flt
    tests/type-errors/05-list-mismatch.flt
    tests/type-errors/06-cons-not-list.flt
    tests/type-errors/07-branch-mismatch.flt
    tests/type-errors/08-condition-not-bool.flt
    tests/type-errors/09-comparison-type.flt
    tests/type-errors/10-logical-type.flt
    tests/type-errors/11-not-a-function.flt
    tests/type-errors/12-let-rhs-error.flt
  </files>
  <action>
Update all 10 existing type error golden tests to match the new diagnostic output format, AND create 2 new test files for missing coverage.

**Part A: Update existing tests (01-10)**

For each test file, run the actual command to see the new output format, then update the `--- Output:` section.

The new format is multi-line, like:
```
error[E0301]: Type mismatch: expected int but got bool
 --> <input>:1:5-9
   = note: in if condition at <input>:1:1-20
   = hint: Check that all branches of your expression return the same type
```

Process for each file:
1. Note the Input expression
2. Run: `dotnet run --project FunLang -- --emit-type "<input>" 2>&1`
3. Capture the actual output
4. Update the `--- Output:` section with the actual multi-line output

**Part B: Create new test file for TEST-02 (E0304 - NotAFunction)**

Create `tests/type-errors/11-not-a-function.flt`:
```
--- Input:
1 2

--- Output:
error[E0304]: ...
```

Test expression `1 2` attempts to call integer 1 as a function with argument 2.
Run `dotnet run --project FunLang -- --emit-type "1 2" 2>&1` to get exact output.

**Part C: Create new test file for TEST-04 (let RHS type error)**

Create `tests/type-errors/12-let-rhs-error.flt`:
```
--- Input:
let x = true in x + 1

--- Output:
error[E0301]: ...
```

Test expression `let x = true in x + 1` binds a bool to x, then tries to use it with +.
Run `dotnet run --project FunLang -- --emit-type "let x = true in x + 1" 2>&1` to get exact output.

IMPORTANT: The actual output depends on span positions and context. Run each test input through the CLI to get the exact output format. The output MUST match exactly for golden tests to pass.
  </action>
  <verify>
Run `make -C tests` - all 12 type error tests should pass.
  </verify>
  <done>
All 10 existing type error tests updated with new multi-line diagnostic format. 2 new tests created (11-not-a-function.flt for TEST-02/E0304, 12-let-rhs-error.flt for TEST-04). All 12 fslit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify complete diagnostic pipeline</name>
  <files>None (verification only)</files>
  <action>
Verify the complete diagnostic pipeline works end-to-end:

1. Test each TypeErrorKind produces correct error code:
   - E0301: UnifyMismatch (type mismatch)
   - E0302: OccursCheck (infinite type)
   - E0303: UnboundVar (undefined variable)
   - E0304: NotAFunction (calling non-function)

2. Test each required scenario from requirements:
   - TEST-01: if-condition type errors (bool expected in condition) - covered by 08-condition-not-bool.flt
   - TEST-02: non-function calls (E0304) - covered by 11-not-a-function.flt
   - TEST-03: argument mismatches - covered by 03-type-mismatch.flt
   - TEST-04: let RHS errors - covered by 12-let-rhs-error.flt
   - TEST-05: occurs check (E0302) - covered by 01-infinite-type.flt

3. Verify type variable normalization in output:
   - `dotnet run --project FunLang -- --emit-type "fun x -> x"` should show `'a -> 'a`
   - `dotnet run --project FunLang -- --emit-type "fun f -> fun x -> f x"` should show `('a -> 'b) -> 'a -> 'b`

4. Run all tests:
   - `make -C tests` - all fslit tests pass (including 12 type error tests)
   - `dotnet run --project FunLang.Tests` - all Expecto tests pass

Document any issues found and fix them.
  </action>
  <verify>
`make -C tests` passes all tests
`dotnet run --project FunLang.Tests` passes all tests
Manual verification of error codes E0301-E0304 in output
  </verify>
  <done>
Complete diagnostic pipeline verified. All error codes display correctly. Type variables normalized to 'a, 'b, 'c. All tests pass. TEST-01 through TEST-05 requirements fully covered.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `dotnet build FunLang` compiles without errors
2. `make -C tests` passes all fslit tests (including 12 type error tests)
3. `dotnet run --project FunLang.Tests` passes all Expecto tests
4. CLI shows new error format: `error[E0301]: Type mismatch...` with location and hints
5. Type output uses normalized variables: `'a -> 'b` not `'u -> 'v`
6. TEST-02 (E0304) covered by 11-not-a-function.flt
7. TEST-04 (let RHS) covered by 12-let-rhs-error.flt
</verification>

<success_criteria>
- [ ] Program.fs uses typecheckWithDiagnostic and formatDiagnostic
- [ ] --emit-type output uses formatTypeNormalized
- [ ] All 10 existing type error golden tests updated and passing
- [ ] New test 11-not-a-function.flt created and passing (TEST-02, E0304)
- [ ] New test 12-let-rhs-error.flt created and passing (TEST-04, E0301)
- [ ] Error codes E0301-E0304 appear in CLI output
- [ ] Error messages include location (-->) and hints (= hint:)
- [ ] All fslit tests pass (make -C tests) - 12 type error tests
- [ ] All Expecto tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-output-testing/04-02-SUMMARY.md`
</output>
