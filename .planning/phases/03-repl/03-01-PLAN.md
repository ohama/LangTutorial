---
phase: 03-repl
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/FunLang.fsproj
  - FunLang/Cli.fs
  - FunLang/Program.fs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All existing CLI commands work identically"
    - "funlang --help shows auto-generated usage"
    - "funlang -e works as alias for --expr"
    - "Invalid flags show error and usage"
  artifacts:
    - path: "FunLang/Cli.fs"
      provides: "Argu CLI argument type"
      exports: ["CliArgs"]
    - path: "FunLang/FunLang.fsproj"
      provides: "Argu package reference"
      contains: "Argu"
  key_links:
    - from: "FunLang/Program.fs"
      to: "FunLang/Cli.fs"
      via: "open Cli, ArgumentParser.Create<CliArgs>"
      pattern: "ArgumentParser.*CliArgs"
---

<objective>
Modernize CLI argument parsing using Argu library

Purpose: Replace 120-line manual pattern matching with declarative Argu DU, gaining auto-generated help, better error messages, and extensibility for REPL flag
Output: Argu-based CLI that behaves identically to current CLI
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-repl/03-RESEARCH.md

@FunLang/Program.fs
@FunLang/FunLang.fsproj
@FunLang/Eval.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Argu package and create Cli.fs module</name>
  <files>FunLang/FunLang.fsproj, FunLang/Cli.fs</files>
  <action>
1. Add Argu NuGet package to FunLang.fsproj:
   ```xml
   <PackageReference Include="Argu" Version="6.2.5" />
   ```

2. Add Cli.fs to FunLang.fsproj compile order (BEFORE Program.fs):
   ```xml
   <!-- 9. CLI argument parsing (uses Argu) -->
   <Compile Include="Cli.fs" />
   ```

3. Create FunLang/Cli.fs with Argu argument type:
   ```fsharp
   module Cli

   open Argu

   [<CliPrefix(CliPrefix.DoubleDash)>]
   type CliArgs =
       | [<AltCommandLine("-e")>] Expr of expression: string
       | Emit_Tokens
       | Emit_Ast
       | Emit_Type
       | Repl
       | [<MainCommand; Last>] File of filename: string
   with
       interface IArgParserTemplate with
           member this.Usage =
               match this with
               | Expr _ -> "evaluate expression"
               | Emit_Tokens -> "show lexer tokens"
               | Emit_Ast -> "show parsed AST"
               | Emit_Type -> "show inferred types (reserved)"
               | Repl -> "start interactive REPL"
               | File _ -> "evaluate program from file"
   ```

NOTE on underscore conversion: Argu automatically converts `Emit_Tokens` to `--emit-tokens` CLI flag. This matches current behavior.

NOTE on Help: Do NOT add explicit Help case. Argu handles --help automatically.
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang
```
Build should succeed with Cli.fs compiled.
  </verify>
  <done>
- FunLang.fsproj has Argu 6.2.5 package reference
- Cli.fs exists with CliArgs discriminated union
- Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor Program.fs to use Argu</name>
  <files>FunLang/Program.fs</files>
  <action>
Rewrite Program.fs to use Argu parser instead of manual pattern matching.

Key requirements:
1. Open Cli module at top
2. Create ArgumentParser with raiseOnUsage = false (so --help doesn't throw)
3. Handle parsing errors gracefully
4. Maintain EXACT current behavior for all existing flags
5. Add Repl case (stub for now - just print message)

Structure:
```fsharp
open System
open System.IO
open FSharp.Text.Lexing
open Argu
open Cli
open Ast
open Eval
open Format

/// Parse a string input and return the AST
let parse (input: string) : Expr =
    let lexbuf = LexBuffer<char>.FromString input
    Parser.start Lexer.tokenize lexbuf

/// Placeholder for REPL (implemented in next plan)
let startRepl () =
    printfn "REPL not yet implemented"
    0

[<EntryPoint>]
let main argv =
    let parser = ArgumentParser.Create<CliArgs>(
        programName = "funlang",
        errorHandler = ProcessExiter(colorizer = function
            | ErrorCode.HelpText -> None
            | _ -> Some ConsoleColor.Red))

    try
        let results = parser.Parse(argv, raiseOnUsage = false)

        // Check if help was requested
        if results.IsUsageRequested then
            printfn "%s" (parser.PrintUsage())
            0
        // --repl flag
        elif results.Contains Repl then
            startRepl()
        // --emit-tokens with --expr
        elif results.Contains Emit_Tokens && results.Contains Expr then
            let expr = results.GetResult Expr
            try
                let tokens = lex expr
                printfn "%s" (formatTokens tokens)
                0
            with ex ->
                eprintfn "Error: %s" ex.Message
                1
        // --emit-ast with --expr
        elif results.Contains Emit_Ast && results.Contains Expr then
            let expr = results.GetResult Expr
            try
                let ast = parse expr
                printfn "%A" ast
                0
            with ex ->
                eprintfn "Error: %s" ex.Message
                1
        // --emit-type (reserved)
        elif results.Contains Emit_Type then
            eprintfn "Error: Type checking not yet implemented. Reserved for future phase."
            1
        // --emit-tokens with file
        elif results.Contains Emit_Tokens && results.Contains File then
            let filename = results.GetResult File
            if File.Exists filename then
                try
                    let input = File.ReadAllText filename
                    let tokens = lex input
                    printfn "%s" (formatTokens tokens)
                    0
                with ex ->
                    eprintfn "Error: %s" ex.Message
                    1
            else
                eprintfn "File not found: %s" filename
                1
        // --emit-ast with file
        elif results.Contains Emit_Ast && results.Contains File then
            let filename = results.GetResult File
            if File.Exists filename then
                try
                    let input = File.ReadAllText filename
                    let ast = parse input
                    printfn "%A" ast
                    0
                with ex ->
                    eprintfn "Error: %s" ex.Message
                    1
            else
                eprintfn "File not found: %s" filename
                1
        // --expr only
        elif results.Contains Expr then
            let expr = results.GetResult Expr
            try
                let result = expr |> parse |> evalExpr
                printfn "%s" (formatValue result)
                0
            with ex ->
                eprintfn "Error: %s" ex.Message
                1
        // file only
        elif results.Contains File then
            let filename = results.GetResult File
            if File.Exists filename then
                try
                    let input = File.ReadAllText filename
                    let result = input |> parse |> evalExpr
                    printfn "%s" (formatValue result)
                    0
                with ex ->
                    eprintfn "Error: %s" ex.Message
                    1
            else
                eprintfn "File not found: %s" filename
                1
        // no arguments
        else
            printfn "%s" (parser.PrintUsage())
            0
    with
    | :? ArguParseException as ex ->
        eprintfn "%s" ex.Message
        1
```

CRITICAL: Test all existing CLI patterns after refactoring to ensure identical behavior.
  </action>
  <verify>
Run existing fslit tests to verify CLI behavior is preserved:
```bash
cd /home/shoh/vibe-coding/LangTutorial && make -C tests
```

Manual verification of key patterns:
```bash
cd /home/shoh/vibe-coding/LangTutorial
dotnet run --project FunLang -- --expr "2 + 3"
dotnet run --project FunLang -- -e "2 + 3"
dotnet run --project FunLang -- --emit-tokens --expr "2 + 3"
dotnet run --project FunLang -- --emit-ast --expr "1 + 2"
dotnet run --project FunLang -- --help
dotnet run --project FunLang -- --repl
```
  </verify>
  <done>
- Program.fs uses Argu for CLI parsing
- All fslit tests pass
- --expr "2+3" returns 5
- -e "2+3" returns 5 (alias works)
- --emit-tokens --expr "2+3" shows tokens
- --help shows auto-generated usage
- --repl prints placeholder message
- Invalid flags show error with usage
  </done>
</task>

</tasks>

<verification>
All existing CLI behavior must be preserved:
```bash
# Run full test suite
cd /home/shoh/vibe-coding/LangTutorial
make -C tests
dotnet run --project FunLang.Tests
```

Check CLI works correctly:
```bash
# Expression evaluation
dotnet run --project FunLang -- --expr "2 + 3 * 4"
# Expected: 14

# File evaluation
echo "let x = 5 in x * 2" > /tmp/test.fun
dotnet run --project FunLang -- /tmp/test.fun
# Expected: 10

# Token emission
dotnet run --project FunLang -- --emit-tokens --expr "1 + 2"
# Expected: NUMBER(1) PLUS NUMBER(2) EOF

# AST emission
dotnet run --project FunLang -- --emit-ast --expr "1 + 2"
# Expected: Add (Number 1, Number 2)

# Help (auto-generated by Argu)
dotnet run --project FunLang -- --help
# Expected: USAGE: funlang [--help] [--expr <expression>] ...
```
</verification>

<success_criteria>
1. Build succeeds with Argu package
2. All 93 fslit tests pass
3. All 168 Expecto tests pass
4. CLI behaves identically for existing patterns
5. --help shows Argu-generated usage
6. -e alias works for --expr
7. --repl flag recognized (placeholder response)
</success_criteria>

<output>
After completion, create `.planning/phases/03-repl/03-01-SUMMARY.md`
</output>
