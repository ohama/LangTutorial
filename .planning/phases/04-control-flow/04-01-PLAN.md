---
phase: 04-control-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Ast.fs
  - FunLang/Lexer.fsl
  - FunLang/Parser.fsy
  - FunLang/Eval.fs
  - FunLang/Format.fs
  - FunLang/Program.fs
autonomous: true

must_haves:
  truths:
    - "User can evaluate boolean literals (true, false)"
    - "User can use if-then-else to select between values"
    - "User can compare integers with =, <, >, <=, >=, <>"
    - "User can combine conditions with && and ||"
    - "Comparisons return boolean, if condition must be boolean"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "Value type (IntValue | BoolValue) and new Expr cases"
      contains: "type Value"
    - path: "FunLang/Lexer.fsl"
      provides: "Tokens: TRUE, FALSE, IF, THEN, ELSE, LE, GE, NE, LT, GT, AND, OR"
      contains: "TRUE"
    - path: "FunLang/Parser.fsy"
      provides: "Grammar with precedence declarations for all operators"
      contains: "%left OR"
    - path: "FunLang/Eval.fs"
      provides: "Evaluator returning Value, with type checking"
      contains: "Value ="
    - path: "FunLang/Format.fs"
      provides: "Token formatting for new tokens"
      contains: "Parser.TRUE"
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "If, Bool, comparison, and logical constructors"
      pattern: "If\\(\\$2"
    - from: "FunLang/Eval.fs"
      to: "Value discriminated union"
      via: "Type checking in evaluation"
      pattern: "BoolValue"
---

<objective>
Implement control flow in FunLang: boolean type, if-then-else, comparison operators, and logical operators.

Purpose: Enable users to write conditional expressions that branch based on boolean conditions. This introduces heterogeneous types (int and bool) and type checking in the evaluator.

Output:
- Value discriminated union (IntValue | BoolValue)
- Extended AST with Bool, If, comparison ops (LessThan, GreaterThan, etc.), logical ops (And, Or)
- Lexer with TRUE, FALSE, IF, THEN, ELSE, comparison, and logical operator tokens
- Parser with precedence declarations and if-then-else grammar
- Type-checking evaluator with short-circuit logical evaluation
- Updated Format.fs for token printing
- Updated Program.fs for Value output formatting
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-control-flow/04-RESEARCH.md

@FunLang/Ast.fs
@FunLang/Lexer.fsl
@FunLang/Parser.fsy
@FunLang/Eval.fs
@FunLang/Format.fs
@FunLang/Program.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Value type and extend AST</name>
  <files>FunLang/Ast.fs</files>
  <action>
Add the Value discriminated union BEFORE the Expr type, and extend Expr with control flow cases:

```fsharp
module Ast

/// Value type for heterogeneous evaluation results
/// Phase 4: Control Flow
type Value =
    | IntValue of int
    | BoolValue of bool

/// Expression AST for arithmetic operations
/// Phase 2: Arithmetic expressions with precedence
type Expr =
    | Number of int
    | Add of Expr * Expr
    | Subtract of Expr * Expr
    | Multiply of Expr * Expr
    | Divide of Expr * Expr
    | Negate of Expr  // Unary minus
    // Phase 3: Variables
    | Var of string           // Variable reference
    | Let of string * Expr * Expr  // let name = expr1 in expr2
    // Phase 4: Control Flow
    | Bool of bool                     // Boolean literal (true, false)
    | If of Expr * Expr * Expr         // if cond then e1 else e2
    | LessThan of Expr * Expr          // <
    | GreaterThan of Expr * Expr       // >
    | LessOrEqual of Expr * Expr       // <=
    | GreaterOrEqual of Expr * Expr    // >=
    | Equal of Expr * Expr             // =
    | NotEqual of Expr * Expr          // <>
    | And of Expr * Expr               // &&
    | Or of Expr * Expr                // ||
```

Key points:
- Value type comes BEFORE Expr (F# requires types in dependency order)
- Boolean literal is `Bool of bool`, distinct from BoolValue
- Comparison operators compare Expr * Expr and return BoolValue
- If takes condition, then-branch, else-branch as three Expr
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1 | head -30
```
Build will show incomplete pattern match warnings (expected until Eval.fs is updated).
  </verify>
  <done>Ast.fs contains Value type and all Phase 4 Expr cases (Bool, If, comparison ops, logical ops)</done>
</task>

<task type="auto">
  <name>Task 2: Add tokens to Lexer</name>
  <files>FunLang/Lexer.fsl</files>
  <action>
Add new token rules to Lexer.fsl. Order matters: keywords before identifiers, multi-char operators before single-char.

1. Add keyword tokens AFTER existing "let" and "in", BEFORE the identifier pattern:
```
    // Phase 4: Boolean and control flow keywords
    | "true"        { TRUE }
    | "false"       { FALSE }
    | "if"          { IF }
    | "then"        { THEN }
    | "else"        { ELSE }
```

2. Add comparison operators BEFORE the single-char '=' rule (multi-char first):
```
    // Phase 4: Comparison operators (multi-char before single-char)
    | "<="          { LE }
    | ">="          { GE }
    | "<>"          { NE }
    | '<'           { LT }
    | '>'           { GT }
```

3. Add logical operators (can go after comparison ops):
```
    // Phase 4: Logical operators
    | "&&"          { AND }
    | "||"          { OR }
```

IMPORTANT ordering:
- "true", "false", "if", "then", "else" MUST come before identifier pattern
- "<=", ">=" MUST come before '<', '>' (longest match)
- "<>" MUST come before '<' (longest match)
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1 | grep -i error | head -10
```
No errors (warnings expected from Eval.fs).
  </verify>
  <done>Lexer.fsl contains TRUE, FALSE, IF, THEN, ELSE, LE, GE, NE, LT, GT, AND, OR tokens</done>
</task>

<task type="auto">
  <name>Task 3: Update Parser with precedence and if-then-else</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Replace the entire Parser.fsy with precedence-declaration-based grammar.

CRITICAL: Use %left/%right/%nonassoc for operator precedence instead of Expr/Term/Factor levels for the new operators. Keep Term/Factor for existing arithmetic (already tested and working).

```fsharp
%{
open Ast
%}

// Token declarations
%token <int> NUMBER
%token <string> IDENT
%token PLUS MINUS STAR SLASH
%token LPAREN RPAREN
%token LET IN EQUALS
%token TRUE FALSE IF THEN ELSE
%token LT GT LE GE NE
%token AND OR
%token EOF

// Precedence declarations (lowest to highest)
// Note: Term/Factor handle STAR/SLASH/PLUS/MINUS precedence via grammar
// These declarations handle Phase 4 operators
%left OR
%left AND
%nonassoc LT GT LE GE EQUALS NE

// Start symbol and its type
%start start
%type <Ast.Expr> start

%%

// Grammar rules

start:
    | Expr EOF           { $1 }

Expr:
    // If-then-else - lowest precedence (no associativity needed)
    | IF Expr THEN Expr ELSE Expr  { If($2, $4, $6) }
    // Let expression - also low precedence
    | LET IDENT EQUALS Expr IN Expr  { Let($2, $4, $6) }
    // Logical OR
    | Expr OR Expr       { Or($1, $3) }
    // Logical AND
    | Expr AND Expr      { And($1, $3) }
    // Comparisons (using EQUALS for = to avoid conflict with let binding)
    | Expr LT Expr       { LessThan($1, $3) }
    | Expr GT Expr       { GreaterThan($1, $3) }
    | Expr LE Expr       { LessOrEqual($1, $3) }
    | Expr GE Expr       { GreaterOrEqual($1, $3) }
    | Expr EQUALS Expr   { Equal($1, $3) }
    | Expr NE Expr       { NotEqual($1, $3) }
    // Arithmetic (uses Term for proper precedence)
    | Expr PLUS Term     { Add($1, $3) }
    | Expr MINUS Term    { Subtract($1, $3) }
    | Term               { $1 }

Term:
    | Term STAR Factor   { Multiply($1, $3) }
    | Term SLASH Factor  { Divide($1, $3) }
    | Factor             { $1 }

Factor:
    | NUMBER             { Number($1) }
    | TRUE               { Bool(true) }
    | FALSE              { Bool(false) }
    | IDENT              { Var($1) }
    | LPAREN Expr RPAREN { $2 }
    | MINUS Factor       { Negate($2) }
```

Key design decisions:
- %nonassoc for comparisons: "1 < 2 < 3" is a parse error (correct - avoids type confusion)
- %left for OR, AND: "a || b || c" is left-associative
- If-then-else at top of Expr: lowest precedence, branches can contain any expression
- EQUALS is reused for both let binding and comparison (context disambiguates)
- TRUE and FALSE in Factor (highest precedence, like literals)
- Keep Term/Factor pattern for arithmetic (already tested and working)
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1 | grep -E "(error|shift/reduce|reduce/reduce)" | head -10
```
May show 1-2 shift/reduce conflicts on ELSE (dangling else - expected and resolved correctly by default shift).
  </verify>
  <done>Parser.fsy has token declarations, precedence declarations, and if-then-else grammar with Bool literal</done>
</task>

<task type="auto">
  <name>Task 4: Implement type-checking evaluator with Value return</name>
  <files>FunLang/Eval.fs</files>
  <action>
Replace entire Eval.fs with Value-returning, type-checking evaluator:

```fsharp
module Eval

open Ast

/// Environment mapping variable names to values
type Env = Map<string, Value>

/// Empty environment for top-level evaluation
let emptyEnv : Env = Map.empty

/// Evaluate an expression in an environment
/// Returns Value (IntValue or BoolValue)
/// Raises exception for type errors and undefined variables
let rec eval (env: Env) (expr: Expr) : Value =
    match expr with
    | Number n -> IntValue n
    | Bool b -> BoolValue b

    | Var name ->
        match Map.tryFind name env with
        | Some value -> value
        | None -> failwithf "Undefined variable: %s" name

    | Let (name, binding, body) ->
        let value = eval env binding
        let extendedEnv = Map.add name value env
        eval extendedEnv body

    // Arithmetic operations - require IntValue operands
    | Add (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> IntValue (a + b)
        | _ -> failwith "Type error: + expects int operands"

    | Subtract (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> IntValue (a - b)
        | _ -> failwith "Type error: - expects int operands"

    | Multiply (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> IntValue (a * b)
        | _ -> failwith "Type error: * expects int operands"

    | Divide (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> IntValue (a / b)
        | _ -> failwith "Type error: / expects int operands"

    | Negate e ->
        match eval env e with
        | IntValue n -> IntValue (-n)
        | _ -> failwith "Type error: unary - expects int operand"

    // Comparison operations - require IntValue operands, return BoolValue
    | LessThan (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> BoolValue (a < b)
        | _ -> failwith "Type error: < expects int operands"

    | GreaterThan (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> BoolValue (a > b)
        | _ -> failwith "Type error: > expects int operands"

    | LessOrEqual (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> BoolValue (a <= b)
        | _ -> failwith "Type error: <= expects int operands"

    | GreaterOrEqual (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> BoolValue (a >= b)
        | _ -> failwith "Type error: >= expects int operands"

    | Equal (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> BoolValue (a = b)
        | (BoolValue a, BoolValue b) -> BoolValue (a = b)
        | _ -> failwith "Type error: = expects operands of same type"

    | NotEqual (left, right) ->
        match (eval env left, eval env right) with
        | (IntValue a, IntValue b) -> BoolValue (a <> b)
        | (BoolValue a, BoolValue b) -> BoolValue (a <> b)
        | _ -> failwith "Type error: <> expects operands of same type"

    // Logical operations with short-circuit evaluation
    | And (left, right) ->
        match eval env left with
        | BoolValue false -> BoolValue false  // Short-circuit
        | BoolValue true ->
            match eval env right with
            | BoolValue b -> BoolValue b
            | _ -> failwith "Type error: && expects bool operands"
        | _ -> failwith "Type error: && expects bool operands"

    | Or (left, right) ->
        match eval env left with
        | BoolValue true -> BoolValue true  // Short-circuit
        | BoolValue false ->
            match eval env right with
            | BoolValue b -> BoolValue b
            | _ -> failwith "Type error: || expects bool operands"
        | _ -> failwith "Type error: || expects bool operands"

    // If-then-else - condition must be BoolValue
    | If (cond, thenBranch, elseBranch) ->
        match eval env cond with
        | BoolValue true -> eval env thenBranch
        | BoolValue false -> eval env elseBranch
        | _ -> failwith "Type error: if condition must be bool"

/// Convenience function for top-level evaluation
let evalExpr (expr: Expr) : Value =
    eval emptyEnv expr

/// Format a value for display
let formatValue (value: Value) : string =
    match value with
    | IntValue i -> string i
    | BoolValue true -> "true"
    | BoolValue false -> "false"
```

Key implementation details:
- Environment now stores `Map<string, Value>` (not `Map<string, int>`)
- All arithmetic ops type-check for IntValue
- Comparison ops type-check for IntValue, return BoolValue
- Equal and NotEqual work on both int and bool (same type required)
- && and || use short-circuit: don't evaluate right if result known from left
- If requires BoolValue condition, then returns result of selected branch
- `formatValue` function added for user-friendly output
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1
```
Build should succeed (warnings about exhaustive matches are OK if covered).
  </verify>
  <done>Eval.fs returns Value, has type checking for all operations, short-circuit for &&/||, formatValue helper</done>
</task>

<task type="auto">
  <name>Task 5: Update Format.fs for new tokens</name>
  <files>FunLang/Format.fs</files>
  <action>
Add formatting cases for all new tokens in the formatToken function:

```fsharp
module Format

open System
open FSharp.Text.Lexing

/// Format a single token as a string
let formatToken (token: Parser.token) : string =
    match token with
    | Parser.NUMBER n -> sprintf "NUMBER(%d)" n
    | Parser.IDENT s -> sprintf "IDENT(%s)" s
    | Parser.PLUS -> "PLUS"
    | Parser.MINUS -> "MINUS"
    | Parser.STAR -> "STAR"
    | Parser.SLASH -> "SLASH"
    | Parser.LPAREN -> "LPAREN"
    | Parser.RPAREN -> "RPAREN"
    | Parser.LET -> "LET"
    | Parser.IN -> "IN"
    | Parser.EQUALS -> "EQUALS"
    // Phase 4: Control flow tokens
    | Parser.TRUE -> "TRUE"
    | Parser.FALSE -> "FALSE"
    | Parser.IF -> "IF"
    | Parser.THEN -> "THEN"
    | Parser.ELSE -> "ELSE"
    | Parser.LT -> "LT"
    | Parser.GT -> "GT"
    | Parser.LE -> "LE"
    | Parser.GE -> "GE"
    | Parser.NE -> "NE"
    | Parser.AND -> "AND"
    | Parser.OR -> "OR"
    | Parser.EOF -> "EOF"

/// Format a list of tokens as a space-separated string
let formatTokens (tokens: Parser.token list) : string =
    tokens |> List.map formatToken |> String.concat " "

/// Tokenize input string into a token list
let lex (input: string) : Parser.token list =
    let lexbuf = LexBuffer<char>.FromString input
    let rec loop acc =
        let token = Lexer.tokenize lexbuf
        match token with
        | Parser.EOF -> List.rev (Parser.EOF :: acc)
        | t -> loop (t :: acc)
    loop []
```

All Phase 4 tokens: TRUE, FALSE, IF, THEN, ELSE, LT, GT, LE, GE, NE, AND, OR.
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj 2>&1 | grep -E "(error|warning)" | head -5
```
No errors. Pattern match may show warnings if Parser tokens don't match - fix by verifying token names.
  </verify>
  <done>Format.fs handles all Phase 4 tokens (TRUE, FALSE, IF, THEN, ELSE, comparison ops, logical ops)</done>
</task>

<task type="auto">
  <name>Task 6: Update Program.fs for Value output</name>
  <files>FunLang/Program.fs</files>
  <action>
Update Program.fs to use formatValue for output instead of %d.

Changes needed:
1. Import Eval module (already done, but ensure it's there)
2. Change all `printfn "%d" result` to `printfn "%s" (formatValue result)`

Find these patterns:
- `let result = expr |> parse |> evalExpr` -> followed by `printfn "%d" result`
- `let result = input |> parse |> evalExpr` -> followed by `printfn "%d" result`

Replace the printfn calls:
- `printfn "%d" result` -> `printfn "%s" (formatValue result)`

There should be 2 occurrences:
1. Pattern 7: --expr evaluation
2. Pattern 9: file evaluation
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj && dotnet run --project FunLang/FunLang.fsproj -- --expr "2 + 3"
```
Should output `5` (as string, not `IntValue 5`).
  </verify>
  <done>Program.fs uses formatValue for displaying evaluation results</done>
</task>

</tasks>

<verification>
Run all verification commands to confirm implementation:

```bash
cd /home/shoh/vibe-coding/LangTutorial

# 1. Build succeeds
dotnet build FunLang/FunLang.fsproj

# 2. Existing arithmetic still works
dotnet run --project FunLang/FunLang.fsproj -- --expr "2 + 3 * 4"
# Expected: 14

# 3. Existing variables still work
dotnet run --project FunLang/FunLang.fsproj -- --expr "let x = 5 in x + 1"
# Expected: 6

# 4. Boolean literals (CTRL-02)
dotnet run --project FunLang/FunLang.fsproj -- --expr "true"
# Expected: true

dotnet run --project FunLang/FunLang.fsproj -- --expr "false"
# Expected: false

# 5. If-then-else with boolean (CTRL-01, Success Criteria 1)
dotnet run --project FunLang/FunLang.fsproj -- --expr "if true then 1 else 2"
# Expected: 1

dotnet run --project FunLang/FunLang.fsproj -- --expr "if false then 1 else 2"
# Expected: 2

# 6. Comparison operators (CTRL-03, Success Criteria 2)
dotnet run --project FunLang/FunLang.fsproj -- --expr "if 5 > 3 then 10 else 20"
# Expected: 10

dotnet run --project FunLang/FunLang.fsproj -- --expr "if 5 < 3 then 99 else 100"
# Expected: 100 (Success Criteria 4)

dotnet run --project FunLang/FunLang.fsproj -- --expr "if 3 <= 3 then 1 else 0"
# Expected: 1

dotnet run --project FunLang/FunLang.fsproj -- --expr "if 3 >= 4 then 1 else 0"
# Expected: 0

dotnet run --project FunLang/FunLang.fsproj -- --expr "if 5 = 5 then 1 else 0"
# Expected: 1

dotnet run --project FunLang/FunLang.fsproj -- --expr "if 5 <> 5 then 1 else 0"
# Expected: 0

# 7. Logical operators (CTRL-04, Success Criteria 3)
dotnet run --project FunLang/FunLang.fsproj -- --expr "let x = 10 in let y = 20 in if x = 10 && y = 20 then 1 else 0"
# Expected: 1

dotnet run --project FunLang/FunLang.fsproj -- --expr "if true || false then 1 else 0"
# Expected: 1

dotnet run --project FunLang/FunLang.fsproj -- --expr "if false || false then 1 else 0"
# Expected: 0

# 8. Token output for new tokens
dotnet run --project FunLang/FunLang.fsproj -- --emit-tokens --expr "if true then 1 else 2"
# Expected: IF TRUE THEN NUMBER(1) ELSE NUMBER(2) EOF

dotnet run --project FunLang/FunLang.fsproj -- --emit-tokens --expr "5 > 3 && 2 < 4"
# Expected: NUMBER(5) GT NUMBER(3) AND NUMBER(2) LT NUMBER(4) EOF

# 9. AST output for if-then-else
dotnet run --project FunLang/FunLang.fsproj -- --emit-ast --expr "if true then 1 else 2"
# Expected: If (Bool true, Number 1, Number 2)

# 10. Type errors
dotnet run --project FunLang/FunLang.fsproj -- --expr "if 1 then 2 else 3" 2>&1
# Expected: Error: Type error: if condition must be bool

dotnet run --project FunLang/FunLang.fsproj -- --expr "true + 1" 2>&1
# Expected: Error: Type error: + expects int operands

# 11. Run existing fslit tests to verify no regressions
make tests
# All existing tests should pass
```
</verification>

<success_criteria>
- [ ] Build succeeds with no errors (warnings on dangling else OK)
- [ ] Existing arithmetic expressions work unchanged (2 + 3 * 4 = 14)
- [ ] Existing variable binding works unchanged (let x = 5 in x = 5)
- [ ] CTRL-01: `if true then 1 else 2` returns 1
- [ ] CTRL-02: `true` returns "true", `false` returns "false"
- [ ] CTRL-03: `if 5 > 3 then 10 else 20` returns 10
- [ ] CTRL-03: All comparison operators work (=, <, >, <=, >=, <>)
- [ ] CTRL-04: `if x = 10 && y = 20 then 1 else 0` evaluates with logical AND
- [ ] Success Criteria 4: `if 5 < 3 then 99 else 100` returns 100
- [ ] Type errors produce clear messages (if condition must be bool)
- [ ] --emit-tokens shows all new tokens correctly
- [ ] --emit-ast shows If, Bool, comparison, logical nodes correctly
- [ ] All existing fslit tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-control-flow/04-01-SUMMARY.md`
</output>
