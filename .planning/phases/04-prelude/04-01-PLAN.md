---
phase: 04-prelude
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Prelude.fs
  - FunLang/FunLang.fsproj
  - Prelude.fun
autonomous: true

must_haves:
  truths:
    - "evalToEnv collects let bindings into environment"
    - "loadPrelude returns environment with all prelude functions"
    - "Prelude.fun defines map, filter, fold, length, reverse, append, hd, tl, id, const, compose"
  artifacts:
    - path: "FunLang/Prelude.fs"
      provides: "Prelude loading infrastructure"
      exports: ["loadPrelude"]
      contains: "evalToEnv"
    - path: "Prelude.fun"
      provides: "Standard library in FunLang source"
      contains: "let rec map"
  key_links:
    - from: "FunLang/Prelude.fs"
      to: "Eval.fs"
      via: "uses eval function"
      pattern: "Eval\\.eval"
    - from: "FunLang/Prelude.fs"
      to: "Prelude.fun"
      via: "File.ReadAllText"
      pattern: "File\\.ReadAllText"
---

<objective>
Create Prelude infrastructure and standard library source file

Purpose: Implement the prelude loading module and write all standard library functions in FunLang source code. This establishes the foundation for automatic prelude loading.

Output: FunLang/Prelude.fs module with evalToEnv and loadPrelude functions, Prelude.fun with all required stdlib functions (PRE-01 through PRE-08)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-prelude/04-RESEARCH.md

@FunLang/Eval.fs
@FunLang/Ast.fs
@FunLang/FunLang.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Prelude.fs module</name>
  <files>FunLang/Prelude.fs, FunLang/FunLang.fsproj</files>
  <action>
Create FunLang/Prelude.fs with:

1. Module declaration: `module Prelude`
2. Open statements: `System.IO`, `FSharp.Text.Lexing`, `Ast`, `Eval`
3. Private `parse` function: Parse string input into AST using LexBuffer and Parser.start
4. Private `evalToEnv` function (recursive):
   - Match `Let (name, binding, body)` -> eval binding, extend env, recurse on body
   - Match `LetRec (name, param, funcBody, inExpr)` -> create FunctionValue, extend env, recurse
   - Match `_` -> return accumulated environment (base case)
5. Public `loadPrelude` function:
   - Define `preludePath = "Prelude.fun"`
   - Check `File.Exists preludePath`
   - If exists: try parse and evalToEnv, catch and warn on error, return emptyEnv on failure
   - If not exists: warn "Prelude.fun not found", return emptyEnv

Add to FunLang.fsproj BEFORE Repl.fs (after Eval.fs):
```xml
<!-- 8. Prelude loading (uses Eval) -->
<Compile Include="Prelude.fs" />
```
Update comment number for Repl.fs to 9, Cli.fs to 10, Program.fs to 11.

Key implementation detail: evalToEnv handles the nested let-in structure of Prelude.fun (let x = ... in let y = ... in ... in ()) by recursively collecting bindings and returning the final environment.
  </action>
  <verify>
`dotnet build FunLang` compiles without errors.
Prelude module is accessible from other modules.
  </verify>
  <done>
Prelude.fs exists with evalToEnv and loadPrelude functions.
FunLang.fsproj includes Prelude.fs in correct build order.
Project builds successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Prelude.fun standard library</name>
  <files>Prelude.fun</files>
  <action>
Create Prelude.fun in project root with all required functions as nested let-in expressions.

Structure: each function defined as `let [rec] name = fun args -> body in` followed by next definition, ending with `()`.

Functions to implement (from research, use exact syntax):

1. **map** (PRE-01): `let rec map = fun f -> fun xs -> match xs with | [] -> [] | h :: t -> (f h) :: (map f t) in`

2. **filter** (PRE-02): `let rec filter = fun pred -> fun xs -> match xs with | [] -> [] | h :: t -> if pred h then h :: (filter pred t) else filter pred t in`

3. **fold** (PRE-03): `let rec fold = fun f -> fun acc -> fun xs -> match xs with | [] -> acc | h :: t -> fold f (f acc h) t in` (left fold, tail recursive)

4. **length** (PRE-04): `let rec length = fun xs -> match xs with | [] -> 0 | _ :: t -> 1 + (length t) in`

5. **reverse** (PRE-05): Tail-recursive using helper:
```
let reverse = fun xs ->
    let rec rev_acc = fun acc -> fun ys ->
        match ys with
        | [] -> acc
        | h :: t -> rev_acc (h :: acc) t
    in
    rev_acc [] xs
in
```

6. **append** (PRE-06): `let rec append = fun xs -> fun ys -> match xs with | [] -> ys | h :: t -> h :: (append t ys) in`

7. **id, const, compose** (PRE-07):
   - `let id = fun x -> x in`
   - `let const = fun x -> fun _ -> x in`
   - `let compose = fun f -> fun g -> fun x -> f (g x) in`

8. **hd, tl** (PRE-08):
   - `let hd = fun xs -> match xs with | h :: _ -> h in` (no empty list case - will error)
   - `let tl = fun xs -> match xs with | _ :: t -> t in` (no empty list case - will error)

Final expression: `()` (discarded by evalToEnv)

Add header comment explaining this is the FunLang standard library.
  </action>
  <verify>
`dotnet run --project FunLang -- -e "let x = 1 in x"` runs (basic sanity, prelude not loaded yet).
Prelude.fun file exists and is valid FunLang syntax (will be tested in Plan 02).
  </verify>
  <done>
Prelude.fun exists with all 11 functions (map, filter, fold, length, reverse, append, hd, tl, id, const, compose).
File ends with `()` for evalToEnv compatibility.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` succeeds
2. `ls Prelude.fun FunLang/Prelude.fs` shows both files exist
3. `grep -c "let rec" Prelude.fun` returns >= 7 (map, filter, fold, length, append, plus helpers)
4. `grep "loadPrelude" FunLang/Prelude.fs` shows function exists
</verification>

<success_criteria>
- Prelude.fs module compiles and exports loadPrelude function
- Prelude.fun contains all 11 required stdlib functions
- evalToEnv correctly handles nested let-in structure (verified in Plan 02)
- Build succeeds with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-prelude/04-01-SUMMARY.md`
</output>
