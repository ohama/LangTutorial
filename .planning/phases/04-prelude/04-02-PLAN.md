---
phase: 04-prelude
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - FunLang/Repl.fs
  - FunLang/Program.fs
  - tests/prelude/map.fun
  - tests/prelude/filter.fun
  - tests/prelude/fold.fun
  - tests/prelude/hd-tl.fun
  - tests/prelude/utils.fun
  - tests/Makefile
autonomous: true

must_haves:
  truths:
    - "REPL starts with prelude functions available"
    - "CLI --expr mode has prelude functions available"
    - "CLI file mode has prelude functions available"
    - "map (fun x -> x * 2) [1, 2, 3] returns [2, 4, 6]"
    - "filter (fun x -> x > 1) [1, 2, 3] returns [2, 3]"
    - "fold (fun a b -> a + b) 0 [1, 2, 3] returns 6"
    - "hd [1, 2, 3] returns 1, tl [1, 2, 3] returns [2, 3]"
  artifacts:
    - path: "FunLang/Repl.fs"
      provides: "REPL with prelude"
      contains: "Prelude.loadPrelude"
    - path: "FunLang/Program.fs"
      provides: "CLI with prelude"
      contains: "Prelude.loadPrelude"
    - path: "tests/prelude/map.fun"
      provides: "map function tests"
      contains: "CHECK:"
  key_links:
    - from: "FunLang/Repl.fs"
      to: "FunLang/Prelude.fs"
      via: "Prelude.loadPrelude call"
      pattern: "Prelude\\.loadPrelude"
    - from: "FunLang/Program.fs"
      to: "FunLang/Prelude.fs"
      via: "Prelude.loadPrelude call"
      pattern: "Prelude\\.loadPrelude"
---

<objective>
Integrate prelude loading into REPL and CLI, add comprehensive tests

Purpose: Complete PRE-09 (auto-load on startup) and verify all prelude functions work correctly through end-to-end tests. This completes Phase 4.

Output: Modified Repl.fs and Program.fs that load prelude on startup, fslit test files verifying all prelude functions
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-prelude/04-RESEARCH.md
@.planning/phases/04-prelude/04-01-SUMMARY.md

@FunLang/Repl.fs
@FunLang/Program.fs
@FunLang/Prelude.fs
@Prelude.fun
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate prelude into REPL and CLI</name>
  <files>FunLang/Repl.fs, FunLang/Program.fs</files>
  <action>
**Modify FunLang/Repl.fs:**

Change `startRepl` function to use prelude environment instead of emptyEnv:

```fsharp
/// Start the REPL with welcome message
let startRepl () : int =
    printfn "FunLang REPL"
    printfn "Type '#quit' or Ctrl+D to quit."
    printfn ""
    let initialEnv = Prelude.loadPrelude()  // CHANGED from emptyEnv
    replLoop initialEnv
    0
```

**Modify FunLang/Program.fs:**

1. Add `open Prelude` at top (or use qualified Prelude.loadPrelude)

2. Create initialEnv near the start of main, AFTER Argu parsing setup but BEFORE the if/elif chain:
```fsharp
let initialEnv = Prelude.loadPrelude()
```

3. Update `--expr` only case (around line 88-96):
   - Change `expr |> parse |> evalExpr` to use `eval initialEnv` instead of `evalExpr` (which uses emptyEnv)
   - Replace: `let result = expr |> parse |> evalExpr`
   - With: `let result = eval initialEnv (parse expr)`

4. Update file only case (around line 98-111):
   - Same change: use `eval initialEnv` instead of `evalExpr`
   - Replace: `let result = input |> parse |> evalExpr`
   - With: `let result = eval initialEnv (parse input)`

Note: REPL already calls Repl.startRepl() which will use prelude. The --emit-tokens and --emit-ast cases don't need prelude since they don't evaluate.

Ensure `open Eval` is present to access `eval` function directly.
  </action>
  <verify>
`dotnet build FunLang` succeeds.
`dotnet run --project FunLang -- -e "map (fun x -> x * 2) [1, 2, 3]"` returns `[2, 4, 6]`.
  </verify>
  <done>
Repl.fs uses Prelude.loadPrelude() for initial environment.
Program.fs uses prelude environment for --expr and file evaluation modes.
Prelude functions are available in all execution modes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add prelude integration tests</name>
  <files>tests/prelude/map.fun, tests/prelude/filter.fun, tests/prelude/fold.fun, tests/prelude/hd-tl.fun, tests/prelude/utils.fun, tests/Makefile</files>
  <action>
Create `tests/prelude/` directory and add fslit test files.

**tests/prelude/map.fun:**
```
// Test: Prelude map function (PRE-01)
// RUN: dotnet run --project FunLang -- -e %s
map (fun x -> x * 2) [1, 2, 3]
// CHECK: [2, 4, 6]

// Test: map with empty list
// RUN: dotnet run --project FunLang -- -e %s
map (fun x -> x + 1) []
// CHECK: []

// Test: map preserves length
// RUN: dotnet run --project FunLang -- -e %s
length (map (fun x -> x) [1, 2, 3, 4, 5])
// CHECK: 5
```

**tests/prelude/filter.fun:**
```
// Test: Prelude filter function (PRE-02)
// RUN: dotnet run --project FunLang -- -e %s
filter (fun x -> x > 1) [1, 2, 3]
// CHECK: [2, 3]

// Test: filter all pass
// RUN: dotnet run --project FunLang -- -e %s
filter (fun x -> x > 0) [1, 2, 3]
// CHECK: [1, 2, 3]

// Test: filter none pass
// RUN: dotnet run --project FunLang -- -e %s
filter (fun x -> x > 10) [1, 2, 3]
// CHECK: []

// Test: filter empty list
// RUN: dotnet run --project FunLang -- -e %s
filter (fun x -> true) []
// CHECK: []
```

**tests/prelude/fold.fun:**
```
// Test: Prelude fold function - sum (PRE-03)
// RUN: dotnet run --project FunLang -- -e %s
fold (fun a -> fun b -> a + b) 0 [1, 2, 3]
// CHECK: 6

// Test: fold with initial value
// RUN: dotnet run --project FunLang -- -e %s
fold (fun a -> fun b -> a + b) 10 [1, 2, 3]
// CHECK: 16

// Test: fold empty list returns initial
// RUN: dotnet run --project FunLang -- -e %s
fold (fun a -> fun b -> a + b) 42 []
// CHECK: 42

// Test: fold product
// RUN: dotnet run --project FunLang -- -e %s
fold (fun a -> fun b -> a * b) 1 [1, 2, 3, 4]
// CHECK: 24

// Test: fold is left-associative
// RUN: dotnet run --project FunLang -- -e %s
fold (fun a -> fun b -> a - b) 10 [1, 2, 3]
// CHECK: 4
```

**tests/prelude/hd-tl.fun:**
```
// Test: hd function (PRE-08)
// RUN: dotnet run --project FunLang -- -e %s
hd [1, 2, 3]
// CHECK: 1

// Test: tl function (PRE-08)
// RUN: dotnet run --project FunLang -- -e %s
tl [1, 2, 3]
// CHECK: [2, 3]

// Test: length function (PRE-04)
// RUN: dotnet run --project FunLang -- -e %s
length [1, 2, 3, 4, 5]
// CHECK: 5

// Test: length empty list
// RUN: dotnet run --project FunLang -- -e %s
length []
// CHECK: 0

// Test: reverse function (PRE-05)
// RUN: dotnet run --project FunLang -- -e %s
reverse [1, 2, 3]
// CHECK: [3, 2, 1]

// Test: reverse empty list
// RUN: dotnet run --project FunLang -- -e %s
reverse []
// CHECK: []

// Test: append function (PRE-06)
// RUN: dotnet run --project FunLang -- -e %s
append [1, 2] [3, 4]
// CHECK: [1, 2, 3, 4]

// Test: append with empty
// RUN: dotnet run --project FunLang -- -e %s
append [] [1, 2]
// CHECK: [1, 2]
```

**tests/prelude/utils.fun:**
```
// Test: id function (PRE-07)
// RUN: dotnet run --project FunLang -- -e %s
id 42
// CHECK: 42

// Test: id with list
// RUN: dotnet run --project FunLang -- -e %s
id [1, 2, 3]
// CHECK: [1, 2, 3]

// Test: const function (PRE-07)
// RUN: dotnet run --project FunLang -- -e %s
const 5 99
// CHECK: 5

// Test: compose function (PRE-07)
// RUN: dotnet run --project FunLang -- -e %s
let double = fun x -> x * 2 in let succ = fun x -> x + 1 in (compose double succ) 5
// CHECK: 12

// Test: compose with map
// RUN: dotnet run --project FunLang -- -e %s
let double = fun x -> x * 2 in map (compose double double) [1, 2, 3]
// CHECK: [4, 8, 12]
```

**Update tests/Makefile:**
Add `prelude` to the SUBDIRS list (after pattern-matching or at appropriate alphabetical position).
  </action>
  <verify>
`make -C tests` runs all tests including prelude tests.
All prelude tests pass.
  </verify>
  <done>
tests/prelude/ directory created with 5 test files.
All prelude functions tested: map, filter, fold, length, reverse, append, hd, tl, id, const, compose.
Tests verify success criteria from ROADMAP.md.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` succeeds
2. `dotnet run --project FunLang -- -e "map (fun x -> x * 2) [1, 2, 3]"` returns `[2, 4, 6]`
3. `dotnet run --project FunLang -- -e "filter (fun x -> x > 1) [1, 2, 3]"` returns `[2, 3]`
4. `dotnet run --project FunLang -- -e "fold (fun a -> fun b -> a + b) 0 [1, 2, 3]"` returns `6`
5. `dotnet run --project FunLang -- -e "hd [1, 2, 3]"` returns `1`
6. `dotnet run --project FunLang -- -e "tl [1, 2, 3]"` returns `[2, 3]`
7. `make -C tests` passes all tests including new prelude tests
</verification>

<success_criteria>
- PRE-09 complete: Prelude loads automatically on startup
- All success criteria from ROADMAP.md verified:
  1. `map (fun x -> x * 2) [1, 2, 3]` returns `[2, 4, 6]`
  2. `filter (fun x -> x > 1) [1, 2, 3]` returns `[2, 3]`
  3. `fold (fun a b -> a + b) 0 [1, 2, 3]` returns 6
  4. `hd [1, 2, 3]` returns 1, `tl [1, 2, 3]` returns `[2, 3]`
  5. FunLang startup has prelude functions available
- All prelude fslit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-prelude/04-02-SUMMARY.md`
</output>
