---
phase: 01-parser-extensions
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - FunLang/Parser.fsy
autonomous: true

must_haves:
  truths:
    - "Annotated expressions `(e : T)` parse correctly"
    - "Annotated lambdas `fun (x: int) -> e` parse correctly"
    - "Curried annotated lambdas `fun (x: int) (y: bool) -> e` parse correctly"
    - "Unannotated lambdas `fun x -> e` still parse correctly (backward compatibility)"
    - "Parenthesized expressions `(e)` still parse correctly (backward compatibility)"
  artifacts:
    - path: "FunLang/Parser.fsy"
      provides: "Annotation grammar rules"
      contains: "Annot|LambdaAnnot"
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "Annot/LambdaAnnot AST construction"
      pattern: "Annot\\(|LambdaAnnot\\("
    - from: "FunLang/Parser.fsy"
      to: "TypeExpr grammar"
      via: "TypeExpr non-terminal in annotation rules"
      pattern: "COLON TypeExpr"
---

<objective>
Add parser rules for annotated expressions and annotated lambdas with curried parameter support.

Purpose: Complete the parser extension for type annotation syntax. After this, users can write `(expr : type)` and `fun (x: type) -> expr` with curried multi-parameter support.
Output: Updated Parser.fsy with Annot, LambdaAnnot, and curried parameter rules.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-parser-extensions/01-RESEARCH.md
@.planning/phases/01-parser-extensions/01-02-SUMMARY.md

# Source files
@FunLang/Parser.fsy
@FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add annotated expression rule to Parser.fsy</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Add annotated expression rule to the Atom section of Parser.fsy.

Find the Atom rule section (around line 105). Add the annotated expression rule AFTER the existing `| LPAREN Expr RPAREN { $2 }` rule:

```fsharp
// v6.0: Annotated expression - (e : T)
| LPAREN Expr COLON TypeExpr RPAREN  { Annot($2, $4, ruleSpan parseState 1 5) }
```

This must come BEFORE the tuple rule `| LPAREN Expr COMMA ExprList RPAREN` to avoid ambiguity. The COLON token disambiguates from plain parenthesized expressions.

Order in Atom should be:
1. `| LPAREN Expr RPAREN { $2 }` - plain parenthesized
2. `| LPAREN Expr COLON TypeExpr RPAREN { Annot(...) }` - NEW: annotated
3. `| LPAREN Expr COMMA ExprList RPAREN { Tuple(...) }` - tuple
  </action>
  <verify>
`dotnet build FunLang` succeeds without grammar conflicts.
  </verify>
  <done>
Parser.fsy Atom section contains annotated expression rule with COLON disambiguator.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add annotated lambda rules with curried parameter support</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Add annotated lambda rules to Parser.fsy.

1. Add helper function to the preamble section (inside the %{ ... %} block, after symSpan helper around line 12):

```fsharp
/// Desugar curried annotated parameters into nested LambdaAnnot nodes
let rec desugarAnnotParams (params: (string * TypeExpr) list) (body: Expr) (span: Span) : Expr =
    match params with
    | [] -> failwith "desugarAnnotParams: empty param list"
    | [(name, ty)] -> LambdaAnnot(name, ty, body, span)
    | (name, ty) :: rest -> LambdaAnnot(name, ty, desugarAnnotParams rest body span, span)
```

2. Add annotated lambda rules to the Expr section (after the existing `| FUN IDENT ARROW Expr` rule around line 67):

```fsharp
// v6.0: Annotated lambda - fun (x: T) -> e
// Single parameter
| FUN LPAREN IDENT COLON TypeExpr RPAREN ARROW Expr
    { LambdaAnnot($3, $5, $8, ruleSpan parseState 1 8) }
// v6.0: Curried annotated lambda - fun (x: T) (y: U) -> e
// Multiple parameters via AnnotParamList
| FUN AnnotParamList ARROW Expr
    { desugarAnnotParams $2 $4 (ruleSpan parseState 1 4) }
```

3. Add AnnotParamList and AnnotParam rules AFTER the MatchClauses rules (before TypeExpr):

```fsharp
// v6.0: Annotated parameter list for curried lambdas
AnnotParamList:
    | AnnotParam AnnotParamList     { $1 :: $2 }
    | AnnotParam                    { [$1] }

AnnotParam:
    | LPAREN IDENT COLON TypeExpr RPAREN    { ($2, $4) }
```

Note: The single-parameter rule `FUN LPAREN IDENT COLON TypeExpr RPAREN ARROW Expr` overlaps with the curried rule but is more efficient for the common case. FsYacc will prefer the more specific rule.
  </action>
  <verify>
`dotnet build FunLang` succeeds. May have shift/reduce conflict warning - check it resolves correctly.
  </verify>
  <done>
Parser.fsy contains: desugarAnnotParams helper, annotated lambda rule, curried lambda rule with AnnotParamList, AnnotParam non-terminal.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and add parser tests</name>
  <files>None (verification only)</files>
  <action>
Verify backward compatibility and test new syntax:

1. Run all existing tests:
   ```bash
   dotnet build && make -C tests && dotnet run --project FunLang.Tests
   ```

2. Verify new syntax parses (manual testing via emit-ast):
   ```bash
   # Annotated expression
   echo "(1 + 2 : int)" | dotnet run --project FunLang -- --emit-ast -

   # Annotated lambda (single param)
   echo "fun (x: int) -> x + 1" | dotnet run --project FunLang -- --emit-ast -

   # Curried annotated lambda
   echo "fun (x: int) (y: int) -> x + y" | dotnet run --project FunLang -- --emit-ast -

   # Type expressions
   echo "(1 : int -> bool)" | dotnet run --project FunLang -- --emit-ast -
   echo "(1 : int * bool)" | dotnet run --project FunLang -- --emit-ast -
   echo "(1 : int list)" | dotnet run --project FunLang -- --emit-ast -
   echo "(1 : 'a)" | dotnet run --project FunLang -- --emit-ast -
   ```

3. Verify backward compatibility (unannotated syntax):
   ```bash
   # Unannotated lambda still works
   echo "fun x -> x + 1" | dotnet run --project FunLang -- --emit-ast -

   # Plain parenthesized still works
   echo "(1 + 2)" | dotnet run --project FunLang -- --emit-ast -

   # Cons operator still works (not confused with COLON)
   echo "1 :: 2 :: []" | dotnet run --project FunLang -- --emit-ast -
   ```

If any tests fail, check:
- Lexer token ordering (keywords before identifier, COLON after CONS)
- Grammar rule ordering (more specific rules first)
- Parser conflicts (review fsyacc output)
  </action>
  <verify>
All existing tests pass. New syntax produces expected AST structures.
  </verify>
  <done>
Build succeeds, all tests pass, new annotation syntax parses correctly, backward compatibility maintained.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` - Clean build
2. `make -C tests` - All fslit tests pass
3. `dotnet run --project FunLang.Tests` - All Expecto tests pass
4. Manual verification of new annotation syntax via --emit-ast
5. Manual verification of backward compatibility
</verification>

<success_criteria>
- [ ] Parser.fsy has annotated expression rule `(e : T)`
- [ ] Parser.fsy has annotated lambda rule `fun (x: T) -> e`
- [ ] Parser.fsy has curried annotated lambda support `fun (x: T) (y: U) -> e`
- [ ] Parser.fsy has AnnotParamList and AnnotParam non-terminals
- [ ] Parser.fsy has desugarAnnotParams helper function
- [ ] All existing tests pass (no breaking changes)
- [ ] New annotation syntax produces correct AST
- [ ] Unannotated code still parses correctly
- [ ] Cons operator (::) not confused with COLON (:)
</success_criteria>

<output>
After completion, create `.planning/phases/01-parser-extensions/01-03-SUMMARY.md`
</output>
