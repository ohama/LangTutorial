---
phase: 01-parser-extensions
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - FunLang/Parser.fsy
autonomous: true

must_haves:
  truths:
    - "Parser declares COLON, TYPE_INT, TYPE_BOOL, TYPE_STRING, TYPE_LIST, TYPE_VAR tokens"
    - "TypeExpr non-terminal parses type expressions"
    - "Arrow types are right-associative (int -> int -> int = int -> (int -> int))"
    - "Tuple types have higher precedence than arrow"
    - "List type uses postfix syntax (int list)"
  artifacts:
    - path: "FunLang/Parser.fsy"
      provides: "Token declarations and TypeExpr grammar"
      contains: "%token COLON"
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "TypeExpr AST construction"
      pattern: "TEInt|TEBool|TEArrow"
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Lexer.fsl"
      via: "Token type imports"
      pattern: "open Parser"
---

<objective>
Add parser token declarations and TypeExpr grammar rules.

Purpose: Enable parsing of type expressions like `int`, `int -> bool`, `int * bool`, `'a list`. These are needed before annotation syntax can be added.
Output: Updated Parser.fsy with token declarations and complete TypeExpr grammar.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-parser-extensions/01-RESEARCH.md
@.planning/phases/01-parser-extensions/01-01-SUMMARY.md

# Source files
@FunLang/Parser.fsy
@FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add token declarations to Parser.fsy</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Add the following token declarations to Parser.fsy in the token section (after line 33, before EOF):

```fsharp
// v6.0: Type annotation tokens
%token COLON
%token TYPE_INT TYPE_BOOL TYPE_STRING TYPE_LIST
%token <string> TYPE_VAR
```

Note:
- COLON is a simple token (no value)
- TYPE_INT/BOOL/STRING/LIST are simple tokens
- TYPE_VAR carries the string value (including the apostrophe, e.g., "'a")

Do NOT add any precedence declarations for type operators - we use grammar structure for precedence.
  </action>
  <verify>
Run `dotnet build FunLang` - should succeed (tokens declared but not yet used in grammar).
  </verify>
  <done>
Parser.fsy contains %token declarations for COLON, TYPE_INT, TYPE_BOOL, TYPE_STRING, TYPE_LIST, and TYPE_VAR.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TypeExpr grammar rules to Parser.fsy</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Add TypeExpr grammar rules to Parser.fsy AFTER the MatchClauses rule (at the end of the file):

```fsharp
// v6.0: Type expression grammar
// Precedence via grammar structure (not %left/%right):
//   Arrow (lowest) -> Tuple -> Atomic (highest)

TypeExpr:
    | ArrowType                     { $1 }

// Arrow is right-associative: int -> int -> int = int -> (int -> int)
ArrowType:
    | TupleType ARROW ArrowType     { TEArrow($1, $3) }
    | TupleType                     { $1 }

// Tuple types: int * bool * string (at least 2 elements)
TupleType:
    | AtomicType STAR TupleTypeList { TETuple($1 :: $3) }
    | AtomicType                    { $1 }

TupleTypeList:
    | AtomicType STAR TupleTypeList { $1 :: $3 }
    | AtomicType                    { [$1] }

// Atomic types: base types, type variables, list types, parenthesized
AtomicType:
    | TYPE_INT                      { TEInt }
    | TYPE_BOOL                     { TEBool }
    | TYPE_STRING                   { TEString }
    | TYPE_VAR                      { TEVar($1) }
    | AtomicType TYPE_LIST          { TEList($1) }
    | LPAREN TypeExpr RPAREN        { $2 }
```

Key design decisions:
- Three-level hierarchy (Arrow > Tuple > Atomic) encodes precedence without conflict
- Right-associativity of arrow via recursive `ArrowType` rule
- Postfix `TYPE_LIST` in `AtomicType` for ML-style `int list`
- Parentheses allow grouping: `(int -> int) list`
- No Span on TypeExpr (errors come from annotated expressions, not type syntax)
  </action>
  <verify>
Run `dotnet build FunLang` - should succeed (grammar compiles without conflicts).
  </verify>
  <done>
Parser.fsy contains TypeExpr, ArrowType, TupleType, TupleTypeList, AtomicType non-terminals with correct precedence structure.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify build and run existing tests</name>
  <files>None (verification only)</files>
  <action>
Run the full build and existing test suites to verify no regressions:

1. Build the project:
   ```bash
   dotnet build
   ```

2. Run fslit tests:
   ```bash
   make -C tests
   ```

3. Run Expecto tests:
   ```bash
   dotnet run --project FunLang.Tests
   ```

All existing tests must pass - the new tokens and grammar rules should not affect existing parsing since they're not yet used in expression rules.

If any tests fail:
- Check for grammar conflicts reported by fsyacc
- Verify token ordering in Lexer.fsl (keywords before identifier)
- Verify COLON comes after CONS pattern
  </action>
  <verify>
All three commands succeed with 0 test failures.
  </verify>
  <done>
Build succeeds, all existing fslit tests pass, all existing Expecto tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` - Clean build with no errors
2. `make -C tests` - All fslit tests pass
3. `dotnet run --project FunLang.Tests` - All Expecto tests pass
4. No fsyacc conflicts reported during build
</verification>

<success_criteria>
- [ ] Parser.fsy declares COLON token
- [ ] Parser.fsy declares TYPE_INT, TYPE_BOOL, TYPE_STRING, TYPE_LIST tokens
- [ ] Parser.fsy declares TYPE_VAR token with string value
- [ ] Parser.fsy has TypeExpr grammar with 5 non-terminals
- [ ] Arrow types parse as right-associative
- [ ] Tuple types have higher precedence than arrow
- [ ] List type uses postfix syntax (AtomicType TYPE_LIST)
- [ ] Build succeeds with no conflicts
- [ ] All existing tests pass (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/01-parser-extensions/01-02-SUMMARY.md`
</output>
