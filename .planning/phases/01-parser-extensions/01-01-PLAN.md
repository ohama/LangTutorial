---
phase: 01-parser-extensions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Lexer.fsl
  - FunLang/Ast.fs
autonomous: true

must_haves:
  truths:
    - "COLON token is lexed from `:` character"
    - "TYPE_INT/BOOL/STRING/LIST tokens are lexed from keywords"
    - "TYPE_VAR token is lexed from `'a`, `'b` etc"
    - "TypeExpr AST type is defined with all variants"
    - "Annot and LambdaAnnot Expr variants exist"
  artifacts:
    - path: "FunLang/Lexer.fsl"
      provides: "New tokens for type annotations"
      contains: "| ':'           { COLON }"
    - path: "FunLang/Ast.fs"
      provides: "TypeExpr type and annotated expression variants"
      contains: "type TypeExpr"
  key_links:
    - from: "FunLang/Lexer.fsl"
      to: "Parser tokens"
      via: "Token types imported from Parser module"
      pattern: "open Parser"
---

<objective>
Add lexer tokens and AST types for type annotation syntax.

Purpose: Foundation for parsing type annotations - tokens must exist before grammar rules can reference them, and AST types must exist before parser can construct them.
Output: Updated Lexer.fsl with new tokens, updated Ast.fs with TypeExpr type and Annot/LambdaAnnot variants.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-parser-extensions/01-RESEARCH.md

# Source files to modify
@FunLang/Lexer.fsl
@FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add type annotation tokens to Lexer.fsl</name>
  <files>FunLang/Lexer.fsl</files>
  <action>
Add the following tokens to Lexer.fsl:

1. Add type variable character class definition after existing `ident_char` definition (around line 27):
```fsharp
let type_var = '\'' letter (letter | digit | '_')*
```

2. Add type keywords AFTER existing keywords (after "with" around line 48) but BEFORE the underscore/wildcard pattern:
```fsharp
// v6.0: Type keywords for type annotations
| "int"         { TYPE_INT }
| "bool"        { TYPE_BOOL }
| "string"      { TYPE_STRING }
| "list"        { TYPE_LIST }
```

3. Add TYPE_VAR pattern AFTER type keywords but BEFORE the identifier pattern (before line 52):
```fsharp
// v6.0: Type variables ('a, 'b, etc.)
| type_var      { TYPE_VAR (lexeme lexbuf) }
```

4. Add COLON token AFTER the `::` CONS pattern (around line 62) but in the single-char operators section:
```fsharp
| ':'           { COLON }      // v6.0: Type annotation
```

CRITICAL ordering:
- Type keywords MUST come before identifier pattern (else "int" lexes as IDENT)
- COLON MUST come after "::" (else "::" lexes as two COLONs)
- TYPE_VAR MUST come before identifier (else "'a" fails to lex)
  </action>
  <verify>
Run `dotnet build FunLang` - should fail with "COLON not defined" or similar parser errors (expected since Parser.fsy doesn't declare these tokens yet).
  </verify>
  <done>
Lexer.fsl contains: TYPE_INT, TYPE_BOOL, TYPE_STRING, TYPE_LIST tokens after keywords; TYPE_VAR pattern with `type_var` definition; COLON token after CONS pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TypeExpr AST type and Annot/LambdaAnnot variants to Ast.fs</name>
  <files>FunLang/Ast.fs</files>
  <action>
Add the following to Ast.fs:

1. Add TypeExpr type definition AFTER the Constant type (around line 110), BEFORE the Value type:
```fsharp
/// Type expression AST for type annotations
/// v6.0: Bidirectional type system
and TypeExpr =
    | TEInt                               // int
    | TEBool                              // bool
    | TEString                            // string
    | TEList of TypeExpr                  // T list
    | TEArrow of TypeExpr * TypeExpr      // T1 -> T2 (right-associative)
    | TETuple of TypeExpr list            // T1 * T2 * ... (n >= 2)
    | TEVar of string                     // 'a, 'b (includes apostrophe)
```

2. Add Annot and LambdaAnnot variants to the Expr type (after Match around line 87):
```fsharp
// v6.0: Type annotations
| Annot of expr: Expr * typeExpr: TypeExpr * span: Span          // (e : T)
| LambdaAnnot of param: string * paramType: TypeExpr * body: Expr * span: Span  // fun (x: T) -> e
```

3. Update the `spanOf` function to handle new variants (around line 140):
Add to the match expression:
```fsharp
| Annot(_, _, s) | LambdaAnnot(_, _, _, s) -> s
```

Note: TypeExpr does NOT carry Span because type expressions are not the source of runtime errors - the annotated expressions are.
  </action>
  <verify>
Run `dotnet build FunLang/Ast.fs` or check with F# compiler that the type definitions are valid.
  </verify>
  <done>
Ast.fs contains: TypeExpr type with TEInt, TEBool, TEString, TEList, TEArrow, TETuple, TEVar variants; Expr type has Annot and LambdaAnnot variants; spanOf handles new variants.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` - Will fail at Parser.fs generation (expected - tokens not declared in Parser.fsy yet)
2. Visually verify Lexer.fsl token ordering is correct per RESEARCH.md
3. Visually verify Ast.fs TypeExpr type matches RESEARCH.md specification
</verification>

<success_criteria>
- [ ] Lexer.fsl has `type_var` character class
- [ ] Lexer.fsl has TYPE_INT, TYPE_BOOL, TYPE_STRING, TYPE_LIST tokens (before identifier pattern)
- [ ] Lexer.fsl has TYPE_VAR token (before identifier pattern)
- [ ] Lexer.fsl has COLON token (after CONS pattern)
- [ ] Ast.fs has TypeExpr type with all 7 variants
- [ ] Ast.fs has Annot and LambdaAnnot in Expr type
- [ ] Ast.fs spanOf function handles new Expr variants
- [ ] No syntax errors in modified files
</success_criteria>

<output>
After completion, create `.planning/phases/01-parser-extensions/01-01-SUMMARY.md`
</output>
