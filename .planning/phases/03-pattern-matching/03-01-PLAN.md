---
phase: 03-pattern-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Ast.fs
  - FunLang/Lexer.fsl
  - FunLang/Parser.fsy
autonomous: true

must_haves:
  truths:
    - "match expression parses with multiple clauses"
    - "Constant patterns (int, bool) parse correctly"
    - "Cons pattern h :: t parses correctly"
    - "Empty list pattern [] parses correctly"
    - "All existing tests still pass (no regressions)"
  artifacts:
    - path: "FunLang/Ast.fs"
      provides: "Match expression and new pattern types"
      contains: ["Match of", "ConsPat of", "EmptyListPat", "ConstPat of"]
    - path: "FunLang/Lexer.fsl"
      provides: "MATCH, WITH, PIPE tokens"
      contains: ["MATCH", "WITH", "PIPE"]
    - path: "FunLang/Parser.fsy"
      provides: "Match grammar rules"
      contains: ["MATCH Expr WITH MatchClauses", "MatchClauses"]
  key_links:
    - from: "FunLang/Parser.fsy"
      to: "FunLang/Ast.fs"
      via: "AST constructor calls"
      pattern: "Match\\(|ConsPat\\(|ConstPat\\("
---

<objective>
Add match expression syntax and new pattern types to FunLang AST, Lexer, and Parser.

Purpose: Enable parsing of `match e with | p1 -> e1 | p2 -> e2` expressions with constant, cons, and empty list patterns. This establishes the syntactic foundation for pattern matching evaluation in Plan 02.

Output: Extended AST with Match expression and new Pattern variants; Lexer with MATCH/WITH/PIPE tokens; Parser with match expression grammar.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-pattern-matching/03-RESEARCH.md

# Existing infrastructure (Phase 1-2)
@FunLang/Ast.fs
@FunLang/Lexer.fsl
@FunLang/Parser.fsy
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AST with Match expression and new Pattern types</name>
  <files>FunLang/Ast.fs</files>
  <action>
Extend the AST types in Ast.fs:

1. Add to Expr type:
   ```fsharp
   | Match of scrutinee: Expr * clauses: MatchClause list
   ```

2. Add new type after Pattern:
   ```fsharp
   and MatchClause = Pattern * Expr
   ```

3. Extend Pattern type with three new cases:
   ```fsharp
   | ConsPat of Pattern * Pattern     // h :: t
   | EmptyListPat                     // []
   | ConstPat of Constant             // 1, true
   ```

4. Add Constant type for pattern literals:
   ```fsharp
   and Constant =
       | IntConst of int
       | BoolConst of bool
   ```

The types must be defined in correct order for F# mutual recursion: Expr -> Pattern -> MatchClause -> Constant -> Value -> Env.

Note: MatchClause is a simple tuple (no named record needed). Constant enables future extension to string constants.
  </action>
  <verify>
Run `dotnet build FunLang` - should compile with no errors (parser not yet updated, so build will fail on parser, but Ast.fs should compile if syntax is correct). Verify by checking for "error FS" in Ast.fs specifically.
  </verify>
  <done>
Ast.fs compiles cleanly. Match, MatchClause, ConsPat, EmptyListPat, ConstPat, and Constant types exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add MATCH, WITH, PIPE tokens to Lexer</name>
  <files>FunLang/Lexer.fsl</files>
  <action>
Add three new tokens to Lexer.fsl:

1. Add keywords (MUST come before identifier pattern, after existing keywords like "let"):
   ```fsharp
   | "match"       { MATCH }
   | "with"        { WITH }
   ```

2. Add pipe character as single-char operator (after other single-char operators):
   ```fsharp
   | '|'           { PIPE }
   ```

The pipe token enables `| pattern -> expr` syntax in match clauses.

IMPORTANT: Keywords must come before the `ident_start ident_char*` pattern or they will be lexed as identifiers.
  </action>
  <verify>
Run `dotnet build FunLang` - Lexer.fsl should generate Lexer.fs without errors. Check for any "unexpected token" errors in fslex output.
  </verify>
  <done>
Lexer.fsl updated with MATCH, WITH, PIPE tokens. fslex generates Lexer.fs successfully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add match expression grammar to Parser</name>
  <files>FunLang/Parser.fsy</files>
  <action>
Extend Parser.fsy with match expression grammar:

1. Add token declarations (after existing tokens):
   ```fsharp
   %token MATCH WITH PIPE
   ```

2. Add match expression to Expr rule (at the top, before LET - match has lower precedence):
   ```fsharp
   | MATCH Expr WITH MatchClauses  { Match($2, $4) }
   ```

3. Add MatchClauses rule (non-empty list, requires at least one clause):
   ```fsharp
   MatchClauses:
       | PIPE Pattern ARROW Expr                { [($2, $4)] }
       | PIPE Pattern ARROW Expr MatchClauses   { ($2, $4) :: $5 }
   ```

4. Extend Pattern rule with new cases (add to existing Pattern rule):
   ```fsharp
   | NUMBER                      { ConstPat(IntConst($1)) }
   | TRUE                        { ConstPat(BoolConst(true)) }
   | FALSE                       { ConstPat(BoolConst(false)) }
   | LBRACKET RBRACKET           { EmptyListPat }
   | Pattern CONS Pattern        { ConsPat($1, $3) }
   ```

IMPORTANT:
- CONS is already declared with `%right CONS` for right-associativity in expressions. The same precedence applies to patterns.
- Pattern CONS Pattern uses right-recursion naturally, matching `h :: t :: rest` as `h :: (t :: rest)`.
- MatchClauses requires leading PIPE (F# style).

5. Verify no shift/reduce conflicts are introduced by running fsyacc.
  </action>
  <verify>
Run `dotnet build FunLang`:
- Parser.fsy should generate Parser.fs without errors
- Check fsyacc output for conflicts (should be 0 or same as before)
- Run `dotnet run --project FunLang -- -e "match 1 with | 1 -> 2"` - should parse (may fail on eval, which is expected)
  </verify>
  <done>
Parser.fsy compiles. Match expressions parse correctly. No new parser conflicts. `match 1 with | 1 -> 2` parses without syntax error.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   dotnet build FunLang
   ```
   Should compile with no errors.

2. **Parse verification (match expressions):**
   ```bash
   # These should parse (may fail on eval - that's Plan 02)
   dotnet run --project FunLang -- -e "match 1 with | 1 -> 2 | _ -> 3"
   dotnet run --project FunLang -- -e "match true with | true -> 1 | false -> 0"
   dotnet run --project FunLang -- -e "match x with | [] -> 0 | h :: t -> 1"
   dotnet run --project FunLang -- -e "match x with | (a, b) -> a"
   ```

3. **Regression tests:**
   ```bash
   make -C tests
   dotnet run --project FunLang.Tests
   ```
   All 122+ fslit tests and 175 Expecto tests should pass.
</verification>

<success_criteria>
1. Match expression `match e with | p1 -> e1 | p2 -> e2` parses without syntax error
2. Constant patterns (NUMBER, TRUE, FALSE) parse correctly
3. Cons pattern `h :: t` parses correctly (right-associative)
4. Empty list pattern `[]` parses correctly
5. Existing tuple pattern `(x, y)` still works in match expressions
6. Variable and wildcard patterns still work
7. No new parser conflicts
8. All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-pattern-matching/03-01-SUMMARY.md`
</output>
