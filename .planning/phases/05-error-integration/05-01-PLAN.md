---
phase: 05-error-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Diagnostic.fs
  - FunLang/Bidir.fs
  - tests/type-errors/13-annot-mismatch.flt
  - tests/type-errors/14-annot-mismatch-lambda.flt
  - tests/type-errors/15-lambda-annot-wrong-body.flt
autonomous: true

must_haves:
  truths:
    - "Annotation mismatch errors show 'due to type annotation' explanation"
    - "Error messages point to expression location (not annotation location)"
    - "Non-annotation errors remain unchanged"
  artifacts:
    - path: "FunLang/Diagnostic.fs"
      provides: "InCheckMode context and annotation-aware formatting"
      contains: "InCheckMode"
    - path: "FunLang/Bidir.fs"
      provides: "InCheckMode pushed when entering check from annotation"
      contains: "InCheckMode"
  key_links:
    - from: "FunLang/Bidir.fs"
      to: "InCheckMode"
      via: "Annot case pushes check context"
      pattern: "InCheckMode.*annotation"
    - from: "FunLang/Diagnostic.fs"
      to: "typeErrorToDiagnostic"
      via: "findExpectedTypeSource extracts annotation context"
      pattern: "due to.*annotation"
---

<objective>
Add mode-aware error diagnostics with expected type explanations from annotations.

Purpose: When a type annotation causes a type mismatch, the error message should explain that the expected type came from the annotation. This helps users understand WHY a type was expected, not just WHAT types mismatched.

Output: Enhanced Diagnostic.fs with InCheckMode context, Bidir.fs pushing annotation context, and updated golden tests showing "due to type annotation" messages.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase-specific
@.planning/phases/05-error-integration/05-RESEARCH.md

# Source files to modify
@FunLang/Diagnostic.fs
@FunLang/Bidir.fs

# Current golden tests (will be updated)
@tests/type-errors/13-annot-mismatch.flt
@tests/type-errors/14-annot-mismatch-lambda.flt
@tests/type-errors/15-lambda-annot-wrong-body.flt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InCheckMode to Diagnostic.fs with annotation-aware formatting</name>
  <files>FunLang/Diagnostic.fs</files>
  <action>
1. Add InCheckMode to InferContext discriminated union (after InConsTail):
   ```fsharp
   | InCheckMode of expected: Type * source: string * Span
   ```
   - `expected`: The expected type from annotation
   - `source`: String describing source ("annotation", "if-branch", etc.)
   - `Span`: Location of the annotation

2. Add InCheckMode case to formatContextStack function:
   ```fsharp
   | InCheckMode (ty, source, span) ->
       sprintf "expected %s due to %s at %s" (formatType ty) source (formatSpan span)
   ```

3. Add helper function findExpectedTypeSource before typeErrorToDiagnostic:
   ```fsharp
   /// Find the first InCheckMode in context to extract annotation source
   let findExpectedTypeSource (contexts: InferContext list) : (Type * string * Span) option =
       contexts
       |> List.tryPick (function
           | InCheckMode (ty, source, span) -> Some (ty, source, span)
           | _ -> None)
   ```

4. Modify typeErrorToDiagnostic for UnifyMismatch case:
   - After matching UnifyMismatch, check for annotation source
   - If annotation found, append "(due to type annotation at X)" to message
   - Change hint from "Check that all branches..." to "Check that the expression matches the annotated type"

   Updated code:
   ```fsharp
   | UnifyMismatch (expected, actual) ->
       let source = findExpectedTypeSource err.ContextStack
       let baseMsg = sprintf "Type mismatch: expected %s but got %s"
                       (formatType expected) (formatType actual)
       let message, hint =
           match source with
           | Some (_, "annotation", span) ->
               baseMsg,
               Some (sprintf "The type annotation at %s expects %s"
                       (formatSpan span) (formatType expected))
           | _ ->
               baseMsg,
               Some "Check that all branches of your expression return the same type"
       Some "E0301", message, hint
   ```

5. Add InCheckMode case to contextToSecondarySpans:
   ```fsharp
   | InCheckMode (_, source, span) -> (span, sprintf "due to %s" source)
   ```
  </action>
  <verify>
Run `dotnet build FunLang` - should compile without errors or warnings.
Run `dotnet run --project FunLang -- --help` - should show CLI help (smoke test).
  </verify>
  <done>
InCheckMode added to InferContext, formatContextStack handles it, findExpectedTypeSource helper exists, typeErrorToDiagnostic produces "due to annotation" hints for annotation-derived errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Push InCheckMode in Bidir.fs and update golden tests</name>
  <files>FunLang/Bidir.fs, tests/type-errors/13-annot-mismatch.flt, tests/type-errors/14-annot-mismatch-lambda.flt, tests/type-errors/15-lambda-annot-wrong-body.flt</files>
  <action>
1. In Bidir.fs, modify the Annot case in synth function to push InCheckMode:
   ```fsharp
   | Annot (e, tyExpr, span) ->
       let expectedTy = elaborateTypeExpr tyExpr
       let ctx' = InCheckMode (expectedTy, "annotation", span) :: ctx
       let s = check ctx' env e expectedTy
       (s, apply s expectedTy)
   ```

2. In Bidir.fs, modify the LambdaAnnot case in synth function to push InCheckMode for the parameter type:
   ```fsharp
   | LambdaAnnot (param, paramTyExpr, body, span) ->
       let paramTy = elaborateTypeExpr paramTyExpr
       let ctx' = InCheckMode (paramTy, "annotation", span) :: ctx
       let bodyEnv = Map.add param (Scheme ([], paramTy)) env
       let s, bodyTy = synth ctx' bodyEnv body
       (s, TArrow (apply s paramTy, bodyTy))
   ```

3. Update tests/type-errors/13-annot-mismatch.flt:
   - Keep same command
   - Update expected output to include annotation hint:
   ```
   error[E0301]: Type mismatch: expected int but got bool
    --> <expr>:1:1-5
      = due to annotation: <expr>:1:1-12
      = note: expected int due to annotation at <expr>:1:1-12
      = hint: The type annotation at <expr>:1:1-12 expects int
   ```
   NOTE: The exact format depends on how formatDiagnostic renders it. Run the command first to see actual output, then update the test.

4. Update tests/type-errors/14-annot-mismatch-lambda.flt similarly.

5. Update tests/type-errors/15-lambda-annot-wrong-body.flt similarly.

IMPORTANT: After modifying Bidir.fs, run the actual commands to see the new error format, then update golden tests to match exactly.
  </action>
  <verify>
Run `make -C tests` - all fslit tests should pass (15/15 type-error tests).
Run `dotnet run --project FunLang.Tests` - all Expecto tests should pass.
Run `dotnet run --project FunLang -- --emit-type --expr "(true : int)" 2>&1` - should show "due to annotation" hint.
  </verify>
  <done>
Bidir.fs pushes InCheckMode for Annot and LambdaAnnot cases. Golden tests updated to match new error format with annotation hints. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. **ERR-01 (Mode-aware context):**
   - InCheckMode exists in InferContext
   - Bidir.fs pushes InCheckMode when entering check mode from annotation

2. **ERR-02 (Expected type messages):**
   - `dotnet run --project FunLang -- --emit-type --expr "(true : int)" 2>&1` shows annotation-aware hint
   - Error message format: "Type mismatch: expected int but got bool" with hint mentioning annotation

3. **ERR-03 (Reuse existing infrastructure):**
   - No new exception types or error handling
   - Uses existing TypeException, Diagnostic, formatDiagnostic flow
   - Only extends InferContext and enhances formatting

4. **Regression check:**
   - `make -C tests` passes (66 fslit tests)
   - `dotnet run --project FunLang.Tests` passes (419+ Expecto tests)
   - Non-annotation type errors unchanged (run test 03-type-mismatch.flt to verify)
</verification>

<success_criteria>
- [ ] InCheckMode added to InferContext discriminated union
- [ ] formatContextStack handles InCheckMode
- [ ] findExpectedTypeSource helper function exists
- [ ] typeErrorToDiagnostic produces annotation-aware hints for UnifyMismatch
- [ ] Bidir.fs Annot case pushes InCheckMode before check
- [ ] Bidir.fs LambdaAnnot case pushes InCheckMode
- [ ] Golden tests 13-15 updated with new error format
- [ ] All fslit tests pass (make -C tests)
- [ ] All Expecto tests pass
- [ ] Non-annotation errors unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-error-integration/05-01-SUMMARY.md`
</output>
