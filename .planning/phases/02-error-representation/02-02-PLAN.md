---
phase: 02-error-representation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - FunLang/Unify.fs
  - FunLang/Infer.fs
  - FunLang/TypeCheck.fs
  - FunLang.Tests/UnifyTests.fs
  - FunLang.Tests/InferTests.fs
autonomous: true

must_haves:
  truths:
    - "unify throws TypeException with context and trace"
    - "infer maintains context stack during traversal"
    - "TypeError includes context stack showing inference path"
    - "TypeError includes trace showing unification failure location"
    - "typecheck catches TypeException and converts to Result"
  artifacts:
    - path: "FunLang/Unify.fs"
      provides: "Unification with context/trace threading"
      contains: "TypeException"
    - path: "FunLang/Infer.fs"
      provides: "Inference with context stack management"
      contains: "InferContext"
    - path: "FunLang/TypeCheck.fs"
      provides: "Type checking catching TypeException"
      contains: "TypeException"
  key_links:
    - from: "FunLang/Unify.fs"
      to: "FunLang/Diagnostic.fs"
      via: "open Diagnostic"
      pattern: "raise \\(TypeException"
    - from: "FunLang/Infer.fs"
      to: "FunLang/Diagnostic.fs"
      via: "open Diagnostic"
      pattern: "InferContext"
    - from: "FunLang/TypeCheck.fs"
      to: "FunLang/Diagnostic.fs"
      via: "open Diagnostic"
      pattern: "TypeException"
---

<objective>
Integrate rich error types into unification and inference.

Purpose: Thread context and trace through type inference so errors capture where they occurred (context stack) and what structurally failed (unify trace). Replace simple TypeError string exception with rich TypeException.
Output: Modified Unify.fs with context/trace threading, Infer.fs with context stack management, TypeCheck.fs catching TypeException.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-representation/02-RESEARCH.md
@.planning/phases/02-error-representation/02-01-SUMMARY.md
@FunLang/Diagnostic.fs
@FunLang/Unify.fs
@FunLang/Infer.fs
@FunLang/TypeCheck.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Unify.fs with context/trace threading</name>
  <files>FunLang/Unify.fs</files>
  <action>
Modify `Unify.fs` to thread context and trace through unification:

1. **Add imports:**
   ```fsharp
   open Diagnostic
   open Ast
   ```

2. **Remove old TypeError exception** (now defined in Diagnostic.fs as TypeException)

3. **Create new unifyWithContext function:**
   ```fsharp
   /// Unify with context and trace tracking for rich error messages
   let rec unifyWithContext (ctx: InferContext list) (trace: UnifyPath list)
                            (span: Span) (t1: Type) (t2: Type): Subst =
   ```

   The function should:
   - Thread `ctx` (context stack) and `trace` (unification path) through recursion
   - Build `trace` as it descends into type structure:
     - TArrow: add `AtFunctionParam t2` when unifying params, `AtFunctionReturn t2` when unifying returns
     - TTuple: add `AtTupleIndex (idx, t2)` for each element
     - TList: add `AtListElement t2` for element type
   - Throw TypeException with full context/trace on failure:
     ```fsharp
     raise (TypeException {
         Kind = UnifyMismatch (t1, t2)
         Span = span
         Term = None
         ContextStack = ctx
         Trace = trace
     })
     ```

4. **Keep original unify function as wrapper** (for backward compatibility):
   ```fsharp
   /// Robinson's unification algorithm (backward compatible)
   let unify (t1: Type) (t2: Type): Subst =
       unifyWithContext [] [] unknownSpan t1 t2
   ```
   This ensures existing code that calls `unify t1 t2` still works.

5. **Update occurs check error** to use TypeException with OccursCheck kind.

Key implementation pattern for TArrow:
```fsharp
| TArrow (a1, b1), TArrow (a2, b2) ->
    let s1 = unifyWithContext ctx (AtFunctionParam a2 :: trace) span a1 a2
    let s2 = unifyWithContext ctx (AtFunctionReturn b2 :: trace) span
                              (apply s1 b1) (apply s1 b2)
    compose s2 s1
```
  </action>
  <verify>
```bash
dotnet build FunLang
grep "unifyWithContext" FunLang/Unify.fs | wc -l  # Should be >= 5 (definition + recursive calls)
grep "TypeException" FunLang/Unify.fs | wc -l  # Should be >= 2
```
  </verify>
  <done>
Unify.fs has unifyWithContext that threads context and trace, throws TypeException with rich error data, and maintains backward-compatible unify wrapper.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Infer.fs with context stack management</name>
  <files>FunLang/Infer.fs</files>
  <action>
Modify `Infer.fs` to maintain context stack during inference:

1. **Add imports:**
   ```fsharp
   open Diagnostic
   ```

2. **Create inferWithContext function:**
   ```fsharp
   /// Infer type with context stack tracking for rich error messages
   let rec inferWithContext (ctx: InferContext list) (env: TypeEnv) (expr: Expr): Subst * Type =
   ```

3. **Context must be maintained for ALL expression types (CTX-02 requirement):**
   The following expression types MUST push appropriate InferContext before recursing:
   - `If` -> InIfCond, InIfThen, InIfElse
   - `App` -> InAppFun, InAppArg
   - `Let` -> InLetRhs, InLetBody
   - `LetRec` -> InLetRecBody
   - `Tuple` -> InTupleElement
   - `List` -> InListElement
   - `Cons` -> InConsHead, InConsTail
   - `Match` -> InMatch, InMatchClause

   Expression types that do NOT need context (leaf nodes or no recursive inference):
   - `Int`, `Bool`, `Str` - literals, no recursion
   - `Var` - lookup only, throws UnboundVar with ctx if missing
   - `Unit`, `Nil` - literals, no recursion
   - `Lam` - body is inferred but doesn't need special context (function body is its own context)

   **Implementation examples:**

   - **If expression:**
     ```fsharp
     | If (cond, thenExpr, elseExpr, span) ->
         let s1, condTy = inferWithContext (InIfCond span :: ctx) env cond
         // ... unify condTy with TBool using unifyWithContext ctx ...
         let s3, thenTy = inferWithContext (InIfThen span :: ctx) env' thenExpr
         let s4, elseTy = inferWithContext (InIfElse span :: ctx) env'' elseExpr
         // ...
     ```

   - **Application:**
     ```fsharp
     | App (func, arg, span) ->
         let s1, funcTy = inferWithContext (InAppFun span :: ctx) env func
         let s2, argTy = inferWithContext (InAppArg span :: ctx) env' arg
         // ...
     ```

   - **Let:**
     ```fsharp
     | Let (name, value, body, span) ->
         let s1, valueTy = inferWithContext (InLetRhs (name, span) :: ctx) env value
         // ...
         let s2, bodyTy = inferWithContext (InLetBody (name, span) :: ctx) bodyEnv body
         // ...
     ```

   - **LetRec:**
     ```fsharp
     | LetRec (name, param, body, expr, span) ->
         // ...
         let s1, bodyTy = inferWithContext (InLetRecBody (name, span) :: ctx) bodyEnv body
         // ...
     ```

   - **Tuple:**
     ```fsharp
     | Tuple (exprs, span) ->
         let folder (s, tys, idx) e =
             let ctx' = InTupleElement (idx, span) :: ctx
             let s', ty = inferWithContext ctx' (applyEnv s env) e
             (compose s' s, ty :: tys, idx + 1)
         // ...
     ```

   - **List literal:**
     ```fsharp
     | List (exprs, span) ->
         // Add InListElement context for each element with its index
         let folder (s, elemTy, idx) e =
             let ctx' = InListElement (idx, span) :: ctx
             let s', ty = inferWithContext ctx' (applyEnv s env) e
             // ...
     ```

   - **Cons:**
     ```fsharp
     | Cons (head, tail, span) ->
         let s1, headTy = inferWithContext (InConsHead span :: ctx) env head
         let s2, tailTy = inferWithContext (InConsTail span :: ctx) env' tail
         // ...
     ```

   - **Match:**
     ```fsharp
     | Match (scrutinee, clauses, span) ->
         let s1, scrutTy = inferWithContext (InMatch span :: ctx) env scrutinee
         let folder s (idx, (pat, expr)) =
             // ...
             let s'', exprTy = inferWithContext (InMatchClause (idx, span) :: ctx) clauseEnv expr
             // ...
     ```

4. **Update unify calls to use unifyWithContext:**
   Every `unify t1 t2` call should become `unifyWithContext ctx [] (spanOf expr) t1 t2`
   Pass the current context stack and the expression's span.

5. **Throw TypeException for UnboundVar:**
   ```fsharp
   | Var (name, span) ->
       match Map.tryFind name env with
       | Some scheme -> (empty, instantiate scheme)
       | None ->
           raise (TypeException {
               Kind = UnboundVar name
               Span = span
               Term = Some expr
               ContextStack = ctx
               Trace = []
           })
   ```

6. **Wrap existing infer as backward-compatible entry point:**
   ```fsharp
   /// Infer type for expression (Algorithm W) - backward compatible
   and infer (env: TypeEnv) (expr: Expr): Subst * Type =
       inferWithContext [] env expr
   ```

7. **Enrich errors with Term on catch:**
   If we catch a TypeException and Term is None, set it to current expr:
   ```fsharp
   try
       // inference code
   with
   | TypeException err when err.Term.IsNone ->
       raise (TypeException { err with Term = Some expr })
   ```
   This ensures the innermost expression is captured.
  </action>
  <verify>
```bash
dotnet build FunLang
grep "inferWithContext" FunLang/Infer.fs | wc -l  # Should be >= 15 (definition + recursive calls)
grep "InferContext" FunLang/Infer.fs | wc -l  # Should be >= 10
grep "unifyWithContext" FunLang/Infer.fs | wc -l  # Should be >= 5
```
  </verify>
  <done>
Infer.fs has inferWithContext that threads context stack through ALL expression types requiring recursion, uses unifyWithContext for unification calls, and throws TypeException for unbound variables.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update TypeCheck.fs to catch TypeException</name>
  <files>FunLang/TypeCheck.fs</files>
  <action>
Update `TypeCheck.fs` to catch the new TypeException:

1. **Add import:**
   ```fsharp
   open Diagnostic
   ```

2. **Update typecheck function:**
   ```fsharp
   /// Type check an expression using the initial type environment
   /// Returns Ok(type) on success, Error(message) on type error
   let typecheck (expr: Expr): Result<Type, string> =
       try
           let subst, ty = infer initialTypeEnv expr
           Ok(apply subst ty)
       with
       | TypeException err ->
           // Convert to Diagnostic, then extract message for backward compatibility
           let diag = typeErrorToDiagnostic err
           Error(diag.Message)
   ```

   Note: For now we just extract the Message for backward compatibility.
   Phase 4 will use the full Diagnostic for rendering.

3. **Add typecheckWithDiagnostic function for full diagnostic access:**
   ```fsharp
   /// Type check an expression and return full diagnostic on error
   /// Returns Ok(type) on success, Error(Diagnostic) on type error
   let typecheckWithDiagnostic (expr: Expr): Result<Type, Diagnostic> =
       try
           let subst, ty = infer initialTypeEnv expr
           Ok(apply subst ty)
       with
       | TypeException err ->
           Error(typeErrorToDiagnostic err)
   ```
   This provides access to full error details for Phase 4.
  </action>
  <verify>
```bash
dotnet build FunLang
grep "TypeException" FunLang/TypeCheck.fs | wc -l  # Should be >= 2
grep "typeErrorToDiagnostic" FunLang/TypeCheck.fs | wc -l  # Should be >= 1
grep "typecheckWithDiagnostic" FunLang/TypeCheck.fs | wc -l  # Should be >= 1

# Functional test: verify TypeException is caught and converted to error message
echo "1 + true" | dotnet run --project FunLang 2>&1 | grep -i "type"
# Should output an error message containing "type" (e.g., "Type mismatch" or similar)
```
  </verify>
  <done>
TypeCheck.fs catches TypeException, converts to Diagnostic, provides both string-based (backward compat) and Diagnostic-based error results. Functional test confirms type errors are properly caught and converted.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update tests for new exception type</name>
  <files>FunLang.Tests/UnifyTests.fs, FunLang.Tests/InferTests.fs</files>
  <action>
Update test files to work with the new TypeException:

1. **In UnifyTests.fs:**
   - Add `open Diagnostic`
   - Update tests that catch `TypeError` to catch `TypeException`:
     ```fsharp
     // Old:
     try
         unify TInt TBool |> ignore
         failtest "Expected TypeError"
     with
     | TypeError _ -> ()

     // New:
     try
         unify TInt TBool |> ignore
         failtest "Expected TypeException"
     with
     | TypeException err ->
         Expect.equal err.Kind (UnifyMismatch (TInt, TBool)) "Should be UnifyMismatch"
     ```
   - Add tests that verify error kind is correct (UnifyMismatch, OccursCheck)

2. **In InferTests.fs:**
   - Add `open Diagnostic`
   - Update tests that catch `TypeError` to catch `TypeException`:
     ```fsharp
     // Old:
     try
         infer Map.empty (Var ("x", unknownSpan)) |> ignore
         failtest "Expected TypeError"
     with
     | TypeError msg -> Expect.stringContains msg "Unbound" "Should mention unbound"

     // New:
     try
         infer Map.empty (Var ("x", unknownSpan)) |> ignore
         failtest "Expected TypeException"
     with
     | TypeException err ->
         Expect.equal err.Kind (UnboundVar "x") "Should be UnboundVar"
     ```
   - Add tests verifying context stack is populated for complex expressions
  </action>
  <verify>
```bash
dotnet run --project FunLang.Tests
# All tests should pass
```
  </verify>
  <done>
Tests updated to catch TypeException, verify error kinds, and all tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 5: Run full test suite and verify no regressions</name>
  <files></files>
  <action>
Run the complete test suite to verify no regressions:

```bash
# Build everything
dotnet build

# Run Expecto tests
dotnet run --project FunLang.Tests

# Run fslit tests
make -C tests

# Test REPL still works
echo "let x = 1 + 2 in x * 3" | dotnet run --project FunLang

# Test type error messages are improved
echo "1 + true" | dotnet run --project FunLang --emit-type 2>&1 | head -5
```

Expected results:
- Expecto: 362+ tests pass
- fslit: 168/190 pass (same as before - pre-existing failures)
- REPL: Works correctly
- Type errors: Now include richer messages
  </action>
  <verify>
```bash
# Verify Expecto tests pass (look for "passed" in output)
dotnet run --project FunLang.Tests 2>&1 | grep "passed"

# Verify fslit tests pass
make -C tests 2>&1 | grep -E "passed|OK"

# Verify REPL computes correctly (should output 9)
echo "let x = 1 + 2 in x * 3" | dotnet run --project FunLang | grep "9"
```
All tests pass, REPL works and outputs 9 for the test expression, type error messages are richer than before.
  </verify>
  <done>
Full test suite passes, no regressions, type error messages include context information.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang` compiles without errors
2. Unify.fs uses TypeException with context/trace
3. Infer.fs maintains context stack through inference
4. TypeCheck.fs catches TypeException
5. All Expecto tests pass
6. All fslit tests pass (same rate as before)
7. Type error messages include context information
</verification>

<success_criteria>
- unifyWithContext threads context and trace parameters
- inferWithContext maintains context stack at ALL expression types requiring recursion
- TypeException replaces old TypeError exception throughout
- typecheck returns Result with rich error message
- typecheckWithDiagnostic returns Result with full Diagnostic
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-representation/02-02-SUMMARY.md`
</output>
