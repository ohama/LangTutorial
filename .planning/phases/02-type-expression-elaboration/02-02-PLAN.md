---
phase: 02-type-expression-elaboration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - FunLang.Tests/ElaborateTests.fs
  - FunLang.Tests/FunLang.Tests.fsproj
autonomous: true

must_haves:
  truths:
    - "Unit tests validate all primitive type elaborations"
    - "Unit tests validate compound type elaborations (arrow, tuple, list)"
    - "Unit tests validate type variable scoping within elaborateScoped"
    - "Unit tests validate polymorphic annotation patterns like 'a -> 'a"
  artifacts:
    - path: "FunLang.Tests/ElaborateTests.fs"
      provides: "Expecto tests for Elaborate module"
      exports: ["elaborateTests"]
      min_lines: 80
    - path: "FunLang.Tests/FunLang.Tests.fsproj"
      provides: "ElaborateTests.fs in compile order"
      contains: '<Compile Include="ElaborateTests.fs"'
  key_links:
    - from: "FunLang.Tests/ElaborateTests.fs"
      to: "Elaborate.elaborateTypeExpr"
      via: "function call"
      pattern: "Elaborate\\.elaborateTypeExpr"
    - from: "FunLang.Tests/ElaborateTests.fs"
      to: "Elaborate.elaborateScoped"
      via: "function call"
      pattern: "Elaborate\\.elaborateScoped"
---

<objective>
Create comprehensive unit tests for the Elaborate module validating all type expression conversions and scoping behavior

Purpose: Verify ELAB-01, ELAB-02, ELAB-03 requirements through automated testing
Output: FunLang.Tests/ElaborateTests.fs with test coverage for all elaboration scenarios
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-type-expression-elaboration/02-RESEARCH.md
@.planning/phases/02-type-expression-elaboration/02-01-SUMMARY.md
@FunLang/Elaborate.fs
@FunLang.Tests/TypeTests.fs (Expecto test pattern reference)
@FunLang.Tests/FunLang.Tests.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ElaborateTests.fs with comprehensive test coverage</name>
  <files>FunLang.Tests/ElaborateTests.fs</files>
  <action>
Create FunLang.Tests/ElaborateTests.fs with Expecto tests for the Elaborate module.

**Module structure:**
```fsharp
module ElaborateTests

open Expecto
open Ast
open Type
open Elaborate
```

**Test groups to implement:**

**1. Primitive type elaboration (ELAB-01):**
- `TEInt -> TInt`
- `TEBool -> TBool`
- `TEString -> TString`

**2. Compound type elaboration (ELAB-01):**
- `TEList TEInt -> TList TInt`
- `TEList (TEList TEBool) -> TList (TList TBool)` (nested)
- `TEArrow (TEInt, TEBool) -> TArrow (TInt, TBool)`
- `TEArrow (TEInt, TEArrow (TEBool, TEString)) -> TArrow (TInt, TArrow (TBool, TString))` (curried)
- `TETuple [TEInt; TEBool] -> TTuple [TInt; TBool]`
- `TETuple [TEInt; TEBool; TEString] -> TTuple [TInt; TBool; TString]` (3-tuple)

**3. Type variable elaboration (ELAB-02):**
- `TEVar "'a" -> TVar n` (some fresh index)
- Two different vars get different indices: `TEArrow (TEVar "'a", TEVar "'b")` -> indices differ
- Same var gets same index: `TEArrow (TEVar "'a", TEVar "'a")` -> same index both times

**4. Scoped elaboration (ELAB-02, ELAB-03):**
- `elaborateScoped [TEVar "'a"; TEVar "'a"]` -> both TVar have same index
- `elaborateScoped [TEVar "'a"; TEVar "'b"; TEVar "'a"]` -> first and third same, second different
- Identity function pattern: `elaborateScoped [TEVar "'a"; TEVar "'a"]` models `(x: 'a) : 'a`

**5. Complex patterns (ELAB-03):**
- Polymorphic identity: `TEArrow (TEVar "'a", TEVar "'a")` -> `TArrow (TVar n, TVar n)` (same n)
- Map-like signature: `TEArrow (TEArrow (TEVar "'a", TEVar "'b"), TEArrow (TEList (TEVar "'a"), TEList (TEVar "'b")))`

**Test implementation pattern (follow TypeTests.fs style):**
```fsharp
[<Tests>]
let elaborateTests =
    testList "Elaborate Module" [
        testList "Primitives (ELAB-01)" [
            testCase "TEInt -> TInt" <| fun _ ->
                let result = elaborateTypeExpr TEInt
                Expect.equal result TInt "TEInt should elaborate to TInt"
            // ...
        ]
        // ...
    ]
```

**Key assertions:**
- For type variable tests, use pattern matching to extract TVar index
- Compare indices for equality/inequality, not exact values (indices are fresh)
  </action>
  <verify>
1. File exists: `ls FunLang.Tests/ElaborateTests.fs`
2. Compiles: `dotnet build FunLang.Tests 2>&1 | grep -E "(error|Build succeeded)"`
3. Tests attribute present: `grep -c "\\[<Tests>\\]" FunLang.Tests/ElaborateTests.fs`
  </verify>
  <done>
ElaborateTests.fs exists with test groups covering primitives, compounds, type variables, scoping, and complex patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ElaborateTests.fs to test project and run full suite</name>
  <files>FunLang.Tests/FunLang.Tests.fsproj</files>
  <action>
Insert ElaborateTests.fs into FunLang.Tests.fsproj ItemGroup.

**Placement:**
- After TypeTests.fs (logically: Type module tests, then Elaborate module tests)
- Before UnifyTests.fs

**Add this line:**
```xml
    <Compile Include="ElaborateTests.fs" />
```

**Run verification:**
1. Build test project
2. Run all tests
3. Verify new ElaborateTests pass
4. Verify no regressions in existing tests
  </action>
  <verify>
1. Test project builds: `dotnet build FunLang.Tests`
2. All tests pass: `dotnet run --project FunLang.Tests 2>&1 | tail -10`
3. ElaborateTests included: `dotnet run --project FunLang.Tests 2>&1 | grep -i elaborate`
4. fslit tests pass: `make -C tests 2>&1 | tail -5`
  </verify>
  <done>
ElaborateTests.fs added to test project, all tests pass including new Elaborate module tests and existing test suite.
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate polymorphic annotation patterns</name>
  <files>FunLang.Tests/ElaborateTests.fs</files>
  <action>
Add specific tests validating ELAB-03 polymorphic annotation patterns.

**Add test cases for:**

1. **Identity function annotation:**
```fsharp
// let id (x: 'a) : 'a = x
// Parameter and return share same 'a
testCase "identity function pattern" <| fun _ ->
    let [paramTy; retTy] = elaborateScoped [TEVar "'a"; TEVar "'a"]
    match (paramTy, retTy) with
    | (TVar a, TVar b) -> Expect.equal a b "'a in param and return should be same"
    | _ -> failtest "Expected TVar"
```

2. **Swap function annotation:**
```fsharp
// let swap (x: 'a) (y: 'b) : 'b * 'a = (y, x)
testCase "swap function uses two type vars" <| fun _ ->
    let tys = elaborateScoped [TEVar "'a"; TEVar "'b"; TETuple [TEVar "'b"; TEVar "'a"]]
    // Verify 'a and 'b are distinct, and reused correctly
```

3. **Const function annotation:**
```fsharp
// let const (x: 'a) (y: 'b) : 'a = x
testCase "const function ignores second arg type" <| fun _ ->
    let tys = elaborateScoped [TEVar "'a"; TEVar "'b"; TEVar "'a"]
    // 'a at positions 0 and 2 should match
```

**Why these patterns matter:**
- They model real polymorphic function signatures
- They validate that scoped elaboration correctly shares type variables
- Phase 3+ will use these patterns for bidirectional checking
  </action>
  <verify>
1. Build: `dotnet build FunLang.Tests`
2. Run with filter: `dotnet run --project FunLang.Tests -- --filter "polymorphic"`
3. All tests pass: `dotnet run --project FunLang.Tests 2>&1 | grep -E "passed|failed"`
  </verify>
  <done>
Polymorphic annotation pattern tests validate identity, swap, and const function signatures with correct type variable sharing.
  </done>
</task>

</tasks>

<verification>
1. `dotnet run --project FunLang.Tests` - all tests pass
2. `make -C tests` - fslit integration tests pass
3. ElaborateTests cover all 7 TypeExpr variants
4. Scoped elaboration tests validate ELAB-02 and ELAB-03
</verification>

<success_criteria>
- ElaborateTests.fs exists with 15+ test cases
- All primitive types tested (ELAB-01)
- All compound types tested (ELAB-01)
- Type variable scoping tested (ELAB-02)
- Polymorphic annotation patterns tested (ELAB-03)
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-type-expression-elaboration/02-02-SUMMARY.md`
</output>
