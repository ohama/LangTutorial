---
phase: 02-type-expression-elaboration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Elaborate.fs
  - FunLang/FunLang.fsproj
autonomous: true

must_haves:
  truths:
    - "TEInt elaborates to TInt"
    - "TEBool elaborates to TBool"
    - "TEString elaborates to TString"
    - "TEList elaborates to TList with elaborated element type"
    - "TEArrow elaborates to TArrow with elaborated domain and range"
    - "TETuple elaborates to TTuple with all elements elaborated"
    - "TEVar elaborates to TVar with consistent index per name within scope"
  artifacts:
    - path: "FunLang/Elaborate.fs"
      provides: "elaborateTypeExpr and elaborateScoped functions"
      exports: ["elaborateTypeExpr", "elaborateScoped"]
      min_lines: 40
    - path: "FunLang/FunLang.fsproj"
      provides: "Elaborate.fs in build order after Type.fs, before Infer.fs"
      contains: '<Compile Include="Elaborate.fs"'
  key_links:
    - from: "FunLang/Elaborate.fs"
      to: "Ast.TypeExpr"
      via: "pattern match on TypeExpr"
      pattern: "match te with"
    - from: "FunLang/Elaborate.fs"
      to: "Type.Type"
      via: "returns Type values"
      pattern: "TInt|TBool|TString|TVar|TArrow|TTuple|TList"
---

<objective>
Create the Elaborate module that converts surface type syntax (TypeExpr) to internal type representation (Type)

Purpose: Enable bidirectional type checker to use user-written type annotations
Output: FunLang/Elaborate.fs with elaborateTypeExpr and elaborateScoped functions
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-type-expression-elaboration/02-RESEARCH.md
@FunLang/Ast.fs (TypeExpr type definition lines 117-124)
@FunLang/Type.fs (Type type definition lines 5-12)
@FunLang/Infer.fs (freshVar pattern lines 9-14)
@FunLang/FunLang.fsproj (build order)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Elaborate.fs with core elaboration functions</name>
  <files>FunLang/Elaborate.fs</files>
  <action>
Create FunLang/Elaborate.fs implementing type expression elaboration.

**Module structure:**
```fsharp
module Elaborate

open Ast
open Type
```

**Fresh type variable counter:**
- Use same pattern as Infer.freshVar (mutable ref cell)
- Start at 0 (separate range from inference's 1000+)
- Function freshTypeVarIndex returns int, not Type

**Type variable environment:**
- TypeVarEnv = Map<string, int> (maps 'a to TVar index)
- Thread environment through elaboration to track bindings

**Core function elaborateWithVars:**
```fsharp
let rec elaborateWithVars (vars: TypeVarEnv) (te: TypeExpr): Type * TypeVarEnv =
    match te with
    | TEInt -> (TInt, vars)
    | TEBool -> (TBool, vars)
    | TEString -> (TString, vars)
    | TEList t -> ...
    | TEArrow (t1, t2) -> ...
    | TETuple ts -> ...
    | TEVar name -> ...
```

**TEVar handling (critical for ELAB-02):**
- If name already in vars: return (TVar idx, vars)
- If name not in vars: create fresh index, add to vars, return (TVar idx, new vars)
- TEVar name includes apostrophe ('a), use name directly as key

**Public API:**
1. `elaborateTypeExpr (te: TypeExpr): Type` - elaborate single type with fresh scope
2. `elaborateScoped (tes: TypeExpr list): Type list` - elaborate multiple types sharing scope (for curried annotations like `fun (x: 'a) (y: 'a) -> ...`)

**TEArrow/TETuple/TEList implementation:**
- Thread environment through all children
- For TETuple: fold over list, accumulating types and environment
- Preserve order of type variables (first 'a seen gets lowest index)
  </action>
  <verify>
1. File exists: `ls FunLang/Elaborate.fs`
2. Module compiles: `dotnet build FunLang/FunLang.fsproj 2>&1 | grep -E "(error|Build succeeded)"`
3. Functions exported: `grep -E "^let (elaborateTypeExpr|elaborateScoped)" FunLang/Elaborate.fs`
  </verify>
  <done>
Elaborate.fs exists with elaborateTypeExpr and elaborateScoped functions that compile successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Elaborate.fs to FunLang.fsproj build order</name>
  <files>FunLang/FunLang.fsproj</files>
  <action>
Insert Elaborate.fs into the ItemGroup in FunLang.fsproj.

**Placement (critical for F# compilation order):**
- AFTER Type.fs (Elaborate.fs depends on Type module)
- BEFORE Infer.fs (future: Infer.fs will use Elaborate module)

**Add this line after the Type.fs Compile entry:**
```xml
    <!-- 2.5. Elaboration module (converts TypeExpr to Type) -->
    <Compile Include="Elaborate.fs" />
```

**Why this position:**
- Elaborate.fs opens Ast (TypeExpr) and Type (Type, TInt, etc.)
- Ast.fs and Type.fs are already compiled by this point
- Future phases will have Infer.fs open Elaborate
  </action>
  <verify>
1. Build succeeds: `dotnet build FunLang/FunLang.fsproj`
2. Correct order in fsproj: `grep -A2 "Type.fs" FunLang/FunLang.fsproj | grep "Elaborate.fs"`
3. Full test suite passes: `dotnet run --project FunLang.Tests 2>&1 | tail -5`
  </verify>
  <done>
FunLang.fsproj includes Elaborate.fs in correct build order, full project builds, all existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build FunLang/FunLang.fsproj` succeeds
2. `dotnet run --project FunLang.Tests` - all existing tests pass (no regressions)
3. Elaborate module is accessible from F# interactive or other modules
</verification>

<success_criteria>
- Elaborate.fs exists in FunLang/
- elaborateTypeExpr converts all 7 TypeExpr variants to corresponding Type
- Type variables in same scope map to same TVar index
- Project builds without errors
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-type-expression-elaboration/02-01-SUMMARY.md`
</output>
