---
phase: 01-tuples
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - FunLang/Eval.fs
  - tests/tuples/01-tuple-basic.flt
  - tests/tuples/02-tuple-nested.flt
  - tests/tuples/03-tuple-heterogeneous.flt
  - tests/tuples/04-pattern-simple.flt
  - tests/tuples/05-pattern-nested.flt
  - tests/tuples/06-pattern-wildcard.flt
  - tests/Makefile
autonomous: true

must_haves:
  truths:
    - "(1, 2) evaluates to TupleValue containing IntValue 1 and IntValue 2"
    - "let (x, y) = (1, 2) in x + y evaluates to 3"
    - "((1, 2), 3) creates nested tuple structure"
    - "(1, true, \"hello\") works with heterogeneous types"
    - "REPL displays tuples as (1, 2) format"
    - "Pattern arity mismatch produces clear error message"
  artifacts:
    - path: "FunLang/Eval.fs"
      provides: "Tuple evaluation, pattern matching, formatting"
      contains: "| Tuple exprs ->"
    - path: "tests/tuples/01-tuple-basic.flt"
      provides: "Basic tuple test"
    - path: "tests/tuples/04-pattern-simple.flt"
      provides: "Pattern matching test"
  key_links:
    - from: "FunLang/Eval.fs"
      to: "FunLang/Ast.fs"
      via: "TupleValue, Pattern types"
      pattern: "TupleValue"
    - from: "FunLang/Eval.fs"
      to: "matchPattern function"
      via: "LetPat evaluation"
      pattern: "matchPattern.*pat.*value"
---

<objective>
Implement tuple evaluation, pattern matching, and integration tests.

Purpose: Complete Phase 1 tuple support by adding runtime behavior - tuple evaluation, pattern destructuring, and output formatting. Verify with comprehensive tests.

Output: Modified Eval.fs with working tuple support, new tests/tuples/ directory with integration tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-tuples/01-RESEARCH.md
@.planning/phases/01-tuples/01-01-SUMMARY.md
@FunLang/Ast.fs
@FunLang/Eval.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tuple evaluation and pattern matching in Eval.fs</name>
  <files>FunLang/Eval.fs</files>
  <action>
Extend Eval.fs with tuple support. Follow the patterns from RESEARCH.md.

1. **Update formatValue function** to handle TupleValue:
   Add case after existing matches:
   ```fsharp
   | TupleValue values ->
       let formattedElements = List.map formatValue values
       sprintf "(%s)" (String.concat ", " formattedElements)
   ```

2. **Add pattern matching helper function** (before `eval` function):
   ```fsharp
   /// Match a pattern against a value, returning bindings if successful
   let rec matchPattern (pat: Pattern) (value: Value) : (string * Value) list option =
       match pat, value with
       | VarPat name, v -> Some [(name, v)]
       | WildcardPat, _ -> Some []
       | TuplePat pats, TupleValue vals ->
           if List.length pats <> List.length vals then
               None  // Arity mismatch
           else
               let bindings = List.map2 matchPattern pats vals
               if List.forall Option.isSome bindings then
                   Some (List.collect Option.get bindings)
               else
                   None
       | _ -> None  // Type mismatch (e.g., TuplePat vs IntValue)
   ```

3. **Add Tuple evaluation case** to `eval` function (with other expression cases):
   ```fsharp
   | Tuple exprs ->
       let values = List.map (eval env) exprs
       TupleValue values
   ```

4. **Add LetPat evaluation case** to `eval` function (near existing Let case):
   ```fsharp
   | LetPat (pat, bindingExpr, bodyExpr) ->
       let value = eval env bindingExpr
       match matchPattern pat value with
       | Some bindings ->
           let extendedEnv = List.fold (fun e (n, v) -> Map.add n v e) env bindings
           eval extendedEnv bodyExpr
       | None ->
           match pat, value with
           | TuplePat pats, TupleValue vals ->
               failwithf "Pattern match failed: tuple pattern expects %d elements but value has %d"
                         (List.length pats) (List.length vals)
           | TuplePat _, _ ->
               failwith "Pattern match failed: expected tuple value"
           | _ ->
               failwith "Pattern match failed"
   ```

5. **Update Equal/NotEqual** to support tuple comparison (structural equality):
   In the `Equal` case, add:
   ```fsharp
   | TupleValue l, TupleValue r -> BoolValue (l = r)
   ```
   Same for `NotEqual`:
   ```fsharp
   | TupleValue l, TupleValue r -> BoolValue (l <> r)
   ```

   Note: F# structural equality `=` on `Value list` handles nested tuples correctly.
  </action>
  <verify>
1. `dotnet build FunLang/FunLang.fsproj` - should compile without warnings
2. Quick smoke test:
   ```bash
   echo '(1, 2)' | dotnet run --project FunLang -- -
   ```
   Expected: `(1, 2)`
3. Pattern test:
   ```bash
   echo 'let (x, y) = (1, 2) in x + y' | dotnet run --project FunLang -- -
   ```
   Expected: `3`
  </verify>
  <done>
Eval.fs contains: formatValue for TupleValue, matchPattern function, Tuple evaluation, LetPat evaluation with arity error messages, tuple equality comparison. All compile without warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tuple integration tests</name>
  <files>
    tests/tuples/01-tuple-basic.flt
    tests/tuples/02-tuple-nested.flt
    tests/tuples/03-tuple-heterogeneous.flt
    tests/tuples/04-pattern-simple.flt
    tests/tuples/05-pattern-nested.flt
    tests/tuples/06-pattern-wildcard.flt
    tests/tuples/07-pattern-arity-error.flt
    tests/tuples/08-tuple-equality.flt
    tests/Makefile
  </files>
  <action>
Create tests/tuples/ directory and integration tests.

1. **Create directory:** `mkdir -p tests/tuples`

2. **Create test files** following the fslit format (see existing tests for pattern):

**tests/tuples/01-tuple-basic.flt:**
```
// Test: Basic tuple literal (TUP-01)
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
(1, 2)
// --- Output:
(1, 2)
```

**tests/tuples/02-tuple-nested.flt:**
```
// Test: Nested tuple (TUP-03)
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
((1, 2), 3)
// --- Output:
((1, 2), 3)
```

**tests/tuples/03-tuple-heterogeneous.flt:**
```
// Test: Heterogeneous tuple (TUP-04)
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
(1, true, "hello")
// --- Output:
(1, true, "hello")
```

**tests/tuples/04-pattern-simple.flt:**
```
// Test: Simple tuple pattern matching (TUP-02)
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
let (x, y) = (1, 2) in x + y
// --- Output:
3
```

**tests/tuples/05-pattern-nested.flt:**
```
// Test: Nested tuple pattern matching (TUP-03)
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
let ((a, b), c) = ((1, 2), 3) in a + b + c
// --- Output:
6
```

**tests/tuples/06-pattern-wildcard.flt:**
```
// Test: Wildcard pattern in tuple (TUP-02)
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
let (x, _) = (42, 99) in x
// --- Output:
42
```

**tests/tuples/07-pattern-arity-error.flt:**
```
// Test: Pattern arity mismatch error
// --- Command: dotnet run --project FunLang -- %input
// --- Exit: 1
// --- Input:
let (x, y, z) = (1, 2) in x
// --- Error:
Pattern match failed: tuple pattern expects 3 elements but value has 2
```

**tests/tuples/08-tuple-equality.flt:**
```
// Test: Tuple structural equality
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
(1, 2) = (1, 2)
// --- Output:
true
```

**tests/tuples/09-tuple-inequality.flt:**
```
// Test: Tuple inequality
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
(1, 2) <> (1, 3)
// --- Output:
true
```

**tests/tuples/10-tuple-in-expr.flt:**
```
// Test: Tuple with expressions
// --- Command: dotnet run --project FunLang -- %input
// --- Input:
(1 + 2, 3 * 4)
// --- Output:
(3, 12)
```

3. **Update tests/Makefile** - add tuples target:
   Add to `.PHONY` line: `tuples`
   Add after existing targets:
   ```makefile
   tuples:
   	@cd .. && fslit tests/tuples/
   ```
  </action>
  <verify>
1. Run all tests:
   ```bash
   make -C tests
   ```
   All tests should pass (existing 66 + new 10 = 76 total)

2. Run tuple tests specifically:
   ```bash
   make -C tests tuples
   ```
   All 10 tuple tests should pass.
  </verify>
  <done>
tests/tuples/ directory contains 10 test files covering: basic tuples, nested tuples, heterogeneous types, pattern matching, wildcard patterns, arity errors, equality. tests/Makefile updated with tuples target. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify REPL output</name>
  <files>None (verification only)</files>
  <action>
Final verification of all success criteria from ROADMAP.md:

1. Run full test suite (fslit + Expecto):
   ```bash
   make -C tests
   dotnet run --project FunLang.Tests
   ```

2. Verify REPL tuple output:
   ```bash
   echo -e "(1, 2)\n:quit" | dotnet run --project FunLang
   ```
   Should display `(1, 2)` in REPL format.

3. Test edge cases manually:
   - Empty expression in tuple: `(1, )` should be syntax error
   - Single element: `(1)` should be grouped expression, NOT tuple
   - Deeply nested: `(((1, 2), 3), 4)` should work

4. Check Expecto tests still pass (they test internal functions):
   ```bash
   dotnet run --project FunLang.Tests
   ```
   All 129 tests should pass.

If any issues found, fix them before marking complete.
  </action>
  <verify>
All verification commands pass:
- `make -C tests` - 76 fslit tests pass
- `dotnet run --project FunLang.Tests` - 129 Expecto tests pass
- REPL correctly displays tuple output
  </verify>
  <done>
All 76 fslit tests pass. All 129 Expecto tests pass. REPL displays tuples correctly. Phase 1 success criteria from ROADMAP.md are met.
  </done>
</task>

</tasks>

<verification>
Phase 1 Success Criteria from ROADMAP.md:

1. **`(1, 2)` expression returns TupleValue:**
   ```bash
   echo '(1, 2)' | dotnet run --project FunLang -- -
   # Output: (1, 2)
   ```

2. **`let (x, y) = (1, 2) in x + y` returns 3:**
   ```bash
   echo 'let (x, y) = (1, 2) in x + y' | dotnet run --project FunLang -- -
   # Output: 3
   ```

3. **`let ((a, b), c) = ((1, 2), 3) in a + b + c` returns 6:**
   ```bash
   echo 'let ((a, b), c) = ((1, 2), 3) in a + b + c' | dotnet run --project FunLang -- -
   # Output: 6
   ```

4. **Heterogeneous tuple `(1, true, "hello")` works:**
   ```bash
   echo '(1, true, "hello")' | dotnet run --project FunLang -- -
   # Output: (1, true, "hello")
   ```

5. **REPL displays tuples as `(1, 2)`:**
   ```bash
   echo -e "(1, 2)\n:quit" | dotnet run --project FunLang
   # REPL output includes: (1, 2)
   ```
</verification>

<success_criteria>
1. formatValue handles TupleValue with correct `(1, 2, 3)` format
2. matchPattern function recursively matches tuple patterns
3. Tuple expressions evaluate to TupleValue
4. LetPat binds pattern variables in environment
5. Arity mismatch produces clear error message
6. Tuple equality uses structural comparison
7. All 76 fslit tests pass (66 existing + 10 new)
8. All 129 Expecto tests pass
9. REPL correctly displays tuple values
</success_criteria>

<output>
After completion, create `.planning/phases/01-tuples/01-02-SUMMARY.md`
</output>
