---
phase: 07-cli-options-file-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Format.fs
  - FunLang/Program.fs
  - FunLang/FunLang.fsproj
autonomous: true

must_haves:
  truths:
    - "User can run funlang --expr '2 + 3' and see 5"
    - "User can run funlang program.fun and see result from file"
    - "User can run funlang --emit-tokens --expr '2 + 3' and see token list"
    - "User can run funlang --emit-ast --expr '2 + 3' and see AST"
    - "User can run funlang --emit-type and see reserved message"
  artifacts:
    - path: "FunLang/Format.fs"
      provides: "Token/AST formatting and lex helper"
      exports: ["formatToken", "formatTokens", "lex"]
    - path: "FunLang/Program.fs"
      provides: "CLI argument handling"
      contains: "match argv with"
  key_links:
    - from: "FunLang/Program.fs"
      to: "FunLang/Format.fs"
      via: "open Format"
      pattern: "formatTokens|lex"
    - from: "FunLang/Format.fs"
      to: "FunLang/Lexer.fs"
      via: "Lexer.tokenize"
      pattern: "Lexer\\.tokenize"
---

<objective>
Add emit options (--emit-tokens, --emit-ast, --emit-type) and file input support to FunLang CLI.

Purpose: Enable users to inspect intermediate representations (tokens, AST) for debugging and learning, and run programs from files instead of just --expr.
Output: Updated Program.fs with full CLI support, Format.fs with token/AST formatters.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-cli-options-file-tests/07-RESEARCH.md
@FunLang/Program.fs
@FunLang/Ast.fs
@FunLang/Lexer.fsl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Format.fs with Token Formatter and Lex Helper</name>
  <files>FunLang/Format.fs, FunLang/FunLang.fsproj</files>
  <action>
Create `FunLang/Format.fs` with:

1. `formatToken` function - Pattern match on Parser token types:
   - `NUMBER n` -> `sprintf "NUMBER(%d)" n`
   - `PLUS` -> `"PLUS"`
   - `MINUS` -> `"MINUS"`
   - `STAR` -> `"STAR"`
   - `SLASH` -> `"SLASH"`
   - `LPAREN` -> `"LPAREN"`
   - `RPAREN` -> `"RPAREN"`
   - `EOF` -> `"EOF"`

2. `formatTokens` function - Map formatToken over list, join with space:
   ```fsharp
   let formatTokens tokens =
       tokens |> List.map formatToken |> String.concat " "
   ```

3. `lex` function - Tokenize input string into token list:
   ```fsharp
   let lex (input: string) : Parser.token list =
       let lexbuf = LexBuffer<char>.FromString input
       let rec loop acc =
           let token = Lexer.tokenize lexbuf
           match token with
           | Parser.EOF -> List.rev (Parser.EOF :: acc)
           | t -> loop (t :: acc)
       loop []
   ```

Update `FunLang.fsproj` to add `Format.fs` AFTER `Parser.fs` and `Lexer.fs` but BEFORE `Eval.fs`:
```xml
<Compile Include="Format.fs" />
```

The module should:
- `open FSharp.Text.Lexing` for LexBuffer
- Reference Parser tokens directly (they're generated)
  </action>
  <verify>
Run `dotnet build FunLang/FunLang.fsproj` - should compile without errors.
  </verify>
  <done>
Format.fs exists with formatToken, formatTokens, and lex functions. Project compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Expand Program.fs with Full CLI Options</name>
  <files>FunLang/Program.fs</files>
  <action>
Rewrite the `main` function in Program.fs to handle all CLI patterns using array pattern matching. Follow the order from most specific to least specific (per RESEARCH.md pitfall #1).

Pattern order (CRITICAL - most specific first):
1. `--emit-tokens --expr <expr>` - Tokenize expression, format output
2. `--emit-ast --expr <expr>` - Parse expression, print AST with %A
3. `--emit-type --expr <expr>` - Reserved, print error message
4. `--emit-tokens <filename>` with File.Exists guard - Tokenize file contents
5. `--emit-ast <filename>` with File.Exists guard - Parse file, print AST
6. `--emit-type <filename>` with File.Exists guard - Reserved error
7. `--expr <expr>` - Existing behavior (parse + eval, print result)
8. `<filename>` with File.Exists guard - Read file, parse + eval
9. `<filename>` without guard - File not found error
10. `--help` or `-h` - Show usage
11. `_` wildcard - Usage error

Implementation details:
- `open System.IO` for File.ReadAllText and File.Exists
- `open Format` for formatTokens and lex functions
- For `--emit-ast`: use `printfn "%A" ast` (F#'s built-in formatter)
- For `--emit-type`: `eprintfn "Error: Type checking not yet implemented. Reserved for future phase."` and return 1
- For file reading: `File.ReadAllText filename`
- Update help text to show all options

Error handling:
- Wrap eval calls in try/with for runtime errors
- File not found: `eprintfn "File not found: %s" filename`
- Use exit code 0 for success, 1 for errors
  </action>
  <verify>
Run these commands and verify outputs:
```bash
cd FunLang && dotnet build
dotnet run --project FunLang -- --expr "2 + 3"  # Should print: 5
dotnet run --project FunLang -- --emit-tokens --expr "2 + 3"  # Should print: NUMBER(2) PLUS NUMBER(3) EOF
dotnet run --project FunLang -- --emit-ast --expr "2 + 3"  # Should print: Add (Number 2, Number 3)
dotnet run --project FunLang -- --emit-type --expr "2 + 3"  # Should print error about reserved
echo "2 + 3 * 4" > /tmp/test.fun && dotnet run --project FunLang -- /tmp/test.fun  # Should print: 14
dotnet run --project FunLang -- --emit-ast /tmp/test.fun  # Should print AST
dotnet run --project FunLang -- nonexistent.fun  # Should print file not found error
```
  </verify>
  <done>
All CLI patterns work:
- `funlang --expr "2 + 3"` prints `5`
- `funlang program.fun` executes file and prints result
- `funlang --emit-tokens --expr "..."` prints token list
- `funlang --emit-ast --expr "..."` prints AST
- `funlang --emit-type ...` prints reserved message
- File not found shows clear error
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build FunLang/FunLang.fsproj`
2. Existing behavior preserved: `dotnet run --project FunLang -- --expr "2 + 3"` -> `5`
3. File input works: Create test.fun with `(2 + 3) * 4`, run `dotnet run --project FunLang -- test.fun` -> `20`
4. Token emit: `dotnet run --project FunLang -- --emit-tokens --expr "2 + 3"` -> `NUMBER(2) PLUS NUMBER(3) EOF`
5. AST emit: `dotnet run --project FunLang -- --emit-ast --expr "2 + 3"` shows AST structure
6. Type emit reserved: `dotnet run --project FunLang -- --emit-type --expr "x"` -> error message about reserved
</verification>

<success_criteria>
- CLI-01: Input via --expr and filename both work
- CLI-02: --emit-tokens outputs formatted token list
- CLI-03: --emit-ast outputs AST using %A formatter
- CLI-04: --emit-type returns reserved error message
- All existing Phase 2 tests still pass (if any)
</success_criteria>

<output>
After completion, create `.planning/phases/07-cli-options-file-tests/07-01-SUMMARY.md`
</output>
