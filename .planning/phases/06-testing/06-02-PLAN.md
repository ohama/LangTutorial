---
phase: 06-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang.Tests/InferTests.fs
  - FunLang.Tests/TypeCheckTests.fs
  - FunLang.Tests/Program.fs
  - FunLang.Tests/FunLang.Tests.fsproj
autonomous: true

must_haves:
  truths:
    - "Infer module correctly infers types for all expression types"
    - "Let-polymorphism works (same function used at different types)"
    - "Lambda parameters are monomorphic"
    - "TypeCheck integration tests verify end-to-end type checking"
    - "Prelude functions have correct polymorphic types"
  artifacts:
    - path: "FunLang.Tests/InferTests.fs"
      provides: "Infer module unit tests (freshVar, instantiate, generalize, infer)"
      exports: ["inferTests"]
    - path: "FunLang.Tests/TypeCheckTests.fs"
      provides: "TypeCheck integration tests (typecheck, initialTypeEnv)"
      exports: ["typeCheckTests"]
  key_links:
    - from: "FunLang.Tests/InferTests.fs"
      to: "FunLang/Infer.fs"
      via: "open Infer"
      pattern: "open Infer"
    - from: "FunLang.Tests/TypeCheckTests.fs"
      to: "FunLang/TypeCheck.fs"
      via: "open TypeCheck"
      pattern: "open TypeCheck"
    - from: "FunLang.Tests/Program.fs"
      to: "FunLang.Tests/InferTests.fs"
      via: "test list registration"
      pattern: "InferTests\\.inferTests"
---

<objective>
Create comprehensive Expecto unit tests for Infer.fs and TypeCheck.fs modules (TEST-04, TEST-05).

Purpose: Verify Algorithm W correctly infers types for all expression types and TypeCheck integration works end-to-end with Prelude.

Output: InferTests.fs and TypeCheckTests.fs with ~50 tests covering inference for all AST nodes and integration with Prelude.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-testing/06-RESEARCH.md
@FunLang/Infer.fs
@FunLang/TypeCheck.fs
@FunLang.Tests/Program.fs
@TESTING.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InferTests.fs for Infer module</name>
  <files>FunLang.Tests/InferTests.fs</files>
  <action>
Create FunLang.Tests/InferTests.fs with comprehensive tests for Infer.fs module:

**Module structure:**
```fsharp
module InferTests

open Expecto
open Type
open Infer
open Ast
open FSharp.Text.Lexing

let parse (input: string) : Expr =
    let lexbuf = LexBuffer<char>.FromString input
    Parser.start Lexer.tokenize lexbuf

/// Infer type in empty environment (for pure inference tests)
let inferEmpty expr =
    let s, ty = infer Map.empty expr
    apply s ty

/// Infer type with TypeCheck.initialTypeEnv (for Prelude-aware tests)
let inferWithPrelude expr =
    let s, ty = infer TypeCheck.initialTypeEnv expr
    apply s ty

[<Tests>]
let inferTests = testList "Type Inference" [...]
```

**Test groups to include:**

1. **Core functions tests** (~5 tests):
   - freshVar generates unique variables: freshVar() <> freshVar()
   - instantiate with empty vars: instantiate (Scheme([], TInt)) = TInt
   - instantiate creates fresh vars: instantiate (Scheme([0], TVar 0)) gives fresh TVar
   - generalize with empty env: generalize Map.empty (TVar 1000) gives Scheme([1000], TVar 1000)
   - generalize excludes env vars: generalize with env containing scheme still generalizes free vars

2. **Literal inference tests (INFER-04)** (~4 tests):
   - Number: inferEmpty (Number 42) = TInt
   - Bool true: inferEmpty (Bool true) = TBool
   - Bool false: inferEmpty (Bool false) = TBool
   - String: inferEmpty (String "hello") = TString

3. **Variable inference tests (INFER-06)** (~3 tests):
   - Variable lookup: infer with env [(x, Scheme([], TInt))] (Var "x") = TInt
   - Polymorphic instantiation: infer with env [(id, Scheme([0], TArrow(TVar 0, TVar 0)))] (Var "id") gives fresh arrow
   - Unbound variable: infer Map.empty (Var "x") raises TypeError "Unbound variable: x"

4. **Arithmetic operator inference (INFER-05)** (~6 tests):
   - Add: int -> int -> int
   - Subtract: int -> int -> int
   - Multiply: int -> int -> int
   - Divide: int -> int -> int
   - Negate: int -> int
   - Type error: Add(Bool true, Number 1) raises TypeError

5. **Comparison operator inference (INFER-05)** (~4 tests):
   - LessThan: int -> int -> bool
   - Equal: int -> int -> bool
   - Type error: LessThan(Bool true, Number 1) raises TypeError

6. **Logical operator inference (INFER-05)** (~3 tests):
   - And: bool -> bool -> bool
   - Or: bool -> bool -> bool
   - Type error: And(Number 1, Bool true) raises TypeError

7. **Lambda inference (INFER-08)** (~5 tests):
   - Identity: parse "fun x -> x" gives 'a -> 'a pattern
   - Constant function: parse "fun x -> 42" gives 'a -> int
   - Using parameter: parse "fun x -> x + 1" gives int -> int
   - Nested lambda: parse "fun x -> fun y -> x + y" gives int -> int -> int

8. **Application inference (INFER-08)** (~4 tests):
   - Simple app: parse "let f = fun x -> x + 1 in f 5" = TInt
   - Curried app: parse "let add = fun x -> fun y -> x + y in add 3 4" = TInt
   - Type error: applying non-function raises TypeError

9. **Let-polymorphism (INFER-07)** (~5 tests):
   - Classic test: parse "let id = fun x -> x in (id 5, id true)" gives TTuple [TInt; TBool]
   - Polymorphic used once: parse "let id = fun x -> x in id 5" = TInt
   - Nested let: parse "let x = 5 in let y = x + 1 in y" = TInt

10. **LetRec inference (INFER-09)** (~4 tests):
    - Simple rec: parse "let rec f x = x in f 42" = TInt
    - Factorial type: parse "let rec fact n = if n <= 1 then 1 else n * fact (n-1) in fact" = int -> int
    - Recursive polymorphism is limited (monomorphic recursion)

11. **If inference (INFER-10)** (~4 tests):
    - parse "if true then 1 else 2" = TInt
    - parse "if true then true else false" = TBool
    - Branch type mismatch: parse "if true then 1 else true" raises TypeError
    - Condition must be bool: parse "if 1 then 2 else 3" raises TypeError

12. **Tuple inference (INFER-11)** (~3 tests):
    - parse "(1, true)" = TTuple [TInt; TBool]
    - parse "(1, 2, 3)" = TTuple [TInt; TInt; TInt]
    - Nested: parse "((1, 2), true)" = TTuple [TTuple [TInt; TInt]; TBool]

13. **List inference (INFER-12)** (~5 tests):
    - EmptyList: parse "[]" gives TList (fresh var)
    - List literal: parse "[1, 2, 3]" = TList TInt
    - Cons: parse "1 :: []" = TList TInt
    - Mixed list error: parse "[1, true]" raises TypeError
    - Cons type error: parse "1 :: 2" raises TypeError (tail not list)

14. **Match inference (INFER-13)** (~4 tests):
    - Simple match: infer correct pattern and result types
    - Branch type unification: all branches same result type
    - Pattern binding types correct

15. **Lambda parameter monomorphism** (~2 tests):
    - parse "fun f -> (f 1, f true)" raises TypeError (f cannot be both int->a and bool->a)
  </action>
  <verify>
```bash
dotnet run --project FunLang.Tests -- --filter "Type Inference"
```
All Type Inference tests pass.
  </verify>
  <done>InferTests.fs exists with ~60 tests covering all expression types and edge cases</done>
</task>

<task type="auto">
  <name>Task 2: Create TypeCheckTests.fs for TypeCheck integration</name>
  <files>FunLang.Tests/TypeCheckTests.fs</files>
  <action>
Create FunLang.Tests/TypeCheckTests.fs with integration tests for TypeCheck.fs:

**Module structure:**
```fsharp
module TypeCheckTests

open Expecto
open Type
open TypeCheck
open Ast
open FSharp.Text.Lexing

let parse (input: string) : Expr =
    let lexbuf = LexBuffer<char>.FromString input
    Parser.start Lexer.tokenize lexbuf

let check input =
    let expr = parse input
    typecheck expr

[<Tests>]
let typeCheckTests = testList "TypeCheck Integration" [...]
```

**Test groups to include:**

1. **Prelude function types (TEST-05)** (~11 tests - one per Prelude function):
   - map: check "map" gives Ok with ('a -> 'b) -> 'a list -> 'b list pattern
   - filter: check "filter" gives Ok with ('a -> bool) -> 'a list -> 'a list pattern
   - fold: check "fold" gives Ok with ('b -> 'a -> 'b) -> 'b -> 'a list -> 'b pattern
   - length: check "length" gives Ok with 'a list -> int pattern
   - reverse: check "reverse" gives Ok with 'a list -> 'a list pattern
   - append: check "append" gives Ok with 'a list -> 'a list -> 'a list pattern
   - id: check "id" gives Ok with 'a -> 'a pattern
   - const: check "const" gives Ok with 'a -> 'b -> 'a pattern
   - compose: check "compose" gives Ok with ('b -> 'c) -> ('a -> 'b) -> 'a -> 'c pattern
   - hd: check "hd" gives Ok with 'a list -> 'a pattern
   - tl: check "tl" gives Ok with 'a list -> 'a list pattern

2. **Prelude usage tests** (~8 tests):
   - map with concrete types: check "map (fun x -> x + 1) [1, 2, 3]" = Ok (TList TInt)
   - filter with predicate: check "filter (fun x -> x > 0) [1, -2, 3]" = Ok (TList TInt)
   - length with list: check "length [1, 2, 3]" = Ok TInt
   - id application: check "id 42" = Ok TInt
   - compose functions: check "compose (fun x -> x + 1) (fun x -> x * 2) 5" = Ok TInt
   - Prelude polymorphism: check "let f = id in (f 1, f true)" = Ok (TTuple [TInt; TBool])

3. **typecheck returns Ok** (~5 tests):
   - Simple expression: check "1 + 2" = Ok TInt
   - Let binding: check "let x = 5 in x" = Ok TInt
   - Function: check "fun x -> x" gives Ok (arrow type)
   - Complex: check "let rec fact n = if n <= 1 then 1 else n * fact (n-1) in fact 5" = Ok TInt

4. **typecheck returns Error** (~5 tests):
   - Unbound variable: check "x" = Error "Unbound variable: x"
   - Type mismatch: check "1 + true" = Error containing "Cannot unify"
   - Infinite type: check "let rec f x = f in f" = Error containing "Infinite type"
   - If branch mismatch: check "if true then 1 else false" = Error containing "Cannot unify"
  </action>
  <verify>
```bash
dotnet run --project FunLang.Tests -- --filter "TypeCheck Integration"
```
All TypeCheck Integration tests pass.
  </verify>
  <done>TypeCheckTests.fs exists with ~30 tests covering Prelude types and typecheck function</done>
</task>

<task type="auto">
  <name>Task 3: Update Program.fs and fsproj to include Infer and TypeCheck tests</name>
  <files>FunLang.Tests/Program.fs, FunLang.Tests/FunLang.Tests.fsproj</files>
  <action>
1. Update FunLang.Tests/FunLang.Tests.fsproj to include new test files.

   Order should be (after TypeTests.fs and UnifyTests.fs if Plan 01 ran first, or just add in order):
   ```xml
   <Compile Include="ReplTests.fs" />
   <Compile Include="TypeTests.fs" />
   <Compile Include="UnifyTests.fs" />
   <Compile Include="InferTests.fs" />
   <Compile Include="TypeCheckTests.fs" />
   <Compile Include="Program.fs" />
   ```

   Note: If Plan 01 hasn't run yet, just add InferTests.fs and TypeCheckTests.fs. The fsproj may not have TypeTests.fs/UnifyTests.fs yet - that's fine, just add what this plan creates.

2. Update FunLang.Tests/Program.fs main function to include new test lists:
   ```fsharp
   runTestsWithCLIArgs [] argv <| testList "FunLang Tests" [
       ReplTests.replEvalTests
       ReplTests.cliTests
       TypeTests.typeTests          // From Plan 01 (may not exist yet)
       UnifyTests.unifyTests        // From Plan 01 (may not exist yet)
       InferTests.inferTests        // Add
       TypeCheckTests.typeCheckTests // Add
       commentTests
       stringTests
       ...
   ]
   ```

   If Plan 01 hasn't run, just add the InferTests and TypeCheckTests entries. Program.fs will fail to compile if TypeTests/UnifyTests don't exist, so conditionally add them or let Plan 01 add them.

   **Safer approach:** Only add InferTests and TypeCheckTests in this task. Let Plan 01 add TypeTests and UnifyTests.
  </action>
  <verify>
```bash
dotnet run --project FunLang.Tests
```
All tests pass (existing + new Infer and TypeCheck tests).
  </verify>
  <done>Program.fs registers InferTests and TypeCheckTests, fsproj includes new files, all tests pass</done>
</task>

</tasks>

<verification>
```bash
# Run all tests
dotnet run --project FunLang.Tests

# Run Infer tests specifically
dotnet run --project FunLang.Tests -- --filter "Type Inference"

# Run TypeCheck tests specifically
dotnet run --project FunLang.Tests -- --filter "TypeCheck Integration"
```

Expected: All tests pass, no regressions in existing tests.
</verification>

<success_criteria>
1. InferTests.fs exists with ~60 tests for Infer module
2. TypeCheckTests.fs exists with ~30 tests for TypeCheck module
3. FunLang.Tests.fsproj includes both new files
4. Program.fs registers both test modules
5. All tests pass: `dotnet run --project FunLang.Tests`
6. TEST-04 (Infer tests) and TEST-05 (TypeCheck tests) requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing/06-02-SUMMARY.md`
</output>
