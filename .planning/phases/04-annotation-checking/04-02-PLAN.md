---
phase: 04-annotation-checking
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/type-errors/13-annot-mismatch.flt
  - tests/type-errors/14-annot-mismatch-lambda.flt
  - tests/type-errors/15-lambda-annot-wrong-body.flt
  - FunLang.Tests/BidirTests.fs
autonomous: true

must_haves:
  truths:
    - "Invalid annotations produce type errors"
    - "Error messages include type mismatch information"
    - "LambdaAnnot with wrong body type produces error"
    - "Tests demonstrate ANNOT-04 requirement (clear error messages)"
  artifacts:
    - path: "tests/type-errors/13-annot-mismatch.flt"
      provides: "fslit test for (true : int) error"
    - path: "tests/type-errors/14-annot-mismatch-lambda.flt"
      provides: "fslit test for lambda annotation mismatch"
    - path: "tests/type-errors/15-lambda-annot-wrong-body.flt"
      provides: "fslit test for LambdaAnnot body type error"
    - path: "FunLang.Tests/BidirTests.fs"
      provides: "Expecto unit tests for annotation errors"
      contains: "annotationErrorTests"
  key_links:
    - from: "tests/type-errors/*.flt"
      to: "dotnet run --project FunLang -- --emit-type"
      via: "fslit CLI integration with error output"
      pattern: "ExitCode: 1"
    - from: "FunLang.Tests/BidirTests.fs"
      to: "Bidir.synthTop"
      via: "Exception catching in tests"
      pattern: "Expect.throws"
---

<objective>
Test invalid type annotations produce appropriate error messages.

Purpose: Verify ANNOT-04 requirement (wrong annotations produce clear error messages). Create comprehensive test coverage for invalid annotation scenarios to ensure the implementation catches type mismatches and reports them correctly.

Output: fslit CLI error tests and Expecto unit tests demonstrating correct error handling for invalid annotations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-annotation-checking/04-RESEARCH.md

@FunLang/Bidir.fs
@FunLang/Diagnostic.fs
@tests/type-errors/03-type-mismatch.flt
@FunLang.Tests/BidirTests.fs
@TESTING.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fslit tests for invalid Annot expressions</name>
  <files>
    tests/type-errors/13-annot-mismatch.flt
    tests/type-errors/14-annot-mismatch-lambda.flt
  </files>
  <action>
Create fslit test files for invalid annotation errors following existing pattern in tests/type-errors/:

**13-annot-mismatch.flt** - Annotating bool as int:
```flt
// Type annotation mismatch: bool annotated as int
// --- Command: dotnet run --project FunLang -- --emit-type --expr "(true : int)" 2>&1
// --- ExitCode: 1
// --- Output:
error[E0301]: Type mismatch: expected int but got bool
 --> <expr>:1:2-5
   = hint: Check that all branches of your expression return the same type
```

**14-annot-mismatch-lambda.flt** - Annotating lambda with wrong type:
```flt
// Type annotation mismatch: lambda annotated with incompatible type
// --- Command: dotnet run --project FunLang -- --emit-type --expr "(fun x -> x + 1 : bool -> bool)" 2>&1
// --- ExitCode: 1
// --- Output:
error[E0301]: Type mismatch: expected bool but got int
 --> <expr>:1:11-15
   = hint: Check that all branches of your expression return the same type
```

Note: Use `--expr` for error tests since the error span references `<expr>`. Match exact error format from existing tests.

IMPORTANT: Run the actual commands first to get the exact error output, then adjust the test file to match. The span positions may vary based on parser behavior.
  </action>
  <verify>
Run `make -C tests type-errors` and confirm both new tests pass.
  </verify>
  <done>
13-annot-mismatch.flt, 14-annot-mismatch-lambda.flt exist and pass fslit tests with correct error output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create fslit test for invalid LambdaAnnot body type</name>
  <files>tests/type-errors/15-lambda-annot-wrong-body.flt</files>
  <action>
Create fslit test file for LambdaAnnot with wrong body type:

**15-lambda-annot-wrong-body.flt** - Annotated lambda with type error in body:
```flt
// LambdaAnnot with type error in body (int parameter used with bool operator)
// --- Command: dotnet run --project FunLang -- --emit-type --expr "fun (x: int) -> x && true" 2>&1
// --- ExitCode: 1
// --- Output:
error[E0301]: Type mismatch: expected bool but got int
 --> <expr>:1:17-17
   = hint: Check that all branches of your expression return the same type
```

IMPORTANT: Run the actual command first to get exact error output:
```bash
dotnet run --project FunLang -- --emit-type --expr "fun (x: int) -> x && true" 2>&1
```

Then adjust the test file to match the actual output (spans may differ).

This tests that:
1. Parameter type from annotation is used in body type checking
2. Type error in body is correctly reported
3. Error message shows the mismatch (bool expected, int given)
  </action>
  <verify>
Run `make -C tests type-errors` and confirm all 15 tests pass (12 existing + 3 new).
  </verify>
  <done>
15-lambda-annot-wrong-body.flt exists and passes fslit test with correct error output.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Expecto unit tests for annotation errors</name>
  <files>FunLang.Tests/BidirTests.fs</files>
  <action>
Add a new test group `annotationErrorTests` to BidirTests.fs for ANNOT-04:

```fsharp
[<Tests>]
let annotationErrorTests =
    testList "Annotation errors (ANNOT-04)" [
        // ANNOT-04: Wrong annotations produce clear errors
        test "Annot: (true : int) raises type error" {
            Expect.throws (fun () -> synthEmpty "(true : int)" |> ignore)
                          "bool cannot be annotated as int"
        }

        test "Annot: (42 : bool) raises type error" {
            Expect.throws (fun () -> synthEmpty "(42 : bool)" |> ignore)
                          "int cannot be annotated as bool"
        }

        test "Annot: (\"hello\" : int) raises type error" {
            Expect.throws (fun () -> synthEmpty "(\"hello\" : int)" |> ignore)
                          "string cannot be annotated as int"
        }

        test "Annot: lambda annotated with wrong return type" {
            Expect.throws (fun () -> synthEmpty "(fun x -> x + 1 : int -> bool)" |> ignore)
                          "int return cannot be annotated as bool"
        }

        test "Annot: lambda annotated with wrong param type" {
            Expect.throws (fun () -> synthEmpty "(fun x -> x && true : int -> bool)" |> ignore)
                          "bool param cannot be annotated as int"
        }

        test "LambdaAnnot: body type mismatch" {
            Expect.throws (fun () -> synthEmpty "fun (x: int) -> x && true" |> ignore)
                          "int param used with bool operator"
        }

        test "LambdaAnnot: body type different from inferred" {
            // x is int, but body tries to use it as string
            Expect.throws (fun () -> synthEmpty "fun (x: int) -> x ^ \"suffix\"" |> ignore)
                          "int param used with string operator"
        }

        test "Annot: list element type mismatch" {
            Expect.throws (fun () -> synthEmpty "([1, 2, 3] : list bool)" |> ignore)
                          "int list cannot be annotated as bool list"
        }

        test "Annot: tuple element type mismatch" {
            Expect.throws (fun () -> synthEmpty "((1, true) : bool * int)" |> ignore)
                          "tuple element types swapped"
        }

        test "Annot: function vs non-function" {
            Expect.throws (fun () -> synthEmpty "(42 : int -> int)" |> ignore)
                          "int cannot be annotated as function"
        }
    ]
```

Add the new test group to the main test list in Program.fs if not auto-discovered.

Note: Tests verify that TypeException is raised. The exact error message content is Phase 5 (Error Integration) work; Phase 4 just verifies errors are thrown.
  </action>
  <verify>
Run `dotnet run --project FunLang.Tests -- --filter "error"` and confirm all annotation error tests pass (verify exceptions are thrown).
Then run full suite: `dotnet run --project FunLang.Tests` - all tests should pass.
  </verify>
  <done>
BidirTests.fs contains annotationErrorTests group with 10 tests for ANNOT-04, all passing (verifying exceptions are thrown for invalid annotations).
  </done>
</task>

</tasks>

<verification>
1. `make -C tests type-errors` - all 15 tests pass (12 existing + 3 new)
2. `dotnet run --project FunLang.Tests -- --filter "error"` - annotation error tests pass
3. `dotnet run --project FunLang.Tests` - full suite passes (no regressions)
4. `make -C tests && dotnet run --project FunLang.Tests` - complete validation
</verification>

<success_criteria>
- 3 new fslit tests in tests/type-errors/ for invalid annotations
- 10 new Expecto tests in BidirTests.fs annotationErrorTests group
- All tests demonstrate ANNOT-04 requirement (error messages for wrong annotations)
- No regressions in existing test suite
- Error messages show type mismatch (expected X got Y)
- Tests cover: literal mismatch, lambda mismatch, list/tuple mismatch, function vs non-function
</success_criteria>

<output>
After completion, create `.planning/phases/04-annotation-checking/04-02-SUMMARY.md`
</output>
