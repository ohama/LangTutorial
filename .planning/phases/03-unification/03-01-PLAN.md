---
phase: 03-unification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Unify.fs
  - FunLang/FunLang.fsproj
autonomous: true

must_haves:
  truths:
    - "occurs check detects infinite types ('a = 'a -> int raises TypeError)"
    - "unify returns empty substitution for identical primitive types"
    - "unify binds type variables to concrete types via singleton"
    - "unify handles arrow types with substitution threading"
    - "unify handles tuple types with length guard"
    - "unify handles list types recursively"
    - "TypeError raised with clear messages for incompatible types"
  artifacts:
    - path: "FunLang/Unify.fs"
      provides: "Unification algorithm with occurs check"
      exports: ["TypeError", "occurs", "unify"]
      min_lines: 40
    - path: "FunLang/FunLang.fsproj"
      provides: "Build order with Unify.fs"
      contains: "Unify.fs"
  key_links:
    - from: "FunLang/Unify.fs"
      to: "FunLang/Type.fs"
      via: "open Type"
      pattern: "open Type"
    - from: "FunLang/Unify.fs"
      to: "freeVars"
      via: "occurs check implementation"
      pattern: "Set.contains.*freeVars"
    - from: "FunLang/Unify.fs"
      to: "apply, compose, singleton, empty"
      via: "substitution operations"
      pattern: "(apply|compose|singleton|empty)"
---

<objective>
Implement the unification algorithm for Hindley-Milner type inference.

Purpose: Unification is the core mechanism that finds substitutions to make two types equal, enabling type inference. This phase provides the `unify` function that Phase 4 (Inference) will use extensively.

Output: FunLang/Unify.fs module with TypeError exception, occurs check, and unify function.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-unification/03-RESEARCH.md
@.planning/phases/02-substitution/02-01-SUMMARY.md
@FunLang/Type.fs
@FunLang/FunLang.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Unify.fs with unification algorithm</name>
  <files>FunLang/Unify.fs</files>
  <action>
Create FunLang/Unify.fs implementing Robinson's unification algorithm:

1. Module declaration: `module Unify`
2. Import: `open Type`
3. Exception: `exception TypeError of string`
4. Occurs check function:
   ```fsharp
   let occurs (v: int) (t: Type): bool =
       Set.contains v (freeVars t)
   ```
5. Recursive unify function with pattern matching:
   - Primitives: TInt, TInt -> empty; TBool, TBool -> empty; TString, TString -> empty
   - TVar: Use symmetric pattern `| TVar n, t | t, TVar n ->`
     - If t = TVar n: return empty (same variable)
     - If occurs n t: raise TypeError "Infinite type: ..."
     - Else: return singleton n t
   - TArrow: Unify domains, apply s1 to ranges, unify ranges, compose s2 s1
   - TTuple: Guard with length check, fold2 with substitution threading
   - TList: Recursively unify element types
   - Default case: raise TypeError "Cannot unify ... with ..."

CRITICAL PITFALLS TO AVOID (from research):
- Use symmetric pattern `| TVar n, t | t, TVar n ->` not just `| TVar n, t ->`
- Always check occurs before singleton
- Compose order: `compose s2 s1` (newer on left)
- Apply substitution before recursive unify: `unify (apply s1 b1) (apply s1 b2)`
- TTuple needs `when List.length ts1 = List.length ts2` guard

Use formatType for error messages to show readable type notation.
  </action>
  <verify>
Run: `dotnet build FunLang`
Expected: Build succeeds with no errors.

Then verify with F# Interactive or quick test:
```fsharp
open Type
open Unify

// Test 1: Same primitives -> empty
unify TInt TInt = empty  // true

// Test 2: TVar binding
unify (TVar 0) TInt  // {0 -> TInt}

// Test 3: Occurs check
try
    unify (TVar 0) (TArrow (TVar 0, TInt)) |> ignore
    false
with TypeError msg -> msg.Contains("Infinite")  // true

// Test 4: Arrow unification
unify (TArrow (TVar 0, TVar 1)) (TArrow (TInt, TBool))
// {0 -> TInt, 1 -> TBool}

// Test 5: Type mismatch
try
    unify TInt TBool |> ignore
    false
with TypeError msg -> msg.Contains("Cannot unify")  // true
```
  </verify>
  <done>
- Unify.fs exists with module Unify, open Type
- exception TypeError of string defined
- occurs function uses freeVars and Set.contains
- unify handles all Type constructors with correct patterns
- Symmetric TVar pattern used
- Occurs check performed before singleton
- Composition order is compose s2 s1
- Substitution applied before recursive unify in TArrow/TTuple
- TTuple has length guard
- Error messages use formatType
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Unify.fs to FunLang.fsproj</name>
  <files>FunLang/FunLang.fsproj</files>
  <action>
Add Unify.fs to FunLang.fsproj in the correct build order position.

Position: After Type.fs (line ~38), before Parser.fsy (line ~41)

Add this line:
```xml
    <!-- 3. Unification module (manually written, depends on Type.fs) -->
    <Compile Include="Unify.fs" />
```

WHY THIS ORDER:
- Unify.fs opens Type module, so Type.fs must come first
- Unify.fs will be opened by Infer.fs (Phase 4), which comes later
- Parser/Lexer don't need Unify, so position before them is fine

Update the comment numbering in fsproj to reflect the new order:
- Type.fs stays as item 2
- Unify.fs becomes item 3
- Parser.fsy becomes item 4
- etc.
  </action>
  <verify>
Run: `dotnet build FunLang`
Expected: Build succeeds, confirming correct file order.

Run: `dotnet run --project FunLang -- --version`
Expected: Outputs version info (confirms runtime works).
  </verify>
  <done>
- FunLang.fsproj contains `<Compile Include="Unify.fs" />`
- Unify.fs appears after Type.fs in file order
- Unify.fs appears before Parser.fsy
- dotnet build succeeds
- dotnet run works
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Build verification:
   ```bash
   dotnet build FunLang
   ```
   Expected: Success with 0 errors.

2. Functional verification script:
   ```bash
   dotnet fsi --use:FunLang/Type.fs --use:FunLang/Unify.fs --eval:"
   open Type
   open Unify

   // Test cases
   printfn \"1. Same primitive: %b\" (unify TInt TInt = empty)
   printfn \"2. TVar binding: %A\" (unify (TVar 0) TInt)

   let occursTest =
       try unify (TVar 0) (TArrow (TVar 0, TInt)) |> ignore; false
       with TypeError msg -> msg.Contains(\"Infinite\")
   printfn \"3. Occurs check: %b\" occursTest

   printfn \"4. Arrow unify: %A\" (unify (TArrow (TVar 0, TVar 1)) (TArrow (TInt, TBool)))

   let mismatchTest =
       try unify TInt TBool |> ignore; false
       with TypeError msg -> msg.Contains(\"Cannot unify\")
   printfn \"5. Type mismatch: %b\" mismatchTest

   printfn \"6. Tuple unify: %A\" (unify (TTuple [TVar 0; TVar 1]) (TTuple [TInt; TBool]))

   printfn \"7. List unify: %A\" (unify (TList (TVar 0)) (TList TInt))

   let tupleLenTest =
       try unify (TTuple [TInt]) (TTuple [TInt; TBool]) |> ignore; false
       with TypeError _ -> true
   printfn \"8. Tuple length mismatch: %b\" tupleLenTest
   "
   ```
   Expected output:
   ```
   1. Same primitive: true
   2. TVar binding: map [(0, TInt)]
   3. Occurs check: true
   4. Arrow unify: map [(0, TInt); (1, TBool)]
   5. Type mismatch: true
   6. Tuple unify: map [(0, TInt); (1, TBool)]
   7. List unify: map [(0, TInt)]
   8. Tuple length mismatch: true
   ```

3. Runtime verification:
   ```bash
   dotnet run --project FunLang -- --version
   echo "1 + 2" | dotnet run --project FunLang
   ```
   Expected: Version output and "3" (existing functionality unbroken).
</verification>

<success_criteria>
Phase 3 Unification is complete when:
1. FunLang/Unify.fs exists with correct module structure
2. TypeError exception defined with string argument
3. occurs function detects type variable in type using freeVars
4. unify handles all Type constructors:
   - Primitives (TInt, TBool, TString) -> empty
   - TVar with symmetric pattern and occurs check
   - TArrow with substitution threading
   - TTuple with length guard and fold2
   - TList with recursive unification
5. Error messages use formatType for readability
6. FunLang.fsproj includes Unify.fs in correct position
7. dotnet build succeeds
8. All verification tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-unification/03-01-SUMMARY.md` following the summary template.
</output>
