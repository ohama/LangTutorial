---
phase: 03-bidirectional-core
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - FunLang/FunLang.fsproj
  - FunLang.Tests/BidirTests.fs
  - FunLang.Tests/FunLang.Tests.fsproj
autonomous: true

must_haves:
  truths:
    - "Bidir module compiles successfully"
    - "synthTop produces same types as Infer.infer for unannotated code"
    - "All existing tests still pass (backward compatibility)"
  artifacts:
    - path: "FunLang/FunLang.fsproj"
      provides: "Bidir.fs in build order"
      contains: "Bidir.fs"
    - path: "FunLang.Tests/BidirTests.fs"
      provides: "Unit tests for bidirectional type checker"
      min_lines: 100
  key_links:
    - from: "FunLang.Tests/BidirTests.fs"
      to: "FunLang/Bidir.fs"
      via: "open Bidir; calls to synthTop"
      pattern: "Bidir\\.synthTop"
    - from: "FunLang/FunLang.fsproj"
      to: "FunLang/Bidir.fs"
      via: "Compile Include in correct order"
      pattern: "Bidir\\.fs"
---

<objective>
Integrate Bidir.fs into the build and create comprehensive unit tests validating bidirectional type checking.

Purpose: Ensure Bidir module compiles correctly in project order and produces identical results to Algorithm W for all unannotated code.
Output: Build integration and test suite validating backward compatibility
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-bidirectional-core/03-01-SUMMARY.md

@FunLang/FunLang.fsproj
@FunLang.Tests/FunLang.Tests.fsproj
@FunLang.Tests/InferTests.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Bidir.fs to FunLang.fsproj build order</name>
  <files>FunLang/FunLang.fsproj</files>
  <action>
Add Bidir.fs to the FunLang.fsproj build order.

**Placement:** After Infer.fs and before TypeCheck.fs. Bidir.fs depends on:
- Ast.fs (expression types)
- Type.fs (type representation)
- Elaborate.fs (type expression elaboration)
- Diagnostic.fs (error types)
- Unify.fs (unification)
- Infer.fs (freshVar, instantiate, generalize, inferPattern)

**Add this line after `<Compile Include="Infer.fs" />`:**
```xml
    <!-- 5.5. Bidirectional type checker (depends on Infer.fs for helpers) -->
    <Compile Include="Bidir.fs" />
```

**Update comment numbering:**
- Current line 6: TypeCheck.fs becomes line 7 in comments
  </action>
  <verify>
```bash
# Verify Bidir.fs in fsproj
grep -n "Bidir.fs" FunLang/FunLang.fsproj

# Verify build order (Infer before Bidir before TypeCheck)
grep -E "Infer|Bidir|TypeCheck" FunLang/FunLang.fsproj | head -5

# Build project
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang/FunLang.fsproj --verbosity quiet
echo "Build exit code: $?"
```
  </verify>
  <done>
Bidir.fs added to FunLang.fsproj in correct build order (after Infer.fs, before TypeCheck.fs). Project builds successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BidirTests.fs with comprehensive test coverage</name>
  <files>FunLang.Tests/BidirTests.fs, FunLang.Tests/FunLang.Tests.fsproj</files>
  <action>
Create BidirTests.fs with tests validating bidirectional type checking.

**Test structure (using Expecto):**
```fsharp
module BidirTests

open Expecto
open Ast
open Type
open Bidir
open Infer

// Helper to parse and get type
let parseAndSynth code =
    let lexbuf = FSharp.Text.Lexing.LexBuffer<_>.FromString code
    let expr = Parser.start Lexer.token lexbuf
    Bidir.synthTop Map.empty expr

// Helper to compare with Algorithm W
let parseAndInfer code =
    let lexbuf = FSharp.Text.Lexing.LexBuffer<_>.FromString code
    let expr = Parser.start Lexer.token lexbuf
    let _, ty = Infer.infer Map.empty expr
    ty
```

**Test groups:**

**1. Literals (BIDIR-03):**
```fsharp
testCase "synth number returns TInt" <| fun _ ->
    Expect.equal (parseAndSynth "42") TInt "number should be int"

testCase "synth bool returns TBool" <| fun _ ->
    Expect.equal (parseAndSynth "true") TBool "bool should be bool"

testCase "synth string returns TString" <| fun _ ->
    Expect.equal (parseAndSynth "\"hello\"") TString "string should be string"
```

**2. Variables (BIDIR-03):**
```fsharp
testCase "synth unbound variable raises error" <| fun _ ->
    Expect.throws (fun () -> parseAndSynth "x" |> ignore) "unbound should error"
```

**3. Lambda - Hybrid approach (BIDIR-05):**
```fsharp
testCase "synth unannotated lambda uses fresh var" <| fun _ ->
    let ty = parseAndSynth "fun x -> x"
    match ty with
    | TArrow (TVar a, TVar b) when a = b -> ()
    | _ -> failwith (sprintf "Expected 'a -> 'a, got %A" ty)

testCase "synth lambda matches Algorithm W" <| fun _ ->
    let bidirTy = parseAndSynth "fun x -> x + 1"
    let inferTy = parseAndInfer "fun x -> x + 1"
    Expect.equal (formatTypeNormalized bidirTy) (formatTypeNormalized inferTy) "should match"
```

**4. Application (BIDIR-03):**
```fsharp
testCase "synth application infers result type" <| fun _ ->
    let ty = parseAndSynth "(fun x -> x + 1) 5"
    Expect.equal ty TInt "should be int"

testCase "synth application matches Algorithm W" <| fun _ ->
    let bidirTy = parseAndSynth "(fun f -> fun x -> f x) (fun y -> y)"
    let inferTy = parseAndInfer "(fun f -> fun x -> f x) (fun y -> y)"
    Expect.equal (formatTypeNormalized bidirTy) (formatTypeNormalized inferTy) "should match"
```

**5. Let-polymorphism (BIDIR-07):**
```fsharp
testCase "let-polymorphism preserved" <| fun _ ->
    let ty = parseAndSynth "let id = fun x -> x in (id 1, id true)"
    match ty with
    | TTuple [TInt; TBool] -> ()
    | _ -> failwith (sprintf "Expected int * bool, got %A" ty)

testCase "let-polymorphism matches Algorithm W" <| fun _ ->
    let code = "let id = fun x -> x in let f = fun y -> id y in f 42"
    let bidirTy = parseAndSynth code
    let inferTy = parseAndInfer code
    Expect.equal (formatTypeNormalized bidirTy) (formatTypeNormalized inferTy) "should match"
```

**6. If expression:**
```fsharp
testCase "synth if expression" <| fun _ ->
    let ty = parseAndSynth "if true then 1 else 2"
    Expect.equal ty TInt "should be int"

testCase "synth if matches Algorithm W" <| fun _ ->
    let code = "if true then fun x -> x else fun y -> y"
    let bidirTy = parseAndSynth code
    let inferTy = parseAndInfer code
    Expect.equal (formatTypeNormalized bidirTy) (formatTypeNormalized inferTy) "should match"
```

**7. Tuples and Lists:**
```fsharp
testCase "synth tuple" <| fun _ ->
    let ty = parseAndSynth "(1, true, \"hi\")"
    Expect.equal ty (TTuple [TInt; TBool; TString]) "should be tuple"

testCase "synth empty list" <| fun _ ->
    match parseAndSynth "[]" with
    | TList (TVar _) -> ()
    | ty -> failwith (sprintf "Expected 'a list, got %A" ty)

testCase "synth cons" <| fun _ ->
    let ty = parseAndSynth "1 :: []"
    Expect.equal ty (TList TInt) "should be int list"
```

**8. Match expression:**
```fsharp
testCase "synth match expression" <| fun _ ->
    let ty = parseAndSynth "match 1 with | 0 -> true | _ -> false"
    Expect.equal ty TBool "should be bool"

testCase "synth match matches Algorithm W" <| fun _ ->
    let code = "match [] with | [] -> 0 | h :: t -> 1"
    let bidirTy = parseAndSynth code
    let inferTy = parseAndInfer code
    Expect.equal (formatTypeNormalized bidirTy) (formatTypeNormalized inferTy) "should match"
```

**9. LetRec:**
```fsharp
testCase "synth letrec" <| fun _ ->
    let ty = parseAndSynth "let rec f x = if x = 0 then 1 else x * f (x - 1) in f 5"
    Expect.equal ty TInt "should be int"

testCase "synth letrec matches Algorithm W" <| fun _ ->
    let code = "let rec len xs = match xs with | [] -> 0 | _ :: t -> 1 + len t in len"
    let bidirTy = parseAndSynth code
    let inferTy = parseAndInfer code
    Expect.equal (formatTypeNormalized bidirTy) (formatTypeNormalized inferTy) "should match"
```

**10. Binary operators:**
```fsharp
testCase "synth arithmetic" <| fun _ ->
    Expect.equal (parseAndSynth "1 + 2 * 3") TInt "should be int"

testCase "synth comparison" <| fun _ ->
    Expect.equal (parseAndSynth "1 < 2") TBool "should be bool"

testCase "synth logical" <| fun _ ->
    Expect.equal (parseAndSynth "true && false") TBool "should be bool"
```

**Add to test project:**
Add BidirTests.fs to FunLang.Tests.fsproj after InferTests.fs.
  </action>
  <verify>
```bash
# Verify test file exists
wc -l FunLang.Tests/BidirTests.fs
# Should be >= 100 lines

# Verify test project includes BidirTests
grep "BidirTests" FunLang.Tests/FunLang.Tests.fsproj

# Run all tests
cd /home/shoh/vibe-coding/LangTutorial && dotnet run --project FunLang.Tests -- --summary
echo "Test exit code: $?"

# Check for specific test coverage
grep -c "testCase" FunLang.Tests/BidirTests.fs
# Should be >= 15 test cases
```
  </verify>
  <done>
BidirTests.fs created with 15+ test cases covering:
- Literals, variables, lambda, application (BIDIR-03, BIDIR-05)
- Let-polymorphism (BIDIR-07)
- If, tuples, lists, match, letrec
- Binary operators
- Algorithm W comparison tests for backward compatibility
All tests pass including existing 378+ tests.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify no regressions</name>
  <files>N/A</files>
  <action>
Run the complete test suite to verify:
1. All new Bidir tests pass
2. All existing 378+ tests still pass (no regressions)
3. fslit tests (66) still pass

```bash
# Expecto tests
cd /home/shoh/vibe-coding/LangTutorial
dotnet run --project FunLang.Tests -- --summary

# fslit tests
make -C tests
```

If any test fails:
1. Identify the failing test
2. Check if it's a Bidir implementation issue
3. Fix the issue in Bidir.fs
4. Re-run tests until all pass
  </action>
  <verify>
```bash
# Full Expecto test run
cd /home/shoh/vibe-coding/LangTutorial && dotnet run --project FunLang.Tests -- --summary 2>&1 | tail -5

# fslit tests
make -C /home/shoh/vibe-coding/LangTutorial/tests 2>&1 | tail -3
```
  </verify>
  <done>
All tests pass:
- Expecto tests: 378+ existing + new Bidir tests
- fslit tests: 66 passing
No regressions introduced.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

```bash
# 1. Build verification
dotnet build /home/shoh/vibe-coding/LangTutorial --verbosity quiet && echo "Build: PASS"

# 2. Test count verification
dotnet run --project /home/shoh/vibe-coding/LangTutorial/FunLang.Tests -- --summary 2>&1 | grep -E "passed|failed"

# 3. fslit verification
make -C /home/shoh/vibe-coding/LangTutorial/tests 2>&1 | grep -E "passed|failed|PASS"

# 4. Backward compatibility check (compare types for common expressions)
cd /home/shoh/vibe-coding/LangTutorial
for expr in "42" "true" "fun x -> x" "fun x -> x + 1" "let id = fun x -> x in id 1"; do
  echo "Testing: $expr"
done
```
</verification>

<success_criteria>
1. FunLang.fsproj includes Bidir.fs in correct build order
2. Project builds successfully with Bidir.fs
3. BidirTests.fs exists with >= 15 test cases
4. All Bidir tests pass
5. All existing 378+ Expecto tests pass
6. All 66 fslit tests pass
7. synthTop produces same types as Infer.infer for unannotated code (verified by comparison tests)
</success_criteria>

<output>
After completion, create `.planning/phases/03-bidirectional-core/03-02-SUMMARY.md`
</output>
