---
phase: 03-bidirectional-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FunLang/Bidir.fs
autonomous: true

must_haves:
  truths:
    - "synth function infers types for synthesizing expressions"
    - "check function verifies expressions against expected types"
    - "Literals, variables, applications synthesize correctly"
    - "Lambdas check against arrow types"
    - "Unannotated lambdas use fresh type variables (hybrid approach)"
    - "Subsumption bridges synthesis to checking via unification"
    - "Let-polymorphism preserved with generalize at let boundaries"
  artifacts:
    - path: "FunLang/Bidir.fs"
      provides: "Bidirectional type checker module"
      exports: ["synth", "check", "synthTop"]
      min_lines: 150
  key_links:
    - from: "FunLang/Bidir.fs"
      to: "FunLang/Elaborate.fs"
      via: "open Elaborate; elaborateTypeExpr for Annot/LambdaAnnot"
      pattern: "elaborateTypeExpr"
    - from: "FunLang/Bidir.fs"
      to: "FunLang/Unify.fs"
      via: "unifyWithContext for subsumption and type matching"
      pattern: "unifyWithContext"
    - from: "FunLang/Bidir.fs"
      to: "FunLang/Infer.fs"
      via: "freshVar, instantiate, generalize reused"
      pattern: "Infer\\.freshVar|Infer\\.instantiate|Infer\\.generalize"
---

<objective>
Create the Bidir.fs module implementing bidirectional type checking with synthesis and checking modes.

Purpose: This is the core of the v6.0 type system - mutually recursive synth/check functions that will eventually replace Algorithm W.
Output: FunLang/Bidir.fs with complete bidirectional type checker for all expression forms
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-bidirectional-core/03-RESEARCH.md

# Existing infrastructure to reuse
@FunLang/Type.fs
@FunLang/Unify.fs
@FunLang/Infer.fs
@FunLang/Elaborate.fs
@FunLang/Diagnostic.fs
@FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Bidir.fs with synth/check functions</name>
  <files>FunLang/Bidir.fs</files>
  <action>
Create FunLang/Bidir.fs implementing bidirectional type checking.

**Module structure:**
```fsharp
module Bidir

open Ast
open Type
open Unify
open Elaborate
open Diagnostic
open Infer  // Reuse freshVar, instantiate, generalize
```

**Implement synth function (BIDIR-01, BIDIR-03, BIDIR-05):**
Returns `Subst * Type` (substitution and inferred type).

Pattern match on expression forms:
1. **Literals** (BIDIR-03): Number -> (empty, TInt), Bool -> (empty, TBool), String -> (empty, TString)
2. **Variables** (BIDIR-03): Lookup in env, instantiate scheme, error if unbound
3. **Application** (BIDIR-03): Synth func, synth arg, check func is arrow type, unify, return result type
4. **Lambda (unannotated)** (BIDIR-05): Fresh var for param (HYBRID approach), synth body, return TArrow
5. **LambdaAnnot** (annotated): Elaborate paramTyExpr, synth body with param in env, return TArrow
6. **Annot** (e : T): Elaborate tyExpr, check e against it, return annotation type
7. **Let** (BIDIR-07): Synth value, generalize, synth body with polymorphic binding
8. **LetRec**: Fresh vars for func/param, synth body, unify with arrow, generalize, synth expr
9. **If**: Synth all branches (switching to check mode handled by subsumption if needed)
10. **Binary operators** (Add, Equal, And, etc.): Check operands against expected types, return result type
11. **Negate**: Check operand against TInt, return TInt
12. **Tuple**: Synth each element, return TTuple
13. **EmptyList**: Return TList with fresh var
14. **List literal**: Synth elements, unify all element types
15. **Cons**: Synth head, synth tail, unify tail with TList head
16. **Match**: Synth scrutinee, infer patterns, synth/check clauses

**Implement check function (BIDIR-02, BIDIR-04, BIDIR-06):**
Returns `Subst` (substitution that makes expression have expected type).

Pattern match on (expr, expected) pairs:
1. **Lambda against TArrow** (BIDIR-04): Extract param type from expected, check body against result type
2. **If against expected**: Check condition against TBool, check both branches against expected
3. **Fallback subsumption** (BIDIR-06): Synth expression, unify result with expected

**Implement synthTop entry point:**
```fsharp
/// Top-level entry: infer type for expression
let synthTop (env: TypeEnv) (expr: Expr): Type =
    let s, ty = synth [] env expr
    apply s ty
```

**Critical implementation details:**
- Thread InferContext through all recursive calls (reuse existing ctx patterns from Infer.fs)
- Apply substitutions eagerly: `applyEnv s env` before recursive calls, `apply s ty` before unification
- Composition order: `compose s3 (compose s2 s1)` for s1 then s2 then s3
- Subsumption unify order: `unifyWithContext ctx [] span (apply s expected) actual` (blame actual)
- Reuse Infer.freshVar (1000+ range), Infer.instantiate, Infer.generalize from existing module
- Reuse Infer.inferPattern for pattern inference in Match

**Do NOT:**
- Create new freshVar counter (reuse Infer.freshVar)
- Create new generalize/instantiate (reuse from Infer)
- Skip InferContext threading
- Forget eager substitution application
  </action>
  <verify>
```bash
# File exists with correct module structure
head -10 FunLang/Bidir.fs
# Should show: module Bidir, open statements

# Check exported functions
grep -E "^let rec synth|^and check|^let synthTop" FunLang/Bidir.fs
# Should show all three functions

# Verify key patterns
grep -c "elaborateTypeExpr" FunLang/Bidir.fs  # >= 2 (Annot, LambdaAnnot)
grep -c "unifyWithContext" FunLang/Bidir.fs   # >= 5 (multiple unification points)
grep -c "Infer.freshVar" FunLang/Bidir.fs     # >= 3 (lambda, letrec, etc.)
grep -c "Infer.generalize" FunLang/Bidir.fs   # >= 2 (let, letrec)
```
  </verify>
  <done>
Bidir.fs exists with:
- synth function handling all 16+ expression forms
- check function with lambda/if checking and subsumption fallback
- synthTop entry point for top-level inference
- Proper reuse of Infer.freshVar, instantiate, generalize
- Elaborate.elaborateTypeExpr used for Annot and LambdaAnnot
- unifyWithContext used for type matching
- InferContext threading throughout
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pattern inference to Bidir module</name>
  <files>FunLang/Bidir.fs</files>
  <action>
Ensure the Bidir module properly handles pattern matching by reusing Infer.inferPattern.

**For Match expression in synth:**
```fsharp
| Match (scrutinee, clauses, span) ->
    let s1, scrutTy = synth (InMatch span :: ctx) env scrutinee
    let resultTy = Infer.freshVar()
    let folder (s, idx) (pat, expr) =
        let patEnv, patTy = Infer.inferPattern pat
        // Unify scrutinee with pattern type
        let s' = unifyWithContext ctx [] span (apply s scrutTy) patTy
        // Merge pattern env with current env
        let clauseEnv = Map.fold (fun acc k v -> Map.add k v acc)
                                 (applyEnv s' (applyEnv s env)) patEnv
        // Synth clause body (or check if we have expected type)
        let s'', exprTy = synth (InMatchClause (idx, span) :: ctx) clauseEnv expr
        // Unify with result type
        let s''' = unifyWithContext ctx [] span (apply s'' resultTy) exprTy
        (compose s''' (compose s'' (compose s' s)), idx + 1)
    let finalS, _ = List.fold folder (s1, 0) clauses
    (finalS, apply finalS resultTy)
```

**For LetPat expression in synth:**
```fsharp
| LetPat (pat, value, body, span) ->
    let s1, valueTy = synth ctx env value
    let patEnv, patTy = Infer.inferPattern pat
    let s2 = unifyWithContext ctx [] span (apply s1 valueTy) patTy
    let s = compose s2 s1
    let env' = applyEnv s env
    let generalizedPatEnv =
        patEnv
        |> Map.map (fun _ (Scheme (_, ty)) ->
            let ty' = apply s ty
            Infer.generalize env' ty')
    let bodyEnv = Map.fold (fun acc k v -> Map.add k v acc) env' generalizedPatEnv
    let s3, bodyTy = synth ctx bodyEnv body
    (compose s3 s, bodyTy)
```

This maintains exact Algorithm W behavior for pattern matching, ensuring backward compatibility (requirement BIDIR-07).
  </action>
  <verify>
```bash
# Verify Match and LetPat handling
grep -A 15 "| Match" FunLang/Bidir.fs | head -20
grep -A 15 "| LetPat" FunLang/Bidir.fs | head -20

# Verify Infer.inferPattern usage
grep -c "Infer.inferPattern" FunLang/Bidir.fs  # >= 2
```
  </verify>
  <done>
Match and LetPat expressions properly implemented in synth using Infer.inferPattern for pattern type inference and maintaining let-polymorphism.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

```bash
# 1. File structure check
wc -l FunLang/Bidir.fs
# Should be >= 150 lines

# 2. Module exports check
grep -E "^let rec synth|^and check|^let synthTop|^and inferBinaryOp" FunLang/Bidir.fs

# 3. Key pattern verification
grep "elaborateTypeExpr" FunLang/Bidir.fs  # Annot, LambdaAnnot handling
grep "Infer.generalize" FunLang/Bidir.fs   # Let-polymorphism
grep "unifyWithContext" FunLang/Bidir.fs   # Subsumption

# 4. Expression coverage check (all Expr variants)
for expr in Number Bool String Var Add Subtract Multiply Divide Negate Equal NotEqual LessThan GreaterThan LessEqual GreaterEqual And Or Lambda LambdaAnnot App If Let LetRec Tuple EmptyList List Cons Match LetPat Annot; do
  echo -n "$expr: "
  grep -c "| $expr" FunLang/Bidir.fs || echo "MISSING"
done
```
</verification>

<success_criteria>
1. FunLang/Bidir.fs exists with >= 150 lines
2. Module exports: synth, check, synthTop functions
3. All 16+ Expr variants handled in synth
4. check function handles Lambda against TArrow, If, and subsumption fallback
5. Reuses Infer.freshVar, Infer.instantiate, Infer.generalize
6. Uses Elaborate.elaborateTypeExpr for Annot and LambdaAnnot
7. Uses unifyWithContext for all type matching
8. InferContext threaded through all recursive calls
9. Eager substitution application pattern followed
</success_criteria>

<output>
After completion, create `.planning/phases/03-bidirectional-core/03-01-SUMMARY.md`
</output>
