---
phase: 02-substitution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [FunLang/Type.fs]
autonomous: true

must_haves:
  truths:
    - "apply correctly substitutes type variables, including transitive chains"
    - "compose chains substitutions in correct order (s2 after s1)"
    - "applyScheme does NOT substitute bound (forall) variables"
    - "freeVars identifies all free type variables in types"
    - "freeVarsScheme excludes bound variables from result"
    - "freeVarsEnv collects all free variables from environment"
  artifacts:
    - path: "FunLang/Type.fs"
      provides: "Substitution and free variable operations"
      exports: [empty, singleton, apply, compose, applyScheme, applyEnv, freeVars, freeVarsScheme, freeVarsEnv]
  key_links:
    - from: "apply"
      to: "TVar case"
      via: "recursive apply for transitive substitution"
      pattern: "apply s t"
    - from: "compose"
      to: "apply"
      via: "Map.map applies s2 to s1 values"
      pattern: "Map.map.*apply"
    - from: "applyScheme"
      to: "apply"
      via: "removes bound vars before applying"
      pattern: "List.fold.*Map.remove"
---

<objective>
Implement substitution operations and free variable tracking for Type.fs

Purpose: Substitution is the foundational operation in Hindley-Milner type inference. These operations enable type variable replacement, substitution chaining, and tracking of unbound variables - all critical for the unification algorithm in Phase 3.

Output: Type.fs extended with apply, compose, applyScheme, applyEnv, freeVars, freeVarsScheme, freeVarsEnv functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-substitution/02-RESEARCH.md
@FunLang/Type.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement substitution operations</name>
  <files>FunLang/Type.fs</files>
  <action>
Add substitution operations to Type.fs after formatType function.

**Functions to add (in this order):**

1. `empty: Subst` - Empty substitution (Map.empty)
2. `singleton (v: int) (t: Type): Subst` - Single variable substitution
3. `apply (s: Subst) (ty: Type): Type` - Apply substitution to type
   - CRITICAL: TVar case must recursively apply: `apply s t` not just `t`
   - This handles transitive chains: {0 -> TVar 1, 1 -> TInt} applied to TVar 0 -> TInt
4. `compose (s2: Subst) (s1: Subst): Subst` - Compose two substitutions
   - Semantics: s2 after s1 (like function composition)
   - Implementation: Apply s2 to all values in s1, then merge s2 bindings
5. `applyScheme (s: Subst) (Scheme (vars, ty)): Scheme` - Apply to scheme
   - CRITICAL: Remove bound vars from s before applying
   - Bound vars (vars list) must NOT be substituted
6. `applyEnv (s: Subst) (env: TypeEnv): TypeEnv` - Apply to all schemes in env

**Reference implementation from docs/todo.md:**
```fsharp
let empty: Subst = Map.empty

let singleton (v: int) (t: Type): Subst = Map.ofList [(v, t)]

let rec apply (s: Subst) = function
    | TInt -> TInt
    | TBool -> TBool
    | TString -> TString
    | TVar n ->
        match Map.tryFind n s with
        | Some t -> apply s t  // CRITICAL: recursive for transitive
        | None -> TVar n
    | TArrow (t1, t2) -> TArrow (apply s t1, apply s t2)
    | TTuple ts -> TTuple (List.map (apply s) ts)
    | TList t -> TList (apply s t)

let compose (s2: Subst) (s1: Subst): Subst =
    let s1' = Map.map (fun _ t -> apply s2 t) s1
    Map.fold (fun acc k v -> Map.add k v acc) s1' s2

let applyScheme (s: Subst) (Scheme (vars, ty)): Scheme =
    let s' = List.fold (fun acc v -> Map.remove v acc) s vars
    Scheme (vars, apply s' ty)

let applyEnv (s: Subst) (env: TypeEnv): TypeEnv =
    Map.map (fun _ scheme -> applyScheme s scheme) env
```

**Do NOT:**
- Return `t` directly in TVar case (must be `apply s t`)
- Use wrong compose order (s2 must take precedence, s1 values get s2 applied)
- Apply substitution to bound variables in schemes
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang
```
Build succeeds with no errors. Functions are syntactically correct.
  </verify>
  <done>
Type.fs contains: empty, singleton, apply (with recursive TVar), compose, applyScheme (removes bound vars), applyEnv.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement free variable functions</name>
  <files>FunLang/Type.fs</files>
  <action>
Add free variable functions to Type.fs after substitution operations.

**Functions to add:**

1. `freeVars (ty: Type): Set<int>` - Free type variables in type
   - Recursive traversal returning Set (not list)
   - Primitives (TInt, TBool, TString) return empty set
   - TVar returns singleton set
   - Composite types union their parts
2. `freeVarsScheme (Scheme (vars, ty)): Set<int>` - Free vars in scheme
   - Set.difference removes bound variables from freeVars result
3. `freeVarsEnv (env: TypeEnv): Set<int>` - Free vars in entire environment
   - Union of freeVarsScheme over all schemes in env

**Reference implementation from docs/todo.md:**
```fsharp
let rec freeVars = function
    | TInt | TBool | TString -> Set.empty
    | TVar n -> Set.singleton n
    | TArrow (t1, t2) -> Set.union (freeVars t1) (freeVars t2)
    | TTuple ts -> ts |> List.map freeVars |> Set.unionMany
    | TList t -> freeVars t

let freeVarsScheme (Scheme (vars, ty)) =
    Set.difference (freeVars ty) (Set.ofList vars)

let freeVarsEnv (env: TypeEnv) =
    env |> Map.values |> Seq.map freeVarsScheme |> Set.unionMany
```

**Do NOT:**
- Use List instead of Set (would allow duplicates, break Set.difference)
- Forget to exclude bound variables in freeVarsScheme
  </action>
  <verify>
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet build FunLang
```
Build succeeds. All functions are accessible and correctly typed.
  </verify>
  <done>
Type.fs contains: freeVars (returns Set<int>), freeVarsScheme (excludes bound vars), freeVarsEnv (union over environment).
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Build verification:**
```bash
dotnet build FunLang
```
Must succeed with no errors or warnings.

2. **Function signature verification (F# Interactive):**
```bash
cd /home/shoh/vibe-coding/LangTutorial && dotnet fsi --use:FunLang/Type.fs --eval "
printfn \"empty: %A\" Type.empty
printfn \"singleton: %A\" (Type.singleton 0 Type.TInt)
let s = Map.ofList [(0, Type.TVar 1); (1, Type.TInt)]
printfn \"apply transitive: %A\" (Type.apply s (Type.TVar 0))
let s1 = Type.singleton 0 (Type.TVar 1)
let s2 = Type.singleton 1 Type.TInt
printfn \"compose: %A\" (Type.apply (Type.compose s2 s1) (Type.TVar 0))
let scheme = Type.Scheme([0], Type.TArrow(Type.TVar 0, Type.TVar 1))
let subst = Map.ofList [(0, Type.TInt); (1, Type.TBool)]
let applied = Type.applyScheme subst scheme
printfn \"applyScheme (bound var protected): %A\" applied
printfn \"freeVars: %A\" (Type.freeVars (Type.TArrow(Type.TVar 0, Type.TVar 1)))
printfn \"freeVarsScheme: %A\" (Type.freeVarsScheme scheme)
"
```

**Expected outputs:**
- `apply transitive`: TInt (not TVar 1)
- `compose`: TInt (TVar 0 -> TVar 1 -> TInt)
- `applyScheme`: Scheme bound var 0 unchanged, only free var 1 -> TBool
- `freeVars`: set [0; 1]
- `freeVarsScheme`: set [1] (0 is bound)
</verification>

<success_criteria>
1. Type.fs compiles with all 9 new functions
2. apply handles transitive substitution chains correctly
3. compose follows correct order (s2 after s1)
4. applyScheme protects bound variables from substitution
5. freeVars family uses Set<int> and correctly excludes bound variables
</success_criteria>

<output>
After completion, create `.planning/phases/02-substitution/02-01-SUMMARY.md`
</output>
